<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ThinkGeo.MapSuite</name>
    </assembly>
    <members>
        <member name="T:ThinkGeo.MapSuite.Layers.FeatureSource">
            <summary>
            	<para>The abstract class from which all feature sources inherit. Feature
                sources represent feature data that can be integrated into Map Suite.</para>
            	<para>This class is key, as it is the abstract class from which all other feature
                sources are derived. In this sense it encapsulates much of the logic for handling
                transactions and ensuring the data is consistent regardless of any projections
                applied.</para>
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.#ctor">
            <summary>This is the default constructor for the abstract FeatureSource class.</summary>
            <returns>None</returns>
            <remarks>
            As this method is protected, you may only add code to this method if you override
            it from an inheriting class.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.CustomColumnFetch">
            <summary>
            This event is raised when fields are requested in a feature source method that do
            not exist in the feature source. It allows you to supplement the data from any outside
            source you have.
            </summary>
            <remarks>
            This event is raised when fields are requested in a feature source method that do
            not exist in the feature source. It allows you to supplement the data from any outside
            source you have.<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.CommittingTransaction">
            <summary>
            This event is raised after the CommitTransaction method is called, but before the
            CommitTransactionCore is called.  This allows you access to the TransactionBuffer before the
            transaction is committed. It also allows you to cancel the pending commit of the
            transaction.
            </summary>
            <remarks>
            This event is raised before the CommitTransactionCore is called and allows you
            access to the TransactionBuffer before the transaction is committed. It also allows you
            to cancel the pending transaction. The TransactionBuffer is the object that stores all
            of the pending transactions and is accessible through this event to allow you to either
            add, remove or modify transactions.<br/>
            	<br/>
            In the event that you cancel the CommitTransaction method, the transaction remains intact and
            you will still be editing. This makes it a nice place to possibly check for
            connectivity before the TransactionCore code is run, which is where the records are
            actually committed. Calling the RollBackTransaction method is the only way to
            permanently cancel a pending transaction without committing it.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.CommittedTransaction">
            <summary>
            This event is raised after the CommitTransaction and the CommitTransactionCore
            are called and allows you access to the TransactionBuffer and the TransactionResults
            object before CommitTransaction method is returned.
            </summary>
            <remarks>
            	<para>This event is raised after the CommitTransactionCore is called and allows you
                access to the TransactionBuffer and the TransactionResults object before
                CommitTransaction method is returned.<br/>
            		<br/>
                With this event, you can analyse the results of the transaction and do any cleanup
                code necessary. In the event some of the records did not commit, you can handle
                those items here. The TransactionResults object is passed out of the
                CommitTransaction method so you could analyze it then; however, this is the only
                place where you have access to both the TransactionResults object and the
                TransactionBuffer object at the same time. These are useful together to try and
                determine what went wrong and possibly try and re-commit them.<br/>
            		<br/>
                At the time of this event you will technically be out of the current
                transaction.</para>
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.OpeningFeatureSource">
            <summary>This event is called before the opening of the FeatureSource.</summary>
            <remarks>
            This event is called before the opening of the FeatureSource. Technically, this
            event is called after the calling of the Open method on the FeatureSource, but before
            the protected OpenCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.OpenedFeatureSource">
            <summary>This event is called after the opening of the FeatureSource.</summary>
            <remarks>
            This event is called after the opening of the FeatureSource. Technically, this
            event is called after the calling of the Open method on the FeatureSource and after the
            protected OpenCore method is called.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.ClosingFeatureSource">
            <summary>This event is called before the closing of the FeatureSource.</summary>
            <remarks>
            This event is called before the closing of the FeatureSource. Technically, this
            event is called after the calling of the Close method on the FeatureSource, but before
            the protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureSource.ClosedFeatureSource">
            <summary>This event is called after the closing of the FeatureSource.</summary>
            <remarks>
            This event is called after the closing of the FeatureSource. Technically, this
            event is called after the calling of the Close method on the FeatureSource and after
            the protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnCustomColumnFetch(ThinkGeo.MapSuite.Layers.CustomColumnFetchEventArgs)">
            <summary>
            This method allows you to raise the CustomColumnFetch event from a derived
            class.
            </summary>
            <returns>None</returns>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            CustomColumnFetch event. This may be useful if you plan to extend the FeatureSource and
            you need access to user-definable field data.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is raised when fields are requested in a feature source method that do not
            exist in the feature source. It allows you supplement the data from any outside source
            you may have.<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnCommittingTransaction(ThinkGeo.MapSuite.Layers.CommittingTransactionEventArgs)">
            <summary>
            This method allows you to raise the CommittingTransaction event from a derived
            class.
            </summary>
            <returns>None</returns>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            CommittingTransaction event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is raised before the CommitTransactionCore is called and allows you access
            to the TransactionBuffer before the transaction is committed. It also allows you to
            cancel the pending transaction. The TransactionBuffer is the object that stores all of
            the pending transactions and is accessible through this event to allow you either add,
            remove or modify transactions.<br/>
            	<br/>
            In the event that you cancel the CommitTransaction method, the transaction remains intact and
            you will still be editing. This makes it a nice place to possibly check for
            connectivity before the TransactionCore code is run, which is where the records are
            actually committed. Calling the RollBackTransaction method is the only way to
            permanently cancel a pending transaction without committing it.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnCommittedTransaction(ThinkGeo.MapSuite.Layers.CommittedTransactionEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the CommittedTransaction event from a derived
            class.
            </summary>
            <remarks>
                You can call this method from a derived class to enable it to raise the
                CommittedTransaction event. This may be useful if you plan to extend the
                FeatureSource and you need access to the event.<br/>
            	<br/>
                Details on the event:<br/>
            	<br/>
            	<para>This event is raised after the CommitTransactionCore is called and allows you
                access to the TransactionBuffer and the TransactionResults object before
                CommitTransaction method is returned.<br/>
            		<br/>
                With this event, you can analyze the results of the transaction and do any cleanup
                code necessary. In the event some of the records did not commit, you can handle
                these items here. The TransactionResults object is passed out of the
                CommitTransaction method so you could analyze it then; however, this is the only
                place where you have access to both the TransactionResults object and the
                TransactionBuffer object at the same time. These are useful together to try and
                determine what went wrong and possibly try and re-commit them.<br/>
            		<br/>
                At the time of this event, you will technically be out of the current
                transaction.</para>
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnOpeningFeatureSource(ThinkGeo.MapSuite.Layers.OpeningFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpeningFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpeningFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the opening of the FeatureSource. Technically, this event is
            called after the calling of the Open method on the FeatureSource, but before the
            protected OpenCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnOpenedFeatureSource(ThinkGeo.MapSuite.Layers.OpenedFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpenedFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpenedFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the opening of the FeatureSource. Technically, this event is
            called after the calling of the Open method on the FeatureSource and after the
            protected OpenCore method is called.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnClosingFeatureSource(ThinkGeo.MapSuite.Layers.ClosingFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosingFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosingFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the closing of the FeatureSource. Technically, this event is
            called after the calling of the Close method on the FeatureSource, but before the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OnClosedFeatureSource(ThinkGeo.MapSuite.Layers.ClosedFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosedFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosedFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the closing of the FeatureSource. Technically, this event is
            called after the calling of the Close method on the FeatureSource and after the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.CanExecuteSqlQuery">
            <summary>
            This property specifies whether the FeatureSource can excute a SQL query or not.
            If it is false, then it will throw exception when these APIs are calleds: ExecuteScalar, ExecuteNonQuery, ExecuteQuery
            </summary>
            <remarks>The default implementation is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.CanExecuteSqlQueryCore">
            <summary>
            This property specifies whether the FeatureSource can excute a SQL query or not.
            If it is false, then it will throw exception when these APIs are calleds: ExecuteScalar, ExecuteNonQuery, ExecuteQuery
            </summary>
            <remarks>The default implementation is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.IsOpen">
            <summary>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </decimalDegreesValue>
            <remarks>
            Various methods on the FeatureSource require that it be in an open state. If one
            of those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the FeatureSource's Open method. The
            method will raise an exception if the current FeatureSource is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.IsOpenCore">
            <summary>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </decimalDegreesValue>
            <remarks>
            Various methods on the FeatureSource require that it be in an open state. If one
            of those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the FeatureSource's Open method. The
            method will raise an exception if the current FeatureSource is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.FeatureSourceColumns">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this property on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This property gets the columns of the feature source.
            </summary>
            <decimalDegreesValue>
            This property gets the columns of the feature source.
            </decimalDegreesValue>
            <remarks>
            None.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.IsInTransaction">
            <summary>
            This property returns true if the FeatureSource is in a transaction and false if
            it is not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureSource is in a transaction and false if
            it is not.
            </decimalDegreesValue>
            <remarks>
            To enter a transaction, you must first call the BeginTransaction method of the
            FeatureSource. It is possible that some FeatureSources are read-only and do not allow
            edits. To end a transaction, you must either call CommitTransaction or
            RollbackTransaction.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.IsTransactionLive">
            <summary>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the FeatureSource,
            such as spatial queries.
            </summary>
            <decimalDegreesValue>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the
            FeatureSource.
            </decimalDegreesValue>
            <remarks>
            The live transaction concept means that all of the modifications you perform during
            a transaction are live from the standpoint of the querying methods on the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.IsEditable">
            <summary>This property returns whether the FeatureSource allows edits or is read-only.</summary>
            <decimalDegreesValue>
            This property returns whether the FeatureSource allows edits or is read-only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read-only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call BeginTransaction and this property is false, then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource, it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default, the decimalDegreesValue is false, meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.Projection">
            <summary>
            This property holds the projection object that is used within the FeatureSource
            to ensure that features inside of the FeatureSource are projected.
            </summary>
            <decimalDegreesValue>This property returns the projections selected by the developer.</decimalDegreesValue>
            <remarks>
            By default this property is null, meaning that the data being passed back from any
            methods on the FeatureSource will be in the coordinate system of the raw data. When you
            specify a projection object in the property, all incoming and outgoing method
            calls will subject the features to projection.<br/>
            	<br/>
            For example, if the spatial database you are using has all of its data stored in decimal
            degrees, but you want to see the data in UTM, you would create a projection object
            that goes from decimal degrees to UTM and set that as the projection. With this one
            property set, we will ensure that it will seem to you the developer that all of the data
            in the FeatureSource is in UTM. That means every spatial query will return UTM projected
            shapes. You can even pass in UTM shapes for the parameters. Internally, we will ensure
            that the shapes are converted to and from the projection without any intervention
            on the developer's part.<br/>
            	<br/>
            In fact, even when you override virtual or abstract core methods in the FeatureSource,
            you will not need to know about projections at all. Simply work with the data in its
            native coordinate system. We will handle all of the projection at the high level
            method.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.GeoCache">
            <summary>
            The cache system.
            </summary>
            <remarks>You must set IsActive to true for the Cache system. The default is not active.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.FeatureIdsToExclude">
            <summary>
            A collection of strings representing record id of features not to get in the Layer.
            </summary>
            <remarks>
            This string collection is a handy place to specify what records not to get from the source.
            Suppose you have a shape file of roads and you want to hide the roads within a particular
            rectangle, simply execute GetFeaturesInsideBoundingBox() and add the id of the return
            features to the collection and forget about them. Since you can set this by Layer it
            makes is easy to determine what to and what not to.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSource.TransactionBuffer">
            <summary>
            The TransactionBuffer used in the Transaction System.
            </summary>
            <remarks>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ExecuteNonQuery(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ExecuteNonQueryCore(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByColumnValue(System.String,System.String,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByColumnValue(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByColumnValue(System.String,System.String)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByColumnValueCore(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ExecuteScalar(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ExecuteScalarCore(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ExecuteQuery(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ExecuteQueryCore(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetColumns">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the columns available for the FeatureSource and caches
            them.
            </summary>
            <returns>This method returns the columns available for the FeatureSource.</returns>
            <remarks>
            As this is the concrete method wrapping the GetColumnsCore, it is important to
            note that this method will cache the results to GetColumnsCore. What this means is that
            the first time this method is called it will call GetCollumnsCore, which is protected,
            and cache the results. The next time this method is called it will not call
            GetColumnsCore again. This was done to increase speed, as this is a critical method that
            is used very often in the internal code of the class.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the virtual core version of the Columns method, it is intended to
            be overridden in inherited version of the class. When overriding, you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way, the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example, if you have a
            FeatureSource that has three columns of information and the user calls a method that
            requests four columns of information (something they can do with custom fields), we will
            first compare what they are asking for to the results of the GetColumnsCore. This
            way we can strip out custom columns before calling other Core methods, which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields, please see the documentation on OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.RefreshColumns">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method refresh the columns available for the FeatureSource and caches
            them.
            </summary>
            <returns>This method refresh the columns available for the FeatureSource.</returns>
            <remarks>
            None.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetCount">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetCountCore. It will
            return whatever is returned by the GetCountCore method, along with any additions
            or subtractions made if you are in a transaction and that transaction is configured to
            be live. To determine what the default implementation of the abstract GetCountCore
            method is, please see the documentation for it.<br/>
            	<br/>
            The default implementation of GetCountCore uses the GetAllRecordsCore method to
            calculate how many records there are in the FeatureSource. We strongly recommend that
            you provide your own implementation for this method that will be more efficient.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetCount. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method GetCount. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient.<br/>
            		<br/>
                If you do not override this method, it will get the count by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example, in a
                ShapeFile the record count is in the main header of the file. Similarly, if you are
                using Oracle Spatial, you can execute a simple query to get the count of all of the
                records without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetBoundingBox">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetBoundingBoxCore. It
            will return whatever is returned by the GetBoundingBoxCore method, along with any
            additions or subtractions made if you are in a transaction and that transaction is
            configured to be live. To determine what the default implementation of the abstract
            GetBoundingBoxCore method is, please see the documentation for it.<br/>
            	<br/>
            The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method to
            calculate the bounding box of the FeatureSource. We strongly recommend that you provide
            your own implementation for this method that will be more efficient.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state, it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetBoundingBox. It does not take into account any transaction activity, as this is
                the responsibility of the concrete public method GetBoundingBox. In this way, as a
                developer, if you choose to override this method you do not have to consider
                transactions at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.<br/>
            		<br/>
                If you do not override this method, it will get the BoundingBox by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example, in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly, if you are using Oracle Spatial, you can execute a simple query to
                get the BoundingBox of all the records without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.CloneDeep">
            <summary>Create a copy of a FeatureSource using the deep clone process.</summary>
            <returns>A cloned FeatureSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.CloneDeepCore">
            <summary>Create a copy of a FeatureSource using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned FeatureSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.Open">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method OpenCore. The
                Open method plays an important role, as it is responsible for initializing the
                FeatureSource. Most methods on the FeatureSource will throw an exception if the
                state of the FeatureSource is not opened. When the map draws each layer, it will
                open the FeatureSource as one of its first steps, then after it is finished drawing
                with that layer it will close it. In this way we are sure to release all resources
                used by the FeatureSource.<br/>
            		<br/>
                When implementing the abstract method, consider opening files for file-based sources,
                connecting to databases in the database-based sources and so on. You will get a
                chance to close these in the Close method of the FeatureSource.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer, it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this virtual method ,consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.Close">
            <remarks>
            This method is the concrete wrapper for the abstract method CloseCore. The Close
            method plays an important role in the life cycle of the FeatureSource. It may be called
            after drawing to release any memory and other resources that were allocated since the
            Open method was called.<br/>
            	<br/>
            If you override the Core version of this method, it is recommended that you take
            the following things into account: This method may be called multiple times, so we
            suggest you write the method so that that a call to a closed FeatureSource is ignored and does
            not generate an error. We also suggest that in the Close you free all resources that
            have been opened. Remember that the object will not be destroyed, but will be re-opened
            possibly in the near future.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method closes the FeatureSource and releases any resources it was using.
            </summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.BeginTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is in transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not editable, it will throw an InvalidOperationException.</exception>
            <summary>This method starts a new transaction if the FeasuteSource allows editing</summary>
            <returns>None</returns>
            <remarks>
            This method is used to start a transaction, assuming that the FeatureSource allows
            editing. There are some additional prerequisites to beginning a transaction, such as ensuring
            that a transaction is not already in progress. You must also be sure that the FeatureSource has
            been opened.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.AddFeature(ThinkGeo.MapSuite.Shapes.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <param name="feature">
            This parameter represents the new Feature that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.AddFeature(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction, it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature (composed of the passed-in BaseShape) to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature (composed of the passed-in BaseShape) to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <param name="shape">
            This parameter represents the BaseShape that will be used to make the new Feature that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.AddFeature(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IDictionary{System.String,System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction, it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature composes of the passed in BaseShape to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature (composed of the passed-in BaseShape) to an existing transaction. You will need to
            ensure that you have started a transaction by calling the BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <param name="shape">
            This parameter represents the BaseShape that will be used to make new Feature that will be added to the
            transaction.
            </param>
            <param name="columnValues">This parameter represents the columnValues for the new features taht will be added to the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.DeleteFeature(System.String)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method deletes a Feature from an existing transaction. You will need to
            ensure that you have started a transaction by calling the BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <summary>This method deletes a Feature from an existing transaction.</summary>
            <returns>None</returns>
            <param name="id">
            This string is the Id of the feature in the FeatureSource you wish to
            delete.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.UpdateFeature(ThinkGeo.MapSuite.Shapes.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the feature, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling the BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <param name="feature">The Feature you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.UpdateFeature(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the feature, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature (composed of the passed-in BaseShape) in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>This method updates a Feature (composed of the passed-in BaseShape) in an existing transaction.</summary>
            <param name="shape">The shape that will be used to make the new Feature that you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.UpdateFeature(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IDictionary{System.String,System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the feature, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature (composed of the passed in BaseShape) in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>This method updates a Feature (composed of the passed-in BaseShape) in an existing transaction.</summary>
            <param name="shape">The shape that will be used to make the new Feature that you wish to update in the transaction.</param>
            <param name="columnValues">This parameter represents the columnValues for the new features that will be added to the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.RollbackTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method will cancel an existing transaction. It will free up the internal
                memory cache of any InternalFeatures added, updated or deleted. You will need to ensure
                that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>
            This method will cancel an existing transaction. It will free up the internal
            memory cache of any InternalFeatures added, updated or deleted.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.CommitTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>
            The returned decimalDegreesValue of this method is a TransactionResult class, which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any errors that were encountered during the
            committing of the transaction.
            </returns>
            <remarks>
            	<para>This method is the concrete wrapper for the virtual method
                CommitTransactionCore. As this is the concrete version, the real work is done in the
                Core version of the method. It will commit the existing transaction to its
                underlying source of data. It will then pass back the results of the commit, including
                any error(s) received. Lastly, it will free up the internal memory cache
                of any InternalFeatures added, updated or deleted. You will need to ensure that you have
                started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will then pass back the results of the commit, including any error(s)
                received. If you are implementing your own FeatureSource, this is one of the
                crucial methods you must create. It should be fairly straightforward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter while
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <returns>
            The returned decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful, as well as any error(s) that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deletes that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetAllFeatures(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetAllFeatures(ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions, as this will be handled in the non-Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource outside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource outside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live,
            this method will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesInsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient. That is especially important for this method, as many
                other default virtual methods use this for their calculations. When you override this
                method, we recommend that you use any spatial indexes you have at your disposal
                to make this method as fast as possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesInsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient. That is especially important for this method, as many
                other default virtual methods use this for their calculations. When you override this
                method, we highly recommend that you use any spatial indexes you have at your disposal
                to make this method as fast as possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data that you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeatureIdsInsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the Ids of all of the InternalFeatures of this FeatureSource that are inside of the bounding box.
            </summary>
            <returns>
            The Ids of all of the InternalFeatures of this FeatureSource that are inside of the bounding box.
            </returns>
            <remarks>
            This method returns the Ids of all of the InternalFeatures of this FeatureSource that are inside of the specified bounding box. 
            If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeatureIdsInsideBoundingBoxCore uses the
            GetfeaturesInsideBoundingBoxCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatureIds inside of
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeatureIdsInsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the Ids of all of the InternalFeatures of this FeatureSource that are inside of the bounding box.
            </summary>
            <returns>
            The Ids of all of the InternalFeatures of this FeatureSource that are inside of the bounding box.
            </returns>
            <remarks>
            This method returns the Ids of all of the InternalFeatures of this FeatureSource that are inside of the specified bounding box. 
            If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeatureIdsInsideBoundingBoxCore uses the
            GetfeaturesInsideBoundingBoxCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatureIds inside of
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesForDrawing(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource that are inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesForDrawing uses the
                GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width
                and height. For example, we can determine if a feature is going to draw in only one
                to four pixels and in that case we may not draw the entire feature but just a
                subset of it instead.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="screenHeight">
            This parameter is the height of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesForDrawing(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource that are inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesForDrawing uses the
                GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width
                and height. For example, we can determine if a feature is going to draw in only one
                to four pixels and in that case we may not draw the entire feature but just a
                subset of it instead.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures that you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="screenHeight">
            This parameter is the height of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesForDrawingCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesForDrawingCore uses the
            GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width and
            height. For example, we can determine if a feature is going to draw in only one
            to four pixels and in that case we may not draw the entire feature but just a
            subset of it instead.
            </remarks>
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures that you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="screenHeight">
            This parameter is the height of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Layers.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Layers.QueryType,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Layers.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="feature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Layers.QueryType,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="feature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.SpatialQueryCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Layers.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified below. If you override this method, you do not need to
            consider transactions. It is suggested that if you are looking to speed up this method
            that you first override the GetFeaturesInsideBoundingBoxCore and then re-test this
            method, as it relies heavily on that method internally. See more information
            below.<br/>
            	<br/>
            	<strong>Spatial Query Types:</strong><br/>
            	<br/>
            	<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape have no points in common.<br/>
            	<br/>
            	<strong>Intersects</strong> - This method returns InternalFeatures where the specific Feature
            and the targetShape have at least one point in common.<br/>
            	<br/>
            	<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape have at least one boundary point in common, but no interior
            points.<br/>
            	<br/>
            	<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape share some but not all interior points.<br/>
            	<br/>
            	<strong>Within</strong> - This method returns InternalFeatures where the specific Feature lies
            within the interior of the targetShape.<br/>
            	<br/>
            	<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
            lies within the interior of the current shape.<br/>
            	<br/>
            	<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape share some but not all points in common.<br/>
            	<br/>
            	<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
            Feature and the target Shape are topologically equal.<br/>
            	<br/>
            The default implementation of SpatialQueryCore uses the
            GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We strongly
            recommend that you provide your own implementation for this method that will be more
            efficient. When you override this method, we recommend that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfFeatureSource">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is the feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is the target feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <param name="searchRadius">
            Limit the maximize distance proximately to search closest records.
            </param>
            <param name="unitOfSearchRadius">
            The unit of searchRadius parameter.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <param name="searchRadius">
            Limit the maximize distance proximately to search closest records.
            </param>
            <param name="unitOfSearchRadius">
            The unit of distanceLimits parameter.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesNearestToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape. It is important to note that the TargetShape and the FeatureSource must use
            the same unit, such as feet or meters. If they do not, then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live,
            then the results will include any transaction Feature that applies.<br/>
            <br/>
            The implementation we provided creates a small bounding box around the TargetShape
            and then queries the features inside of it. If we reach the number of items to find,
            then we measure the returned InternalFeatures to find the nearest. If we do not find enough
            records, we scale up the bounding box and try again. As you can see, this is not the
            most efficient method. If your underlying data provider exposes a more efficient way,
            we recommend you override the Core version of this method and implement it.<br/>
            <br/>
            The default implementation of GetFeaturesNearestCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient.
            When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When
                you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesWithinDistanceOfCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeatureById(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a Feature by providing its Id in the FeatureSource.</summary>
            <returns>This method returns a Feature by providing its Id in the FeatureSource.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore and only passes one Id in the
            collection. That method in turn calls the GetAllFeaturesCore. Because of this, if you
            want a more efficient version of this method, we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="id">
            This parameter is the Id which uniquely identifies it in the
            FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeatureById(System.String,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
            <summary>This method returns a Feature by providing its Id in the FeatureSource.</summary>
            <returns>This method returns a Feature by providing its Id in the FeatureSource.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore and only passes one Id in the
            collection. That method in turn calls the GetAllFeaturesCore. Because of this, if you
            want a more efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="id">
            This parameter is the Id which uniquely identifies it in the
            FeatureSource.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identifies the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identifies the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetBoundingBoxById(System.String)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method returns a bounding box by providing an Id. The internal
            implementation calls the GetFeaturesByIdsCore and only passes one Id in the collection.
            That method in turn calls the GetAllFeaturesCore. Because of this, if you want a more
            efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <summary>This method returns a bounding box based on the InternalFeatures Id specified.</summary>
            <returns>This method returns a bounding box based on the InternalFeatures Id specified.</returns>
            <param name="id">
            This parameter represents the Id for the InternalFeatures whose bounding box you
            want.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetBoundingBoxByIds(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </summary>
            <returns>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </returns>
            <remarks>
            This method returns a bounding boxes by providing a goupd of Ids. The internal
            implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids for the InternalFeatures whose bounding boxes
            you want.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetColumnNamesOutsideFeatureSource(System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that, as a
                general rule, returning column data of a Feature or a set of InternalFeatures happens
                inside the non-Core methods and we usually take care of it. However, as a developer,
                if you wish to add a new public method, then you will need to handle the projection
                yourself.<br/>
            		<br/>
                Let's say, for example, that you want to add a new Find method called FindLargeFeatures.
                You pass in a group of columns to return. Most of the time, the requested columns will
                actually be in the FeatureSource, but sometimes they will not. The way we allow users to get
                data from outside of the Feature Source is by raising an event called
                CustomColumnFetch. This way, we allow people to provide data that is outside of the
                FeatureSource. Since you will be implementing your own public method, you will want
                to support this as all of our other public methods do.<br/>
            		<br/>
                When you first enter the public method, you will want to separate out the fields
                that are in the FeatureSource from those that are not. You can call this method and
                the GetColumnNamesOutsideFeatureSource. If inside your public method you need to
                call any of our Core methods, then you need to make sure that you only pass in the
                list of column names that are in the FeatureSource. We assume that Core methods are
                simple and they do not handle this complexity.<br/>
            		<br/>
                With the list of non-FeatureSource column names, you simply loop through each column
                name for each record and call the OnCustomColumnFetch method while passing in the proper
                parameters. This will allow you give the user a chance to provide the values for
                the Feature's fields that were not in the FeatureSource. After that, you combine
                your results and pass them back out as the return.<br/>
            		<br/>
                public Collection&lt;Feature&gt; FindLargeFeatures(double AreaSize, IEnumerable
                &lt;string&gt; columnsToReturn)<br/>
                {</para>
            	<para>//Step 1: Separate the columns that are in the FeatureSource from those that
                are not.<br/>
            		<br/>
                // Step 2: Call any Core Methods and only pass in the columns that are in the
                FeatureSource</para>
            	<para>//Step3: For Each feature/column name combination, call the OnCustomFiedlFetch
                and allow your user to provide the custom data.<br/>
            		<br/>
                // Step4: Integrate the custom data with the result of the Core method plus any
                processing you did. Then return the consolidated result.<br/>
            		<br/>
                }</para>
            </remarks>
            <summary>
            This method returns the field names that are not in the FeatureSource from a list
            of provided field names.
            </summary>
            <returns>
            This method returns the field names that are not in the FeatureSource from a list
            of provided field names.
            </returns>
            <param name="returningColumnNames">
            This parameter is a list of field names, where not every field name may be in the
            FeatureSource.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetBoundingBoxesByIds(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </summary>
            <returns>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </returns>
            <remarks>
            This method returns a bounding boxes by providing a goupd of Ids. The internal
            implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids for the InternalFeatures whose bounding boxes
            you want.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFirstFeaturesWellKnownType">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the well known type that represents the first feature from FeatureSource.</summary>
            <returns>This method returns the well known type that represents the first feature from FeatureSource.</returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetFirstFeaturesWellKnownTypeCore. It will
            return whatever is returned by the GetFirstFeaturesWellKnownTypeCore method, along with any additions
            or subtractions made if you are in a transaction and that transaction is configured to
            be live. To determine what the default implementation of the abstract GetCountCore
            method is, please see the documentation for it.<br/>
            	<br/>
            The default implementation of GetFirstFeaturesWellKnownTypeCore uses the GetAllFeaturesCore method to
            get WellKnownType of the first feature from all features. We strongly recommend that
            you provide your own implementation for this method that will be more efficient.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFirstFeaturesWellKnownTypeCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the well known type that represents the first feature from FeatureSource.</summary>
            <returns>This method returns the well known type that represents the first feature from FeatureSource.</returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetFirstFeaturesWellKnownType. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method GetFirstFeaturesWellKnownType. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRFeaturesCore method to
                get WellKnownType of the first feature from all features. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient.<br/>
            		<br/>
                If you do not override this method, it will get the count by calling the
                GetAllFeaturesCore method and get WellKnownType of the first feature from all features. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example, in a
                ShapeFile the record count is in the main header of the file. Similarly, if you are
                using Oracle Spatial, you can execute a simple query to get the count of all of the
                records without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this, if you want a more
            efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnNames, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToExternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.RectangleShape})">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangles">This parameter represents a group of RectangleShapes that you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToInternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.RectangleShape})">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangles">This parameter represents a group of RectangleShapes that you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToExternalProjection(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a RectangleShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a RectangleShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangle">This parameter represents the rectangle you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToInternalProjection(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a RectangleShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a RectangleShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangle">This parameter represents the rectangle you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToInternalProjection(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="baseShape">This parameter represents the BaseShape you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToExternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="features">This parameter represents a group of Features that you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToInternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="features">This parameter represents the group of Features that you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToExternalProjection(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="feature">This parameter represents the Feature you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToInternalProjection(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="feature">This parameter represents the Feature you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetColumnNamesInsideFeatureSource(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method returns the field names that are in the FeatureSource from a list of
            provided field names.
            </summary>
            <returns>
            This method returns the field names that are in the FeatureSource from a list of
            provided field names.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that, as a
                general rule, returning column data of a Feature or a set of InternalFeatures happens
                inside the non-Core methods and we usually take care of it. However, as a developer,
                if you wish to add a new public method, then you will need to handle the projection
                yourself.<br/>
            		<br/>
                Let's say, for example, that you want to add a new Find method called FindLargeFeatures.
                You pass in a group of columns to return. Most of the time, the requested columns will
                actually be in the FeatureSource, but sometimes they will not. The way we allow users to get
                data from outside of the Feature Source is by raising an event called
                CustomColumnFetch. This way, we allow people to provide data that is outside of the
                FeatureSource. Since you will be implementing your own public method, you will want
                to support this as all of our other public methods do.<br/>
            		<br/>
                When you first enter the public method, you will want to separate out the fields
                that are in the FeatureSource from those that are not. You can call this method and
                the GetColumnNamesOutsideFeatureSource. If inside your public method you need to
                call any of our Core methods, then you need to make sure that you only pass in the
                list of column names that are in the FeatureSource. We assume that Core methods are
                simple and they do not handle this complexity.<br/>
            		<br/>
                With the list of non-FeatureSource column names, you simply loop through each column
                name for each record and call the OnCustomColumnFetch method while passing in the proper
                parameters. This will allow you give the user a chance to provide the values for
                the Feature's fields that were not in the FeatureSource. After that, you combine
                your results and pass them back out as the return.<br/>
            		<br/>
                public Collection&lt;Feature&gt; FindLargeFeatures(double AreaSize, IEnumerable
                &lt;string&gt; columnsToReturn)<br/>
                {</para>
            	<para>//Step 1: Separate the columns that are in the FeatureSource from those that
                are not.<br/>
            		<br/>
                // Step 2: Call any Core Methods and only pass in the columns that are in the
                FeatureSource</para>
            	<para>//Step3: For Each feature/column name combination, call the OnCustomFiedlFetch
                and allow your user to provide the custom data.<br/>
            		<br/>
                // Step4: Integrate the custom data with the result of the Core method plus any
                processing you did. Then return the consolidated result.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="returningColumnNames">
            This parameter is a list of column names, where not every field name may be in the
            FeatureSource.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.GetReturningColumnNames(ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
             <summary>
             Get returning columnNames according to the returningColumnType.
             </summary>
             <param name="returningColumnNamesType">The passed in returningColumnType.</param>
             <returns>The returning ColumnNames based on the given returningColumnNamesType.</returns>
            <remarks>The concreted FeatureSource can override this logic if needed.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.SplitColumnNames(System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method will split the column names based on our column syntax.</summary>
            <returns>This returns a single list of column names.</returns>
            <remarks>
            This method is meant to be used by advanced users who are creating their own new methods
            on the FeatureSource. We have a system where you can concatenate column names you specify
            anywhere in the system to create a unique string. For example, let's say you have
            a dataset that has the following columns: Name, Grade and Class, and you want to
            create a custom label for it. Whenever you specify the column you wanted to use in the
            label, you could use a string like this: "[Name] received a [Grade] in [Class]" and
            this would be valid. Behind the scenes, this method parses the string and returns the
            column names separately. Then, after we have the data, there is another helper
            method called CombineFieldValues that will add them back together again.<br/>
            	<br/>
            All of this happens normally in the concrete methods of the FeatureSource and
            inheriting classes; however, if you want to extend the classes and create your own
            concrete methods, then we suggest you use this to be compliant with the concatenation
            system.
            </remarks>
            <param name="columnNames">This parameter represents the column names you want to split.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.ConvertToDataTable(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method is a static API to get information about a group of passed-in features with the specified
            returningColumns, in the format of a DataTable.
            </summary>
            <param name="features">This parameter specifies the target features.</param>
            <param name="columnNames">This parameter specifies the returning columnNames for the features.</param>
            <returns>A DateTable of information about those passed-in features and the returning columnNames.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSource.CombineFieldValues(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method returns the re-combined collection of columns.</summary>
            <remarks>
            This method is meant to be used by advanced users who are creating their own new methods
            on the FeatureSource. We have a system where you can concatenate column names you specify
            anywhere in the system to create a unique string. For example, let's say you have
            a dataset that has the following columns: Name, Grade and Class, and you want to
            create a custom label for it. Whenever you specify the column you wanted to use in the
            label, you could use a string like this: "[Name] received a [Grade] in [Class]" and
            this would be valid. Behind the scenes, this method recombines the strings that were
            split in the SplitColumNames method.<br/>
            	<br/>
            All of this happens normally in the concrete methods of the FeatureSource and
            inheriting classes; however, if you want to extend the classes and create your own
            concrete methods, then we suggest you use this to be compliant with the concatenation
            system.
            </remarks>
            <returns>This method returns the re-combined collection of columns.</returns>
            <param name="columnValues">This parameter represents the split columns and their values.</param>
            <param name="originalColumnNames">This parameter is the original list of column names that may be combined.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Layer">
            <summary>This class is the base class for all types of Layers.</summary>
            <remarks>
            The Layer class is where all other types of layers are inherited from. It
            provides the base set of functionality. Though all Layers inherit from this class, we
            strongly suggest if you decide to create your own layer type that you consider
            inheriting from the higher level RasterLayer for image-based layers and FeatureLayer for
            feature-based layers. They provide a rich set of default operations for the various
            types of layers and are simple to inherit from.<br/>
            	<br/>
            As it is abstract, there are a number of methods you need to implement. The first is
            DrawCore. In this method, you are responsible for drawing the layer's representation.
            The other two required methods are OpenCore and CloseCore. These open and close the Layer. In
            the Open, you are responsible for getting the layer ready for drawing. You should open
            any file references, etc. In the Close, you need to clean up all file handles, close
            other objects etc. It is important that the Close puts the class in a state where it can
            be re-opened in the future. It is different than Dispose, as closed Layers will still
            exist and can be re-opened later in the mapping life cycle. Many methods (in the layer
            and in higher level objects) will require that the Layer be open before these methods
            are called, otherwise they will throw an exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.#ctor">
            <summary>This is the default constructor for the Layer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.IsOpen">
            <summary>This property returns true if the Layer is open and false if it is not.</summary>
            <decimalDegreesValue>This property returns true if the Layer is open and false if it is not.</decimalDegreesValue>
            <remarks>
            This method is the concrete wrapper for the abstract method IsOpenCore. Various
            methods on the Layer require that it be in an open state. If one of those methods is
            called when the state is not open, then the method will throw an exception. To enter the
            open state, you must call the Layer Open method. The method will raise an exception if
            the current Layer is already open.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.HasBoundingBox">
            <summary>
            This property indicates whether a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.IsOpenCore">
            <summary>This property returns true if the Layer is open and false if it is not.</summary>
            <decimalDegreesValue>This property returns true if the Layer is open and false if it is not.</decimalDegreesValue>
            <remarks>
            Various methods on the Layer require that it be in an open state. If one of those
            methods is called when the state is not open, then the method will throw an exception.
            To enter the open state, you must call the Layer Open method. The method will raise an
            exception if the current Layer is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.DrawingTime">
            <summary>This property gets the last drawing time for the layer.</summary>
            <decimalDegreesValue>This property gets the last drawing time for the layer.</decimalDegreesValue>
            <remarks>
            We track the drawing time for the layer and report it back in this method. This
            is useful for determining the speed of various layers.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.Name">
            <summary>This property gets and sets the name for the layer.</summary>
            <decimalDegreesValue>This property gets the name for the layer.</decimalDegreesValue>
            <remarks>
            The name is user defined. It is useful to set, as it may be used for higher level
            components such as legends, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.IsVisible">
            <summary>This property gets and set the visible state of the layer.</summary>
            <decimalDegreesValue>This property gets the visible state of the layer.</decimalDegreesValue>
            <remarks>
            If this property is set to false, the layer will not draw. We ensure this in the
            Draw method. This is useful for legends and other controls that control the visibility
            of layers.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.Transparency">
            <summary>
            This property gets and sets the amount of transparency to apply to the
            image.
            </summary>
            <value>This property gets the amount of transparency to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.BlueTranslation">
            <summary>This property gets and sets the amount of blue to apply to the image.</summary>
            <value>This property gets the amount of blue to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.RedTranslation">
            <summary>This property gets and sets the amount of red to apply to the image.</summary>
            <value>This property gets the amount of red to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.GreenTranslation">
            <summary>This property gets and sets the amount of green to apply to the image.</summary>
            <value>This property gets the amount of green to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.KeyColors">
            <summary>
            Gets a value represents a collection of key colors. If HasKeyColor property is false, it will throw exception when you use KeyColors.
            </summary>
            <remarks>It will make these colors transparent when draw image.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.IsNegative">
            <summary>
            This property gets and sets whether the image should be converted to negative (inverse colors).
            </summary>
            <value>This property gets and sets whether the image should be converted to negative (inverse colors).</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.IsGrayscale">
            <summary>
            This property gets and sets if the image should be converted to grayscale.
            </summary>
            <value>
            This property gets and sets if the image should be converted to grayscale.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.ColorMappings">
            <summary>
            ColorMapping
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Layer.DrawingExceptionMode">
            <summary>
            Gets or sets the DrawExcpetionMode when exception happens.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.CloneDeep">
            <summary>Create a copy of Layer using the deep clone process.</summary>
            <returns>A cloned Layer.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.CloneDeepCore">
            <summary>Create a copy of Layer using the deep clone process. The default implemenation uses serialization.</summary>
            <returns>A cloned Layer.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.Open">
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method OpenCore. The
                open method plays an important role, as it is responsible for initializing the Layer.
                Most methods on the Layer will throw an exception if the state of the Layer is not
                opened. When the map draws each layer, the layer will be opened as one of its first steps;
                then, after it is finished drawing with that layer, it will close it. In this way, we
                are sure to release all resources used by the Layer.<br/>
            		<br/>
                When implementing the abstract method, consider opening the FeatureSource or
                RasterSource. You will get a chance to close these in the Close method of the
                Layer.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.Close">
            <remarks>
            This method is the concrete wrapper for the abstract method CloseCore. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method closes the Layer and releases any resources it was using.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.GetBoundingBox">
            <summary>This method returns the bounding box of the Layer.</summary>
            <returns>This method returns the bounding box of the Layer.</returns>
            <remarks>
            This method is the concrete wrapper for the abstract method GetBoundingBoxCore.
            This method returns the bounding box of the RasterLayer.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the Layer.</summary>
            <returns>This method returns the bounding box of the Layer.</returns>
            <remarks>This method returns the bounding box of the Layer.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.Draw(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the worldExtent, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the geoImageOrNativeImage, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labeledInLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a mapUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.DrawException(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Exception)">
            <summary>
            This method will draw on the canvas when the layer.Draw throw exception and
            the DrawExceptionMode is set to DrawException instead of ThrowException.
            </summary>
            <param name="canvas">The target canvas to draw the layer.</param>
            <param name="e">The exception thrown when layer.Draw().</param>
            <remarks>This method can be overriden its logic by rewrite the DrawExceptionCore.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.DrawExceptionCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Exception)">
            <summary>
            This method will draw on the canvas when the layer.Draw throw exception and
            the DrawExceptionMode is set to DrawException instead of ThrowException.
            </summary>
            <param name="canvas">The target canvas to draw the layer.</param>
            <param name="e">The exception thrown when layer.Draw().</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Layer.DrawCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BinaryTileCache.GetTile(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BinaryTileCache.GetTiles(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method returns all the BitmapTiles within the passed in world extent, some of which may not has bitmap.
            </summary>
            <param name="worldExtent">The target worldExtent will be used to fetch all the BufferTile from.</param>
            <returns>Returns a collection of BufferTile within the passed in worldExtent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BinaryTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This abstract method returns the BufferTile corresponding to passed in row and column.
            Each concrete TileCache need to implement this logic to get tile from a row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BufferTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache">
            <summary>
            This class is a concrete class inherits from BitmapTileCache.
            In this class, the tiles will be saved in memory and it provides 
            some properties to control it very easily.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.MaximumTilesCount">
            <summary>
            This property gets or sets the maximum tiles count, if it exceed,it will delete the old first cached tiles.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.CachedTilesByScale">
            <summary>
            This property gets the Cached tiles,each item is a Dictionary with scale as its key.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column. 
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.SaveTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will save the target tile passed in.
            </summary>
            <param name="tile">The target tile to be saved.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.DeleteTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.ClearCacheCore">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryBitmapTileCache.GetHigherScaleTileCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
            <summary>
            This method overrides the logic in its base class BitmapTileCache.
            This method will return the HigherScale BitmapTile which is always used for preview 
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.BitmapTileCache">
            <summary>
            This is the base class for BitmapTileCache system which inherits from TileCache class.
            </summary>
            <remarks>TileCahce system is very efficient in improving the performance of
            application, especially when large data or remote server images are included.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.#ctor(System.String,ThinkGeo.MapSuite.Layers.TileImageFormat,ThinkGeo.MapSuite.Layers.TileMatrix)">
            <summary>
            This is the constructor of the class.
            </summary>
            <param name="cacheId">This is the cache identifier which marks its difference with other TileCache.</param>
            <param name="imageFormat">This is the imageFormate showing what kind of image we are trying to save.</param>
            <param name="tileMatrix">This is the tile matrix system which is used for caculating tiles.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BitmapTileCache.NoDataTileImage">
            <summary>
            This property returns back a preset image showing the tile data is missing.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BitmapTileCache.LoadingTileImage">
            <summary>
            This property returns back a preset image showing the Tile is loading.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BitmapTileCache.ImageFormat">
            <summary>
            Gets or sets the tile image format.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BitmapTileCache.JpegQuality">
            <summary>
            Gets or sets the Jpeg quality , this property only take effects when setting
            the ImageFormat to Jpeg.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.SaveTiles(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method will save the bitmap with its extent attached into tiles.
            </summary>
            <param name="image">The target bitmap to be saved into tiles.</param>
            <param name="imageExtent">The target extent for the bitmap.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the target bitmap, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.GetTile(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method returns the BitmapTile corresponding to the tile bounding box passed in.
            </summary>
            <param name="tileBoundingBox">The target boundingBox for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in boundingBox.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.GetTile(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.GetTiles(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method returns all the BitmapTiles within the passed in world extent, some of which may not has bitmap.
            </summary>
            <param name="worldExtent">The target worldExtent will be used to fetch all the BitmapTiles from.</param>
            <returns>Returns a collection of BitmapTiles within the passed in worldExtent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This abstract method returns the BitmapTile corresponding to passed in row and column.
            Each concrete TileCache need to implement this logic to get tile from a row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.GetHigherScaleTile(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
            <summary>
            This method will return the HigherScale BitmapTile which is always used for preview
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.GetHigherScaleTileCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
            <summary>
            This method is virtual and can be overriden by its sub classes.
            This method will return the HigherScale BitmapTile which is always used for preview
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTileCache.MergeBitmaps(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.BitmapTile},System.Double)">
            <summary>
            This method will merege the passed in bitmap tiles into a larege bitmap tile.
            </summary>
            <param name="tilesToMerge">The collection of tiles to be mereged.</param>
            <param name="scale">The target scale for result mereged bitmap tile.</param>
            <returns>Returns a merged bitmap tile.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Matrix">
            <summary>
            This class represents a base Matrix which encapsulate the tile caculation logics.
            </summary>
            <remarks>
            This class is abstract and designed to be inherited to create your own
            TileMatrix. The derived TileMatrix classes are typically used on a TileMatrixSet.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.#ctor">
            <summary>This method is the default protected constructor.</summary>
            <returns>None</returns>
            <remarks>If you use this constructor, you have to set the properties correctly before use it.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.#ctor(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner)">
            <summary>This method is the default protected constructor.</summary>
            <param name="boundingBox">This parameter specified the boundingBox of the Matrix.</param>
            <param name="cellHeight">This parameter specified the cell height(in DecimalDegrees) of the Matrix.</param>
            <param name="cellWidth">This parameter specified the cell width(in DecimalDegrees) of the Matrix.</param>
            <param name="id">This parameter specified the id of the Matrix.</param>
            <param name="referenceCorner">This parameter specified the cacluation reference corner of the Matrix.</param>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.#ctor(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner,System.Int64,System.Int64)">
            <summary>This method is the default protected constructor.</summary>
            <param name="cellHeight">This parameter specified the cell height(in DecimalDegrees) of the Matrix.</param>
            <param name="cellWidth">This parameter specified the cell width(in DecimalDegrees) of the Matrix.</param>
            <param name="id">This parameter specified the id of the Matrix.</param>
            <param name="referenceCorner">This parameter specified the cacluation reference corner of the Matrix.</param>
            <param name="columnCount">This parameter specified the column count of the Matrix.</param>
            <param name="rowCount">This parameter specified the row count of the Matrix.</param>
            <param name="referencePoint">This parameter specified the cacluation reference point of the Matrix.</param>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Matrix.CellWidth">
            <summary>
            This property gets the cell width of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Matrix.CellHeight">
            <summary>
            This property gets the cell height of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Matrix.BoundingBox">
            <summary>
            This property gets or sets the BouningBox of the Matrix.
            </summary>
            <remarks>The bounding box of the Matrix is related with the
            referencePoint, cellWidth, cellHeight and the rowCount and columnCount.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Matrix.RowCount">
            <summary>
            This property gets the row count of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Matrix.ColumnCount">
            <summary>
            This property gets the column count of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Matrix.Id">
            <summary>
            This property gets or sets the id of the Matrix.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetAllCells">
            <summary>This method returns all the cells of the TileMatrix.</summary>
            <returns>This method returns a collection of TileMatrixCell.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">The InvalidOperationException will be thown if too many cells(greater than maximumCellCount) are need to returned back.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetCell(System.Int64,System.Int64)">
            <summary>
            Get the cell by passing a specified row and column.
            </summary>
            <param name="row">This parameter specifies the row based on 1.</param>
            <param name="column">This parameter specifies the row based on 1.</param>
            <returns>The returning cell by specified the row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetCell(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            Get the cell by passing a specified point shape location.
            </summary>
            <param name="intersectingPoint">The parameter specified the target point location.</param>
            <returns>The returning cell by specifing the target point location.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetRowIndex(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            Get the row index by passing a specified point shape location.
            </summary>
            <param name="intersectingPoint">The parameter specified the target point location.</param>
            <returns>The returning row index by specifing the target point location.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetColumnIndex(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            Get the column index by passing a specified point shape location.
            </summary>
            <param name="intersectingPoint">The parameter specified the target point location.</param>
            <returns>The returning column index by specifing the target point location.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetIntersectingCells(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This method returns the intersecting cells of the TileMatrix.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns a collection of TileMatrixCell which intersecting with the passed in extent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">The InvalidOperationException will be thown if too many cells(greater than maximumCellCount) are need to returned back.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetContainedCells(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This method returns the contained cells of the TileMatrix.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns a collection of TileMatrixCell which contained in the passed in extent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">The InvalidOperationException will be thown if too many cells(greater than maximumCellCount) are need to returned back.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetIntersectingRowColumnRange(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This method returns the RowColumnRange of the TileMatrix intersects the passed in extent.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns the RowColumnRange intersects the passed in extent.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.GetContainedRowColumnRange(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This method returns the RowColumnRange of the TileMatrix contained the passed in extent.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns the RowColumnRange contained the passed in extent.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.SetMatrix(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner)">
            <summary>
            This method sets the Matrix system by passing in each variables.
            </summary>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="cellWidth">This parameter specifies the cell width(in decimalDegrees) to set the Matrix.</param>
            <param name="cellHeight">This parameter specifies the cell height(in decimalDegrees) to set the Matrix.</param>
            <param name="boundingBox">This parameter specifies the boundingBox to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>Accroding to the these given parameters, the referencePoint, rowCount, columnCount can be caculated.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.SetMatrix(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner,System.Int64,System.Int64)">
            <summary>
            This method sets the Matrix system by passing in each variables.
            </summary>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="cellWidth">This parameter specifies the cell width(in decimalDegrees) to set the Matrix.</param>
            <param name="cellHeight">This parameter specifies the cell height(in decimalDegrees) to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference Point to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Matrix.SetMatrix(System.Double,System.Double)">
            <summary>
            This method sets the Matrix system by passing the cellWidth and cellHeight.
            </summary>
            <param name="cellWidth">This parameter specifies the cell width(in decimalDegrees) to set the Matrix.</param>
            <param name="cellHeight">This parameter specifies the cell height(in decimalDegrees) to set the Matrix.</param>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.NativeImageTileCache">
            <summary>
            This is the base class for NativeTileCache system which inherits from TileCache class.
            </summary>
            <remarks>TileCahce system is very efficient in improving the performance of
            application, especially when large data or remote server images are included.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTileCache.#ctor(System.String,ThinkGeo.MapSuite.Layers.TileImageFormat,ThinkGeo.MapSuite.Layers.TileMatrix)">
            <summary>
            This is the constructor of the class.
            </summary>
            <param name="cacheId">This is the cache identifier which marks its difference with other TileCache.</param>
            <param name="imageFormat">This is the imageFormate showing what kind of image we are trying to save.</param>
            <param name="tileMatrix">This is the tile matrix system which is used for caculating tiles.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTileCache.GetTile(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method returns the NativeImageTile corresponding to the tile bounding box passed in.
            </summary>
            <param name="tileBoundingBox">The target boundingBox for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in boundingBox.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTileCache.GetTile(System.Int64,System.Int64)">
            <summary>
            This method returns the NativeImageTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.NativeImageTileCache.ImageFormat">
            <summary>
            Gets or sets the tile image format.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTileCache.GetTiles(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method returns all the NativeImageTiles within the passed in world extent.
            </summary>
            <param name="extent">The target worldExtent will be used to fetch all the NativeImageTiles from.</param>
            <returns>Returns a collection of NativeImageTiles within the passed in worldExtent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This abstract method returns the NativeImageTile corresponding to passed in row and column.
            Each concrete TileCache need to implement this logic to get tile from a row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RasterSource">
            <summary>
            The abstract class from which all raster sources inherit. Raster sources
            represent raster data that can be integrated into Map Suite.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.RasterSource.OpeningRasterSource">
            <summary>This event is called before the opening of the RasterSource.</summary>
            <remarks>
            This event is called before the opening of the RasterSource. Technically, this
            event is called after the calling of the Open method on the RasterSource, but before the
            protected OpenCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.RasterSource.OpenedRasterSource">
            <summary>This event is called after the opening of the RasterSource.</summary>
            <remarks>
            This event is called after the opening of the RasterSource. Technically, this event
            is called after the calling of the Open method on the RasterSource and after the
            protected OpenCore method is called.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.RasterSource.ClosingRasterSource">
            <summary>This event is called before the closing of the RasterSource.</summary>
            <remarks>
            This event is called before the closing of the RasterSource. Technically, this
            event is called after the calling of the Close method on the RasterSource, but before the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.RasterSource.ClosedRasterSource">
            <summary>This event is called after the closing of the RasterSource.</summary>
            <remarks>
            This event is called after the closing of the RasterSource. Technically, this event
            is called after the calling of the Close method on the RasterSource and after the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.#ctor">
            <summary>This is the default new constructor for the RasterSource.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.Transparency">
            <summary>
            This property gets and sets the amount of transparency to apply to the
            image.
            </summary>
            <value>This property gets the amount of transparency to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.BlueTranslation">
            <summary>This property gets and sets the amount of blue to apply to the image.</summary>
            <value>This property gets the amount of blue to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.RedTranslation">
            <summary>This property gets and sets the amount of red to apply to the image.</summary>
            <value>This property gets the amount of red to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.GreenTranslation">
            <summary>This property gets and sets the amount of green to apply to the image.</summary>
            <value>This property gets the amount of green to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.IsNegative">
            <summary>
            This property gets and sets whether the image should be converted to negative (inverse colors).
            </summary>
            <value>This property gets and sets whether the image should be converted to negative (inverse colors).</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.IsGrayscale">
            <summary>
            This property gets and sets if the image should be converted to grayscale.
            </summary>
            <value>
            This property gets and sets if the image should be converted to grayscale.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.ScaleFactor">
            <summary>
            The scale factor when drawing the primitive image. For example I am looking for an image with 100*100px, If the 
            ScaleFactor is set to 2, it means the component will get the image with 200*200px.  We want to keep it as 1 (by default)
            for most cases. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.OnOpeningRasterSource(ThinkGeo.MapSuite.Layers.OpeningRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpeningRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpeningRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the opening of the RasterSource. Technically, this event is
            called after the calling of the Open method on the RasterSource, but before the protected
            OpenCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.OnOpenedRasterSource(ThinkGeo.MapSuite.Layers.OpenedRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpenedRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpenedRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the opening of the RasterSource. Technically, this event is
            called after the calling of the Open method on the RasterSource and after the protected
            OpenCore method is called.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.OnClosingRasterSource(ThinkGeo.MapSuite.Layers.ClosingRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosingRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosingRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the closing of the RasterSource. Technically, this event is
            called after the calling of the Close method on the RasterSource, but before the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.OnClosedRasterSource(ThinkGeo.MapSuite.Layers.ClosedRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosedRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosedRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the closing of the RasterSource. Technically, this event is
            called after the calling of the Close method on the RasterSource and after the protected
            CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.CloneDeep">
            <summary>Create a copy of RasterSource using the deep clone process.</summary>
            <returns>A cloned RasterSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is: when shallow cloned,
            only the object is copied, but the contained objects are not; while in deep clone it
            does copy the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.CloneDeepCore">
            <summary>Create a copy of RasterSource using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned RasterSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is: when shallow cloned,
            only the object is copied, but the contained objects are not; while in deep clone it
            does copy the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetWorldFileText">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a string that represents the image's world file.</summary>
            <returns>This method returns a string that represents the image's world file.</returns>
            <remarks>
            This method wraps the Core version of this method and returns a string that
            represents the image's world file. The world file is a file type that can accompany
            image files. It contains information about the image's position, resolution and other
            spatial-related items. It is common to have this kind of file associated with generic
            image types such as JPG, BMP, and normal TIFF because they do not have a mechanism to
            store this data internally. Modern GIS image types such as JPEG2000, ECW, and MrSid
            typically have this information stored internally. We provide this method in the event
            that you want to create your own world file from any image that either already has one
            or has its data stored internally.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GenerateWorldFileText(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is Null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <summary>
            This method returns a string that represents the image's world file based on the
            parameters passed in.
            </summary>
            <returns>
            This method returns a string that represents the image's world file based on the
            parameters passed in.
            </returns>
            <remarks>
            This method returns a string that represents the image's world file. The world file
            is a file type that can accompany image files. It contains information about the image's
            position, resolution and other spatial-related items. It is common to have this kind of
            file associated with generic image types such as JPG, BMP, and normal TIFF because they
            do not have a mechanism to store this data internally. Modern GIS image types such as
            JPEG2000, ECW, and MrSid typically have this information stored internally. We provide
            this method in the event that you want to create your own world file from any image that
            either already has one or has its data stored internally.
            </remarks>
            <param name="worldExtent">This parameter represents the worldExtent of the image in world coordinates.</param>
            <param name="imageWidth">This parameter is the width of the image in screen coordinates.</param>
            <param name="imageHeight">This parameter is the height of the image in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetImageWidth">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <remarks>
            This method returns the width of the image in screen coordinates.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <returns>This method returns the width of the image in screen coordinates.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <returns>This method returns the width of the image in screen coordinates.</returns>
            <remarks>This abstract method is called from the concrete method GetImageWidth.
            You need to override it if you inherit from the RasterSource to return the width of your image.
            It returns the width of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetImageHeight">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>
            This method returns the height of the image in screen coordinates.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>This abstract method is called from the concrete method GetImageHeight.
            You need to override it if you inherit from the RasterSource to return the height of your image.
            It returns the height of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetHorizontalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the horizontal resolution of the image.</summary>
            <returns>This method returns the horizontal resolution of the image.</returns>
            <remarks>
            This method returns the horizontal resolution of the image.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetVerticalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the vertical resolution of the image.</summary>
            <returns>This method returns the vertical resolution of the image.</returns>
            <remarks>
            This method returns the vertical resolution of the image.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetBoundingBox">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>
            This method returns the bounding box of the RasterSource.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.IsOpen">
            <summary>
            This property returns true if the RasterSource is open and false if it is
            not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the RasterSource is open and false if it is
            not.
            </decimalDegreesValue>
            <remarks>
            Various methods on the RasterSource require that it be in an open state. If one
            of those methods is called when the state is not open, the method will throw an
            exception. To enter the open state, you must call the RasterSource's Open method. The
            method will raise an exception if the current RasterSource is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.HasProjectionText">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a RasterSource which is not open, it will throw an InvalidOperationException.</exception>
            <summary>
            This property returns true if the RasterSource has projection text, false if not.
            </summary>
            <remarks>
            Before you call GetProjectionText method, you should check this property to
            ensure that your RasterSource has projection information. It will throw an exception if
            there is no projection information in the RasterSource.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterSource.HasProjectionTextCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a RasterSource which is not open, it will throw an InvalidOperationException.</exception>
            <summary>
            This property returns true if the RasterSource has projection text, false if not.
            </summary>
            <remarks>
            	<para>This protected virtual method is called from the concrete public property
                HasProjectionText. The default implementation for this method returns false. So if
                you inherit RasterSource, please ensure that you override this virtual property to return
                the correct projection status of your RasterSource.</para>
            	<para></para>
            	<para>We will check the HasProjectionText status before you call the
                GetProjectionText method. It will throw an exception if the HasProjectionText
                property returns false.</para>
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetProjectionText">
            <summary>This method returns the projection text in proj4 format.</summary>
            <returns>This method returns the projection text in proj4 format.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetProjectionTextCore">
            <summary>
            This method returns the projection text in proj4 format.
            </summary>
            <returns>Projection text string.</returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetProjectionText.</para>
            	<para>The default implementation of this core method is to throw an exception. So you
                need to overwrite this method to return the RasterSource projection text.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.Open">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method OpenCore. The
                Open method plays an important role, as it is responsible for initializing the
                RasterSource. Most methods on the RasterSource will throw an exception if the state
                of the RasterSource is not opened. When the map draws each layer, it will open the
                RasterSource as one of its first steps; then, after it is finished drawing with that
                layer, it will close it. In this way, we are sure to release all resources used by
                the RasterSource.<br/>
            		<br/>
                When implementing the abstract method, consider opening files for file-based sources,
                connecting to databases in the database-based sources and so on. You will get a chance
                to close these in the Close method of the RasterSource.
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.OpenCore">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            RasterSource. Most methods on the RasterSource will throw an exception if the state of
            the RasterSource is not opened. When the map draws each layer, it will open the
            RasterSource as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            RasterSource.<br/>
            	<br/>
            When implementing this abstract method, consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the RasterSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.Close">
            <remarks>
            This method is the concrete wrapper for the abstract method CloseCore. The Close
            method plays an important role in the life cycle of the RasterSource. It may be called
            after drawing to release any memory and other resources that were allocated since the
            Open method was called.<br/>
            	<br/>
            If you override the Core version of this method, it is recommended that you take
            the following things into account: This method may be called multiple times, so we
            suggest you write the method so that that a call to a closed RasterSource is ignored and does
            not generate an error. We also suggest that in the Close you free all resources that
            have been opened. Remember that the object will not be destroyed, but will be re-opened
            possibly in the near future.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method closes the RasterSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.CloseCore">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The Close method plays an important role in the life cycle of the RasterSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed RasterSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetImage(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in. As the core version of this method is abstract, you will need to override it when
            creating your own RasterSource.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterSource.GetImageCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source that has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in. As the core version of this method is abstract, you will need to override it when
            creating our own RasterSource.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Tile">
            <summary>
            	<para>This is the base class which describle the Tile class. Tile concept is used
                as a rectangle image which will be saved in Memory or Hard disk to enhance the
                performance.</para>
            	<para></para>
            	<para>The Tile cache system is very popular in many GIS products including the
                GoogleMaps, VE Maps etc, the Tile can be considered a small subset used in the
                TileCache system.</para>
            </summary>
            <remarks>
            The Tile is the lowest level Tile in the Tile hierarchy. Directly
            inherited from Tile are BitmapTile, NativeImageTile. The methods and
            properties on Tile are the lowest common denominator for all the various kinds of
            Tiles. It marked abstract and is designed only to be inherited from.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Tile.#ctor">
            <summary>
            This is the default constructor for Tile.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Tile.#ctor(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
            <summary>
            This is the  constructor for Tile by passing the boundingBox and scale.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Tile.Scale">
            <summary>The scale to describe the Tile.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Tile.BoundingBox">
            <summary>The Bounding box to describe the Tile.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Tile.CloneDeep">
            <summary>This method shows the way to deep clone a Tile object.</summary>
            <returns>This method returns the cloned Tile object.</returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, In this way, we
            leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about
            this,please contact our support team as we would be happy to work with you on extending
            our framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Tile.CloneDeepCore">
            <summary>This method shows the way to override deep clone a Tile object.</summary>
            <returns>This method returns the cloned Tile object.</returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, In this way, we
            leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about
            this,please contact our support team as we would be happy to work with you on extending
            our framework.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TileAccessMode">
            <summary>This enumeration represents how the tileCache should access the tiles.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TileAccessMode.Default">
            <summary>The default mode is ReadAddDelete.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TileAccessMode.ReadOnly">
            <summary>This mode represents the tileCache just can read tiles from it.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TileAccessMode.ReadAdd">
            <summary>This mode represents the tileCache can read tiles from it and add tiles to it, but can not delete tiles.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TileAccessMode.ReadAddDelete">
            <summary>This mode represents the tileCache is no limited that can read, add, delete tiles.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TileCache">
            <summary>
            This is the base class for TileCache system.
            </summary>
            <remarks>TileCahce system is very efficient in improving the performance of
            application, especially when large data or remote server images are included.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.#ctor(System.String,ThinkGeo.MapSuite.Layers.TileMatrix)">
            <summary>
            This is the constructor of the class.
            </summary>
            <param name="cacheId">This is the cache identifier which marks its difference with other TileCache.</param>
            <param name="imageFormat">This is the imageFormate showing what kind of image we are trying to save.</param>
            <param name="tileMatrix">This is the tile matrix system which is used for caculating tiles.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileCache.TileMatrix">
            <summary>
            Gets or sets the TileMatrix which is used in caculation for tiles.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileCache.TileAccessMode">
            <summary>
            Gets or sets the Mode for the TileCache access the tiles. The Default value is ReadAddDelete
            </summary>
            <remarks>If you want it to take effect, you need set the Read property false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileCache.CacheId">
            <summary>
            Gets or sets the id of the TileCache.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.SaveTile(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will save the target tile passed in.
            </summary>
            <param name="tile">The target tile to be saved.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the target tile, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.DeleteTiles(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method will delete the tiles within the passed in worldExtent.
            </summary>
            <param name="worldExtent">The target extent to delete all tiles within it.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.DeleteTile(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the target tile, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.ClearCache">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.ClearCacheCore">
            <summary>
            This abstract method will clear all the tiles in the tileCache, for each
            sub TileCache class must implement this method.
            </summary>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.SaveTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This abstract method will save the target tile passed in, for each
            sub TileCache class must implement this method.
            </summary>
            <param name="tile">The target tile to be saved.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileCache.DeleteTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This abstract method will delete the target tile passed in, for each
            sub TileCache class must implement this method.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TileMatrix">
            <summary>
            This is the base class inherits from Matrix which describe the Matrix system used
            for Tilling system.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner,System.Int64,System.Int64)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>]
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference point location to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are caculated via these given parameters.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="boundingBox">This parameter specifies the boundingBox to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are caculated via these given parameters.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Layers.MatrixReferenceCorner)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are caculated via these given parameters.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrix.Scale">
            <summary>
            This property gets or sets the Scale for the TileMatrix.
            </summary>
            <remarks> When set a different Scale, it will recaculate the parameters in TileMatrix.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrix.TileWidth">
            <summary>
            This property gets or sets the TileWidth for the TileMatrix.
            </summary>
            <remarks> When set a different TileWidth, it will recaculate the parameters in TileMatrix.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrix.TileHeight">
            <summary>
            This property gets or sets the TileHeight for the TileMatrix.
            </summary>
            <remarks> When set a different TileHeight, it will recaculate the parameters in TileMatrix.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrix.BoundingBoxUnit">
            <summary>
            This property gets or sets the BoundingBoxUnit for the TileMatrix.
            </summary>
            <remarks> When set a different BoundingBoxUnit, it will recaculate the parameters in TileMatrix. Also,
            The default boundingBox value depends on the BoundingBoxUint.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrix.GetResolutionFromScale(System.Double)">
            <summary>
            This method will get resolution from scale and can be overridden.
            </summary>
            <param name="scale">This parameter specifies the target scale to get resolution from.</param>
            <returns>Returns the resolution corresponding to the passed in scale.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.BitmapTile">
            <summary>
            This class represents a NativeImageTile, which is defined as scale, RectangleBox
            and a byte array for its tile bitmap.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTile.#ctor">
            <summary>
            This is the default constructor without passing any parameters. All its
            properties should be set via the properties.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTile.#ctor(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing the boundingBox and scale.
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTile.#ctor(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing image bitmap and the boundingBox and scale.
             </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BitmapTile.Bitmap">
            <summary>This property is the Bitmap showing the tile image.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTile.Finalize">
            <summary>
            This method is the destructorof this class. Destructor cannot be called and only will be invoked automatically.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.BitmapTile.Dispose">
            <summary>
            This method is targeting releasing or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.BuildIndexMode">
            <summary>This enumeration represents whether an index should be rebuilt or not.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.BuildIndexMode.DoNotRebuild">
            <summary>Do not rebuild the index if it exists.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.BuildIndexMode.Rebuild">
            <summary>Rebuild the index if it exists.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ClosedFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosedFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ClosedFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ClosedRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosedRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ClosedRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ClosingFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosingFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ClosingFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ClosingRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosingRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ClosingRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <remarks>None</remarks>
            <returns>None</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.CommittedTransactionEventArgs">
            <summary>
            This class represents the parameters passed in through the CommittedTransaction
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.CommittedTransactionEventArgs.#ctor(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <summary>This is the constructor of the event arguments.</summary>
            <overloads>This is the constructor that allows you to pass in a transaction buffer.</overloads>
            <returns>None</returns>
            <param name="transactionBuffer">This parameter represents the transaction buffer that has been committed.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.CommittedTransactionEventArgs.#ctor">
            <summary>This is the constructor of the event arguments.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.CommittedTransactionEventArgs.TransactionBuffer">
            <summary>This property returns the transaction buffer that has been committed.</summary>
            <decimalDegreesValue>This property returns the transaction buffer that has been committed.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.CommittingTransactionEventArgs">
            <summary>
            This class represents the parameters passed in through the CommittingTransaction
            event.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.CommittingTransactionEventArgs.#ctor(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <overloads>This is the constructor that allows you to pass in a transaction buffer.</overloads>
            <summary>This is the default constructor for the event.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="transactionBuffer">
            This parameter represents the transaction buffer that needs to be
            committed.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.CommittingTransactionEventArgs.#ctor">
            <summary>This is the constructor of the event arguments.</summary>
            <overloads>This is the default constructor for the event arguments.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.CommittingTransactionEventArgs.Cancel">
            <summary>This property allows you to cancel the transaction.</summary>
            <decimalDegreesValue>This property allows you to cancel the transaction.</decimalDegreesValue>
            <remarks>This property allows you to cancel the transaction.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.CommittingTransactionEventArgs.TransactionBuffer">
            <summary>This property returns the transaction buffer that needs to be committed.</summary>
            <decimalDegreesValue>This property returns the transaction buffer that needs to be committed.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.CustomColumnFetchEventArgs">
            <summary>This class represents the parameters passed in through the CustomFieldFetch event.</summary>
            <remarks>
            CustomColumnFetch Event Background<br/>
            	<br/>
            This event is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.CustomColumnFetchEventArgs.#ctor(System.String,System.String)">
            <summary>This is the constructor that allows you to create the event arguments.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">The column name you need data for.</param>
            <param name="id">The Id of the feature you need data for.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.CustomColumnFetchEventArgs.ColumnName">
            <summary>This property returns the column name that you need to return data for.</summary>
            <decimalDegreesValue>This property returns the column name that you need to return data for.</decimalDegreesValue>
            <remarks>
            	<para>You will need to look up the Id in your external data source and find this
                column's data.<br/>
            		<br/>
            		<br/>
                CustomColumnFetch Event Background<br/>
            		<br/>
                This event is used primarily when you have data relating to a particular feature or set of
                features that is not within source of the data. For example, you may have a shape file
                of the world whose .dbf component describes the area and population of each country.
                Additionally, in an outside SQL Server table, you may also have data about the countries,
                and it is this data that you wish to use for determining how you want to color
                each country.<br/>
            	<br/>
                To integrate this SQL data, you simply create a file name that does not exist in the
                .dbf file.  Whenever Map Suite is queried to return records that specifically require
                this field, the FeatureSource will raise this event and allow you the developer to
                supply the data. In this way, you can query the SQL table and store the
                data in some sort of collection, and then when the event is raised, simply supply that
                data.<br/>
            	<br/>
                As this is an event, it will raise for each feature and field combination requested.
                This means that the event can be raised quite often, and we suggest that you cache the
                data you wish to supply in memory. We recommend against sending out a new SQL query
                each time this event is raised. Image that you are supplementing two columns and your query
                returns 2,000 rows. This means that if you requested those fields, the event would be raised
                4,000 times.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.CustomColumnFetchEventArgs.Id">
            <summary>This property returns the Id that you need to return data for.</summary>
            <decimalDegreesValue>This property returns the Id that you need to return data for.</decimalDegreesValue>
            <remarks>
            You will need to look up the Id in your external data source and find this
            field's data.<br/>
            	<br/>
            CustomColumnFetch Event Background<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.CustomColumnFetchEventArgs.ColumnValue">
            <summary>
            This parameter returns the field decimalDegreesValue that the event is seeking. It is intended
            to be set in the event.
            </summary>
            <decimalDegreesValue>
            This parameter returns the field decimalDegreesValue that the event is seeking. It is intended
            to be set in the event.
            </decimalDegreesValue>
            <remarks>
            When you lookup the Id and FieldName, you should set this property with the data
            from your external data source.<br/>
            	<br/>
            CustomColumnFetch Event Background<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EncryptedFileBitmapTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EncryptedFileBitmapTileCache.#ctor(System.String)">
            <summary>
            This is the overloads constructor.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <remarks>If you use this constructor, the other properties are set with default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EncryptedFileBitmapTileCache.#ctor(System.String,System.String)">
            <summary>
            This is the overloads constructor.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <remarks>If you use this constructor, the other properties are set with default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EncryptedFileBitmapTileCache.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.TileImageFormat,ThinkGeo.MapSuite.Layers.TileMatrix)">
            <summary>
            This is the constructor with all the parameters needed passed in.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <param name="imageFormat">This parameter specifies the image format of the tile cahce.</param>
            <param name="tileMatrix">This parameter specifies the tile matrix of the tile cache.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType">
            <summary>This enumeration represents the type of ExcutingSqlStatement.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetFeaturesByIds">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeauturesByIds.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetFeaturesByColumnValue">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeaturesByColumnValue.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetFeaturesOutsideBoundingBox">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeaturesOutsideBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetSpatialDataType">
            <summary> This value shows the type of ExcutingSqlStatement is GetSpatialDataType.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetBoundingBox">
            <summary> This value shows the type of ExcutingSqlStatement is GetBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetAllFeatures">
            <summary> This value shows the type of ExcutingSqlStatement is GetAllFeatures.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetCount">
            <summary> This value shows the type of ExcutingSqlStatement is GetCount.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetColumns">
            <summary> This value shows the type of ExcutingSqlStatement is GetColumns.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.BuildIndex">
            <summary> This value shows the type of ExcutingSqlStatement is BuildIndex.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.ExecuteScalar">
            <summary> This value shows the type of ExcutingSqlStatement is ExecuteScalar.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.ExecuteQuery">
            <summary> This value shows the type of ExcutingSqlStatement is ExecuteQuery.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.ExecuteNonQuery">
            <summary> This value shows the type of ExcutingSqlStatement is ExecuteNonQuery.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetFirstGeometryType">
            <summary> This value shows the type of ExcutingSqlStatement is GetFirstGeometryType.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.MakeAllGeometriesValid">
            <summary> This value shows the type of ExcutingSqlStatement is MakeAllGeometriesValid.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.Validate">
            <summary> This value shows the type of ExcutingSqlStatement is Validate.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.CommitTransactionEx">
            <summary> This value shows the type of ExcutingSqlStatement is CommitTransaction.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetFeaturesInsideBoundingBoxEx">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeaturesInsideBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.Unknown">
            <summary>Default value of this enumation, it has no idea of what type of ExcutingSqlStatement is for now.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.ExecuteSpatialQuery">
            <summary>This value shows the type of ExcutingSqlStatement is ExecuteSpatialQuery.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType.GetFeatureIds">
            <summary>This value shows the type of ExcutingSqlStatement is GetFeatureIds.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.FeatureCache">
            <summary>
            FeatureCache is a cache system used in FeatureSource to speed up the fetching
            data system.
            </summary>
            <remarks>
            The FeatureCache system uses the BoundingBox as the "Key" to cache the features.
            For example, if I first get data for a BoundingBox(BoundingBox1) and cache the
            features within the BoundingBox, in the future if I want to get the features within
            another BoundingBox(BoundingBox2) which is within BoundingBox1, I will get the
            features directly from the FeatureCache instead of from FileSystem or DBSystem.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.#ctor">
            <summary>
            This is the default constructor that will create a new instance of the
            FeatureCache.
            </summary>
            <returns>None</returns>
            <remarks>
            The cache system is not used by default.  If you want to use it, you must set
            the <strong>IsActive</strong> property to true.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureCache.IsActive">
            <summary>This boolean property sepcifies whether cache system is active or not.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.GetFeatures(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null, it will throw an ArgumentNullException.</exception>
            <summary>
            This method returns a Collection of Features cached in the FeatureCache system. All of the returning features
            are within the BoundingBox and were fetched from FileSystem or DBSystem in a previous operation.
            </summary>
            <returns>
            This method returns a Collection of Features cached in the FeatureCache system.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetFeaturesCore. It
            will return whatever is returned by the GetBoundingBoxCore method.
            To determine what the default implementation of the abstract
            GetBoundingBoxCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.GetFeaturesCore(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null, it will throw an ArgumentNullException.</exception>
            <summary>
            This method returns a Collection of Features cached in the FeatureCache system. All of the returning features
            are within the BoundingBox and were fetched from FileSystem or DBSystem in a previous operation.
            </summary>
            <returns>
            This method returns a Collection of Features cached in the FeatureCache system.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetFeaturesCore. It
            will return whatever is returned by the GetBoundingBoxCore method.
            To determine what the default implementation of the abstract
            GetBoundingBoxCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.Clear">
            <summary>
            This method clears all of the CachedItems in this FeatureCache.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.Add(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Shapes.Feature})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the WorldExtent, it will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method by passing a Invalid RectangleShape for the WorldExtent, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the Collection of features, it will throw an ArgumentNullException.</exception>
            <summary>
            This method will add an item to the FeatureCache system by passing a WorldExtent as "Key"
            and a collection of features as its corresponding cached features.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method AddCore. It
            will return whatever is returned by the AddCore method.
            To determine what the default implementation of the abstract
            AddCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.AddCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Shapes.Feature})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the WorldExtent, it will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method by passing a Invalid RectangleShape for the WorldExtent, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the Collection of features, it will throw an ArgumentNullException.</exception>
            <summary>
            This method will add an item to the FeatureCache system by passing a WorldExtent as "Key"
            and a collection of features as its corresponding cached features.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method AddCore. It
            will return whatever is returned by the AddCore method.
            To determine what the default implementation of the abstract
            AddCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.Open">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method OpenCore. It
            will return whatever is returned by the OpenCore method.
            To determine what the default implementation of the abstract
            OpenCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.OpenCore">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method OpenCore. It
            will return whatever is returned by the OpenCore method.
            To determine what the default implementation of the abstract
            OpenCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.Close">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method CloseCore. It
            will return whatever is returned by the CloseCore method.
            To determine what the default implementation of the abstract
            CloseCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.CloseCore">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method CloseCore. It
            will return whatever is returned by the CloseCore method.
            To determine what the default implementation of the abstract
            CloseCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureCache.IsExtentCached(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method determines whether the WorldExtent is already cached in the FeatureCache System.
            </summary>
            <param name="worldExtent">The target WorldExtent which will be determined as already cached or not.</param>
            <returns>True if the specified WorldExtent is already cached. Otherwise, returns false.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.FeatureSourceColumn">
            <summary>This class represents a column contained within a FeatureSource.</summary>
            <remarks>
            A FeatureSource is typically represented by a number of InternalFeatures and their column
            data. This column represents the characteristics of that data.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.#ctor">
            <summary>This is the constructor to create a FeatureSourceColumn.</summary>
            <overloads>This overload creates a FeatureSourceColumn that is empty.</overloads>
            <returns>None</returns>
            <remarks>This constructor is the default, but should not be used.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.#ctor(System.String)">
            <summary>This is the constructor to create a FeatureSourceColumn.</summary>
            <overloads>
            This overload creates a FeatureSourceColumn by specifying the column's name only.
            </overloads>
            <returns>None</returns>
            <remarks>This is the constructor that should be used.</remarks>
            <param name="columnName">This parameter represents the name of the column.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.#ctor(System.String,System.String,System.Int32)">
            <summary>This is the constructor to create a FeatureSourceColumn.</summary>
            <overloads>
            This overload creates a FeatureSourceColumn by specifying the column's name, type
            and max length.
            </overloads>
            <returns>None</returns>
            <remarks>This is the constructor that should be used.</remarks>
            <param name="columnName">This parameter represents the name of the column.</param>
            <param name="typeName">This parameter represents the type name of the column.</param>
            <param name="maxLength">This parameter represents the maximum length of the column.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.ColumnName">
            <summary>This property returns the name of the column.</summary>
            <decimalDegreesValue>This property returns the name of the column.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.TypeName">
            <summary>This property returns the type name of the column.</summary>
            <decimalDegreesValue>This property returns the type name of the column.</decimalDegreesValue>
            <remarks>
            This property is freeform and the type name is not tied to anything. It is wise
            to try and use familiar type names such as string, integer, date, etc., although it may
            not fit every different type of FeatureSource. We suggest thar you avoid using this property
            unless you know the types beforehand or simply want them for display purposes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.MaxLength">
            <summary>This property returns the maximum length of the column.</summary>
            <decimalDegreesValue>This property returns the maximum length of the column.</decimalDegreesValue>
            <remarks>
            The maximum length is user defined and not in any way enforced in our default
            FeatureSource implementation. It is mainly for display purposes or when dealing with a
            known Feature Source type.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureSourceColumn.ToString">
            <summary>
            Returns column name of FeatureSourceColumn
            </summary>
            <returns>Returns column name of FeatureSourceColumn</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.FileBitmapTileCache">
            <summary>
            This class is a concrete class inherits from BitmapTileCache.
            In this class, the tiles will be saved in disk and can be viewed very
            conveniently.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.#ctor(System.String)">
            <summary>
            This is the overloads constructor.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <remarks>If you use this constructor, the other properties are set with default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.#ctor(System.String,System.String)">
            <summary>
            This is the overloads constructor.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <remarks>If you use this constructor, the other properties are set with default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.TileImageFormat,ThinkGeo.MapSuite.Layers.TileMatrix)">
            <summary>
            This is the constructor with all the parameters needed passed in.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <param name="imageFormat">This parameter specifies the image format of the tile cahce.</param>
            <param name="tileMatrix">This parameter specifies the tile matrix of the tile cache.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.CacheDirectory">
            <summary>
            Gets or sets the cache direcory.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.SaveTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will save the target tile passed in, you could override this API to create your own logic.
            </summary>
            <param name="tile">The target tile to be saved.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.DeleteTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.ClearCacheCore">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileBitmapTileCache.GetHigherScaleTileCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
            <summary>
            This method overrides the logic in its base class BitmapTileCache.
            This method will return the HigherScale BitmapTile which is always used for preview
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache">
            <summary>
            This class is a concrete class inherits from NativeImageTileCache.
            In this class, the tiles will be saved in disk and can be viewed very
            conveniently.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.TileImageFormat,ThinkGeo.MapSuite.Layers.TileMatrix)">
            <summary>
            This is the constructor with all the parameters needed passed in.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <param name="imageFormat">This parameter specifies the image format of the tile cahce.</param>
            <param name="tileMatrix">This parameter specifies the tile matrix of the tile cache.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.CacheDirectory">
            <summary>
            Gets or sets the cache direcory.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This method returns the NativeImageTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.SaveTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will save the target tile passed in, you could override this API to create your own logic.
            </summary>
            <param name="tile">The target tile to be saved.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.DeleteTileCore(ThinkGeo.MapSuite.Layers.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileNativeImageTileCache.ClearCacheCore">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the Read is set to true.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.BuildRecordIdMode">
            <summary>This enumeration represents whether a record ID should be rebuilt or not.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.BuildRecordIdMode.DoNotRebuild">
            <summary>Do not rebuild the record ID if it exists.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.BuildRecordIdMode.Rebuild">
            <summary>Rebuild the record ID if it exists.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.DbfColumn">
            <summary>This class represents the column information specific to a DBF column.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DbfColumn.#ctor">
            <summary>This method is the constructor for the DbfColumn.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DbfColumn.#ctor(System.String,ThinkGeo.MapSuite.Layers.DbfColumnType,System.Int32,System.Int32)">
            <summary>This method is the constructor for the DbfColumn.</summary>
            <overloads>This constructor is intended to be used to create the object.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter represents the name of the column in the DBF.</param>
            <param name="columnType">This parameter represents the type of the column in the DBF.</param>
            <param name="length">This parameter represents the length of the column in the DBF.</param>
            <param name="decimalLength">
            This parameter represents the number of decimal places the column has, if it is a
            numeric type.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DbfColumn.ColumnType">
            <summary>This property returns the type of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the type of the column in the DBF.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DbfColumn.Length">
            <summary>This property returns the length of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the length of the column in the DBF.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DbfColumn.DecimalLength">
            <summary>This property returns the decimal length of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the decimal length of the column in the DBF.</decimalDegreesValue>
            <remarks>
            This is the number of decimal places the number represents. This is only
            applicable if the column type is numeric.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.DbfColumnType">
            <summary>This enumeration represents the column type in the DBF.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.Null">
            <summary>Null</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.Logical">
            <summary>
            1 byte to include:<br/>
            	<br/>
            ? - Default<br/>
            Y,y - Yes<br/>
            N,n - No<br/>
            F,f - False<br/>
            T,t - True
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.Memo">
            <summary>10 digit pointer to memo file.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.Date">
            <summary>Date in format - YYYYMMDD</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.DateTime">
            <summary>
            Chronological data consisting of month, day, year, hours, minutes, and seconds
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.IntegerInBinary">
            <summary>4 byte numeric type.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.DoubleInBinary">
            <summary>8 byte numeric type.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.Float">
            <summary>8 byte numeric type.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.DbfColumnType.Numeric">
            <summary>8 byte numeric type.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DbfColumnInfo.op_Addition(ThinkGeo.MapSuite.Layers.DbfColumnInfo,ThinkGeo.MapSuite.Layers.DbfColumnInfo)">
            <summary>This method is an override of the + functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DbfColumnInfo.op_Equality(ThinkGeo.MapSuite.Layers.DbfColumnInfo,ThinkGeo.MapSuite.Layers.DbfColumnInfo)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DbfColumnInfo.op_Inequality(ThinkGeo.MapSuite.Layers.DbfColumnInfo,ThinkGeo.MapSuite.Layers.DbfColumnInfo)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.OpenDbfFile(System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>
            Open the DBF file
            </summary>
            <param name="currentFileName">the file name</param>
            <param name="access">the access mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CreateDBFFile(System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>
            Create a DBF File
            </summary>
            <param name="FileName">the name of the new dbf file</param>
            <param name="access">the access mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GenerateDBTFile">
            <summary>
            Generate DBT file if memo fields exist in dbf
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.InitFileHeaderInfo(System.Byte[],ThinkGeo.MapSuite.Layers.GeoDbf)">
            <summary>
            Initialize the File Header Info by the first 32 bytes data
            </summary>
            <param name="arrFileHeader">the first 32 bytes data</param>
            <param name="dbfFile">The dbfFile to be initialized</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.InitFieldsHeaderInfo(System.Byte[],ThinkGeo.MapSuite.Layers.GeoDbf)">
            <summary>
            Initialize the Fields Header Info by the header data
            </summary>
            <param name="arrHeader">the file header data</param>
            <param name="dbfFile">The DBF File to be initialized</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadNativeAttribute(System.Int32,System.Int32)">
            <summary>
            Get the Native attribute in string
            </summary>
            <param name="iRecord">the Record Index</param>
            <param name="iField">the Field Index</param>
            <returns>the corresponding attribute in string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetValidSubString(System.Byte[])">
            <summary>
            Get Valid Length of the Input Bytes, Remove the End '\0'
            </summary>
            <param name="bytesIn">the input byte array</param>
            <returns>the Valid Sub String</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetValidSubString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get Valid Length of the Input Bytes, Remove the End '\0'
            </summary>
            <param name="bytesIn">the input byte array</param>
            <param name="length">the length of the bytes to be converted</param>
            <param name="nIndex">the start index of the bytes to be converted</param>
            <returns>the Valid Sub String</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadNativeAttributeInBytes(System.Int32,System.Int32)">
            <summary>
            Get the Native attribute in string
            </summary>
            <param name="iRecord">the Record Index</param>
            <param name="iField">the Field Index</param>
            <returns>the corresponding attribute in bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadNativeAttributeInBytes_UnEncrypted(System.Int32,System.Int32)">
            <summary>
            Get the Native attribute in string, For UnEncrypted File
            </summary>
            <param name="iRecord">the Record Index</param>
            <param name="iField">the Field Index</param>
            <returns>the corresponding attribute in bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadNativeAttributesInBytes(System.Int32)">
            <summary>
            Get the Native attribute in byte[]
            </summary>
            <param name="iRecord">the Record Index</param>
            <returns>the corresponding attribute in bytep[]</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadNativeAttributes_UnEncrypted(System.Int32)">
            <summary>
            Get the Native attribute in byte[], for UnEncrypted file
            </summary>
            <param name="iRecord">the Record Index</param>
            <returns>the corresponding attribute in bytep[]</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadDBTRecord(System.Int32)">
            <summary>
            Get the Record in DBT file accoring to the block index
            </summary>
            <param name="iBlock">the block index</param>
            <returns>the record in string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadDBTRecord_UnEncrypted(System.Int32)">
            <summary>
            Get the Record in DBT file accoring to the block index
            </summary>
            <param name="iBlock">the block index</param>
            <returns>the record in string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.FlushCurrentRecord">
            <summary>
            Flush the Current Record to disk
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.AddBlank(System.Byte[]@,System.Int32,System.Int32,System.Int32,System.Byte)">
            <summary>
            Add Blank Bytes to a bytes array
            </summary>
            <param name="arrUpdateBytes">the bytes array to Write</param>
            <param name="nOffset">the start Pos of the valid SubArray</param>
            <param name="nWrittenBytes">the written bytes in the Valid SubArray</param>
            <param name="nSize">the size of the Valid SubArray</param>
            <param name="byteBlank">the content for blank</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.Write2CurrentRecord(System.Int32,System.Object)">
            <summary>
            Write an object to Current Record
            </summary>
            <param name="iField">the field the object belong to, Start With 0</param>
            <param name="objValue">the object to be added to</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.Write2DBT(System.Object,System.Int32)">
            <summary>
            Write the Value to DBT file
            </summary>
            <param name="Value">the Value to write</param>
            <param name="nOriginalBlock">the number of the Original Block</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.Switch2RightRecord(System.Int32)">
            <summary>
            Switch CurrentRecord to the input Record
            </summary>
            <param name="iRecord">the Index of the Record, which will be the Current Record</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.WriteHeader(System.Boolean)">
            <summary>
            Write out the header and field descriptions before writing any
            actral data records.
            </summary>
            <param name="bHaveMemoField">the HaveMemoField remark</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.UpdateHeader">
            <summary>
            Update the Header
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.UpdateFields">
            <summary>
            Update the Fields
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetDBTFile(System.String)">
            <summary>
            Get the corresponding dbt file
            </summary>
            <param name="dbf">the dbf file</param>
            <returns>the corresponding dbt file</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.MoveDBFAfterFieldOperation(System.String,System.String)">
            <summary>
            Move DBF/DBT files after the Field operations
            </summary>
            <param name="strSrcDBF">the source dbf, which is a tmp file during the operation
            </param>
            <param name="strDestDBF">the dest dbf, which is the original file</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetTmpDBFFile">
            <summary>
            Get tmp DBF File
            </summary>
            <returns>The tmp DBF File</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.AddField2ExistedFile(System.String,ThinkGeo.MapSuite.Layers.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Add a new Field to this existed dbf file
            </summary>
            <param name="FieldName">The new Field's Name</param>
            <param name="type">The new Field's Type</param>
            <param name="nDecimals">The new Field's Width</param>
            <param name="nWidth">The new Fields's Decimal Count</param>
            <returns>the new Field Index</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.AddField2BlankFile(System.String,ThinkGeo.MapSuite.Layers.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Add a new Field to this blank dbf file
            </summary>
            <param name="FieldName">The new Field's Name</param>
            <param name="type">The new Field's Type</param>
            <param name="nDecimals">The new Field's Width</param>
            <param name="nWidth">The new Fields's Decimal Count</param>
            <returns>the new Field Index</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.PackDBFFile(ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Delete all the "Deleted" records , and Open the new Stream
            </summary>
            <param name="DeletedArray">The deleted Array, which is useful during pack
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.PackDBTFile(ThinkGeo.MapSuite.Portable.PclArrayList,ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Pack the DBT File
            </summary>
            <param name="DeletedArray"> the index of every deleted elements</param>
            <param name="MemoFields">the index of every memo fields</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.PackData_DBF(System.IO.Stream@,ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Pack the Data for DBF file
            </summary>
            <param name="fsDest"> The Destination FileStream</param>
            <param name="DeletedArray">The Deleted Array</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.PackData_DBT(System.IO.Stream@,ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Pack the Data for DBT file
            </summary>
            <param name="fsDest"> The Destination FileStream</param>
            <param name="DeletedBlocks">The Memo Array</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.UpdateMemoRecord(ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Update the MemoRecord pointer in DBF after DBT file was flushed
            </summary>
            <param name="memoFields">the memo Fields index Array</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CopyData_DBF(System.IO.Stream,System.Int32,System.Int32,System.IO.Stream@,System.Int32)">
            <summary>
            Move the data between iStart and iEnd, to the stream start with iWriteTo, for DBF
            </summary>
            <param name="fsSrc">The Original filestream</param>
            <param name="iStart">Start Record Index in _fsFile</param>
            <param name="iEnd">End Record Index in _fsFile</param>
            <param name="fsDest">The Destination filestream</param>
            <param name="iWriteTo">the begin Index to be written in fsDest</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CopyData_DBT(System.IO.Stream,System.Int32,System.Int32,System.IO.Stream@,System.Int32)">
            <summary>
            Move the data between iStart and iEnd, to the stream start with iWriteTo, for DBT
            </summary>
            <param name="fsSrc">The Original filestream</param>
            <param name="iStart">Start Record Index in _fsFile</param>
            <param name="iEnd">End Record Index in _fsFile</param>
            <param name="fsDest">The Destination filestream</param>
            <param name="iWriteTo">the Record Index to be written in fsDest</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.UpdateDBTHeader(System.IO.Stream,System.Int32)">
            <summary>
            Update the DBT Header
            </summary>
            <param name="fsDBT">the DBT File</param>
            <param name="nDeletedBlocks">the Deleted Blocks</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetNewValue(System.Int32)">
            <summary>
            Get the new Value according to the original decimalDegreesValue
            </summary>
            <param name="OriginalValue">the original decimalDegreesValue</param>
            <returns>the new decimalDegreesValue</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.MakeContrastArrays(ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Make the 2 Contrast Arrays, used for updating the memo fields in new dbf
            </summary>
            <param name="arrOriginal">the original block index arraylist</param>
            <param name="arrNew">the new block index arraylist</param>
            <param name="iOriginalStart">Start index for a copy</param>
            <param name="iOriginalEnd">End index for a copy</param>
            <param name="iNewStart">WriteTo index for a copy</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetDeletedBlocks(ThinkGeo.MapSuite.Portable.PclArrayList,ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Get the Deleted Blocks Array
            </summary>
            <param name="DeletedArray">the index of every deleted elements</param>
            <param name="MemoFields">the index of every memo fields</param>
            <returns>the Deleted Blocks Array</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GenDeletedIndexArray">
            <summary>
            Get the Deleted ArrayListAdapter
            </summary>
            <remarks>Read MAX_RECORDS_ONCE_READ Records each time to balance mem and efficiency </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.UpdateDeletedArray">
            <summary>
            Update the Deleted Array, make mark
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetBlockCount(System.Int32,System.Int32)">
            <summary>
            Get the Block Count transferred
            </summary>
            <param name="iStart">the start index</param>
            <param name="iEnd">the end index</param>
            <returns>the block count between them</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetBlockSizeOfRecord(System.IO.Stream,System.Int32)">
            <summary>
            Get the Record Length starts at a Block
            </summary>
            <param name="fsDBT">the DBT filestream</param>
            <param name="iBlock">the block index</param>
            <returns>the Record Length</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetHeaderBytes">
            <summary>
            Get Header in Bytes
            </summary>
            <returns>The Header in Bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.FieldsAreValid(ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Get whether the fields are valid
            </summary>
            <param name="Fields">the fields info</param>
            <returns>whether the fields are valid</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CheckEncryptFlag(System.Byte)">
            <summary>
            Check the Encrypted Flag
            </summary>
            <param name="Flag">the Encrypted Flag</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CheckOpening(System.String)">
            <summary>
            Check whether the File is in Create Mode
            </summary>
            <param name="ErrorMsg">the ErrorMsg to be thrown in Create Mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetNewField(ThinkGeo.MapSuite.Layers.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Get Field info according to the input
            </summary>
            <param name="nDecimals">The Field Decimal Count</param>
            <param name="nWidth">The Field Width</param>
            <param name="type">The Field Type</param>
            <returns>The Field Information packed in the DbfFieldInfo struct</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetNewHeaderArray(System.String,ThinkGeo.MapSuite.Layers.DbfColumnInfo)">
            <summary>
            Get the new Header Array according to the new Field infomation
            </summary>
            <param name="Field">the new Field info</param>
            <param name="FieldName">the new Field Name</param>
            <returns>the new Header Array</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetStrByObj(System.Int32,ThinkGeo.MapSuite.Layers.DbfColumnType,System.Object)">
            <summary>
            Get the string from the input object and type
            </summary>
            <param name="iField">get the decimal size from iField </param>
            <param name="objValue">The Value of an attribute boxed in object</param>
            <param name="type">the type of the field</param>
            <returns>the string format of the input Value according to the field type</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetDoubleStrByObj(System.Object,System.Int32,ThinkGeo.MapSuite.Layers.DbfColumnType,System.Globalization.CultureInfo)">
            <summary>
            Get Double string according to the input object and Decimal Size
            </summary>
            <param name="objValue">the Value boxed in Object</param>
            <param name="nDecimalSize">the decimal Size</param>
            <returns>the Double String</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetInputErrorMsg(System.String,ThinkGeo.MapSuite.Layers.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Get Input Error Message according the input
            </summary>
            <param name="FieldName">the Field Name</param>
            <param name="type">The Field type</param>
            <param name="nWidth">The Width of the Field</param>
            <param name="nDecimals">The Decimal Count of the Field</param>
            <returns>The Error Message of the Input</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ConvertStr2Int32(System.String,System.Globalization.CultureInfo)">
            <summary>
            Simulate the atoi function in c++
            </summary>
            <param name="strNum">the Num string </param>
            <returns>the Converted int number</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ConvertStr2Int32Str(System.String)">
            <summary>
            Simulate the atoi function in c++
            </summary>
            <param name="strNum">the Num string </param>
            <returns>the Converted string according with the format of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.WriteInt2Bytes(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Write an Int Value to Bytes Array
            </summary>
            <param name="bytes">the bytes Array to be written</param>
            <param name="iStart">the start index in bytes when Writing</param>
            <param name="intValue">the intValue to write</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.ReadIntFromBytes(System.Byte[],System.Int32)">
            <summary>
            Read the Int Value from Bytes Array
            </summary>
            <param name="bytes">the bytes array to read</param>
            <param name="iStart">the start index in bytes when reading</param>
            <returns>the int decimalDegreesValue read from the bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.GetTime(System.Byte[]@)">
            <summary>
            Get the Time Record in File Header
            </summary>
            <param name="FileHeader">the Header bytes</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CopyHeaderData_DBF(ThinkGeo.MapSuite.Layers.GeoDbf,System.IO.Stream@)">
            <summary>
            Copy the Header bytes in dbfFile to fsDest
            </summary>
            <param name="dbfFile">The Source DBaseFile</param>
            <param name="fsDest">The Destination FileStream</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.GeoDbf.CopyHeaderData_DBT(System.IO.Stream,System.IO.Stream@)">
            <summary>
            Copy the Header bytes in dbtFile to fsDest
            </summary>
            <param name="dbtFile">The Source FileStream</param>
            <param name="fsDest">The Destination FileStream</param>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.GeoDbf.isFileDetached">
            <summary>
            Whether the filestream has been detached
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix">
            <summary>
            This class defines the TileMatrix system used in MapSuite component.
            </summary>
            <remarks>
            This MapSuite Tile Matrix system is the TileMatrix system designed for use
            both in Desktop Edition and Web Edition.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.#ctor(System.Double)">
            <summary>
            This is the constructor by passing the scale.
            </summary>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.#ctor(System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.#ctor(System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="boundingBox">This parameter specifies the bounding box to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.#ctor(System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.PointShape,System.Int64,System.Int64)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference point location to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
            <param name="boundingBox">This parameter specifies the bounding box to set the Matrix.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.PointShape,System.Int64,System.Int64)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference point location to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MapSuiteTileMatrix.GetResolutionFromScale(System.Double)">
            <summary>
            This method will get resolution from scale and can be overridden.
            </summary>
            <param name="scale">This parameter specifies the target scale to get resolution from.</param>
            <returns>Returns the resolution corresponding to the passed in scale.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MatrixReferenceCorner">
            <summary>
            This enum specifies the Reference corner when caculating the Matrix from Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.MatrixReferenceCorner.UpperLeft">
            <summary>
            This items specifies the reference corner should be the UpperLeft of the Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.MatrixReferenceCorner.UpperRight">
            <summary>
            This items specifies the reference corner should be the UpperRight of the Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.MatrixReferenceCorner.LowerLeft">
            <summary>
            This items specifies the reference corner should be the LowerLeft of the Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.MatrixReferenceCorner.LowerRight">
            <summary>
            This items specifies the reference corner should be the LowerRight of the Matrix boundingBox.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.NativeImageTile">
            <summary>
            This class represents a NativeImageTile, which is defined as scale, RectangleBox
            and a byte array for its tile bitmap.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTile.#ctor">
            <summary>
            This is the default constructor without passing any parameters. All its
            properties should be set via the properties.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTile.#ctor(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing the boundingBox and scale.
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.NativeImageTile.#ctor(System.Byte[],ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing image bitmap array and the boundingBox and scale.
             </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.NativeImageTile.NativeImage">
            <summary>This property is the byte arry showing the image of the tile.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.OpenedFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpenedFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.OpenedFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.OpenedRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpenedRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.OpenedRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.OpeningFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpeningFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.OpeningFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.OpeningRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpeningRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.OpeningRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.OverwriteMode">
            <summary>
            This enumeration represents whether a file should be overwrite or not if the file
            exists.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.OverwriteMode.Overwrite">
            <summary>Over write the file if the file exits.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.OverwriteMode.DoNotOverwrite">
            <summary>Do not over write the file if the file exits.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.QueryType">
            <summary>
            This enumeration specifies the ways you can execute a spatial query against a
            FeatureSource.
            </summary>
            <remarks>
            This enumeration is used on the FeatureSource for the SpatialQuery method and
            reflects all the ways you can compare geometries.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Disjoint">
            <summary>The current shape and the targetShape have no points in common.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Intersects">
            <summary>The current shape and the targetShape have at least one point in common.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Touches">
            <summary>
            The current shape and the targetShape have at least one boundary point in common,
            but no interior points.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Crosses">
            <summary>
            The current shape and the targetShape share some but not all interior
            points.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Within">
            <summary>The current shape lies within the interior of the targetShape.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Contains">
            <summary>The targetShape lies within the interior of the current shape.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.Overlaps">
            <summary>
            The current shape and the targetShape share some but not all points in
            common.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.QueryType.TopologicalEqual">
            <summary>The current shape and the target Shape are topologically equal.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RotationProjection">
            <summary>This projection allows you to rotate the map image base don an angle.</summary>
            <remarks>
            This can be usefully when you are working with directional maps such as driving
            maps where you want the upper center of the map to be in line with the direction of the
            vehicle heading.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RotationProjection.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor and will set the angle to 0 whick is north being
            up.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor and will set the angle to 0 whick is north being
            up.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RotationProjection.#ctor(System.Double)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in an angle to change the rotation of the
            map.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to pass in an angle to change the rotation of the
            map.
            </remarks>
            <param name="angle">This parameter is the angle you want to map to rotate to.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RotationProjection.Angle">
            <summary>This property sets the angle of rotation.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RotationProjection.GetUpdatedExtent(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This method returns an adjusted extend based on the angle of rotation.</summary>
            <returns>This method returns an adjusted extend based on the angle of rotation.</returns>
            <remarks>
            This method returns an adjusted extend based on the angle of rotation. It is
            important that you update your current extent every time you adjust the angle of the
            projection. This will ensure the rotaion is performed properly.
            </remarks>
            <param name="worldExtent">This parameter is the world extent before the rotation.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RotationProjection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RotationProjection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because inside of the FeatureSource you
            will in many cases to to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RowColumnRange">
            <summary>
            This structure is used to describe a range of tiles for a given extent.
            Basiclly, 4 values exists : the Row range is from MinColumnIndex to MaxColumnIndex,
            the Column range is from the MinRowIndex to MaxRowIndex.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RowColumnRange.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Contructor of the structure to instance a RowColumnRange.
            </summary>
            <param name="minRowIndex">Min Row Index which stands for the up boundary.</param>
            <param name="maxRowIndex">Max Row Index which stands for the lower boundary.</param>
            <param name="minColumnIndex">Min Column Index which stands for the left boundary.</param>
            <param name="maxColumnIndex">Max Column Index which stands for the right boundary.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RowColumnRange.MinRowIndex">
            <summary>
            Gets or sets the Min Row Index which stands for the up boundary.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RowColumnRange.MaxRowIndex">
            <summary>
            Gets or sets the Max Row Index which stands for the lower boundary.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RowColumnRange.MinColumnIndex">
            <summary>
            Gets or sets the Min Column Index which stands for the left boundary.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RowColumnRange.MaxColumnIndex">
            <summary>
            Gets or sets the Max Column Index which stands for the right boundary.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RowColumnRange.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RowColumnRange.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RowColumnRange.op_Equality(ThinkGeo.MapSuite.Layers.RowColumnRange,ThinkGeo.MapSuite.Layers.RowColumnRange)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="rowColumnRange1">This parameter represents the first rowColumnRange to compare.</param>
            <param name="rowColumnRange2">This parameter represents the second rowColumnRange to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RowColumnRange.op_Inequality(ThinkGeo.MapSuite.Layers.RowColumnRange,ThinkGeo.MapSuite.Layers.RowColumnRange)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="rowColumnRange1">This parameter represents the first rowColumnRange to compare.</param>
            <param name="rowColumnRange2">This parameter represents the second rowColumnRange to compare.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Child">
            <summary>
            Internal node of the Rtree. Used to access Leaf nodes, where real data lies.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Child.#ctor(ThinkGeo.MapSuite.Layers.ChildPage)">
            <summary>
            Constructor
            </summary>
            <param name="page">ChildPage object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Child.SplitNode(ThinkGeo.MapSuite.Layers.Record,ThinkGeo.MapSuite.Layers.Node[]@)">
            <summary>
            Split Child
            </summary>
            <param name="insertRec"></param>
            <param name="nodeList"></param>
            <returns>Leaf array that contains two child objects.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ChildPage">
            <summary>
            ChildPage is a block of data in memory that represents a ChildPage.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ChildPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor
            </summary>
            <param name="rtFile">	RtreeFile object	</param>
            <param name="pageNo">	Page No.			</param>
            <param name="extId">	File type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ChildPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for new page
            </summary>
            <param name="rtFile">	RtreeFile object</param>
            <param name="extId">	File type Id	</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ChildPage.CreateRecordObj">
            <summary>
            Override function for creating Entry object
            </summary>
            <returns>Entry object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ChildPage.GetMaxRecordCount">
            <summary>
            Override method for getting max record count
            </summary>
            <returns>Max record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ChildPage.UpdateEntry(ThinkGeo.MapSuite.Layers.Entry,System.Int32)">
            <summary>
            Update the current node's entry after its leaf has been split.
            </summary>
            <param name="ent">Entry object</param>
            <param name="idx">Entry's index</param>
            <returns>
            	True for success  
            	False for failure
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.DataPage">
            <summary>
            DataPage is a base class of LeafPage and ChildPage.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.InsertRecord(ThinkGeo.MapSuite.Layers.Record)">
            <summary>
            Insert record for override
            </summary>
            <param name="rec">Record object for insertion.</param>
            <returns>False</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.DeleteRecord(System.Int32)">
            <summary>
            Delete a record according to its index for override.
            </summary>
            <param name="idx">Index of the record.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.Flush">
            <summary>
            Override method for writing contents to disk.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for existing page in file.
            </summary>
            <param name="rtFile">	FileStream object	</param>
            <param name="pageNo">	Page No.			</param>
            <param name="extId">	File type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for new page
            </summary>
            <param name="rtFile">	FileStream object	</param>
            <param name="extId">	File type Id		</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DataPage.PageHeader">
            <summary>
            Property PageHeader
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetLevel">
            <summary>
            Get the level of this page.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.SetLevel(System.UInt16)">
            <summary>
            Set the level for this page.
            </summary>
            <param name="level">level</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.SetPageNo(System.UInt32)">
            <summary>
            Set the page number for this page.
            </summary>
            <param name="pageNo">page no.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.InitForEmptyPage">
            <summary>
            Initialize for an empty page, write the page header and the page end.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetRecordCount">
            <summary>
            Get the record count of this page.
            </summary>
            <returns>record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.ReadPageHeader">
            <summary>
            Read page header.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.WritePageHeader">
            <summary>
            Write page header.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.ReadRecordSetHeader">
            <summary>
            Read RecordSetHeader from memory stream.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.WriteRecordSetHeader">
            <summary>
            Write RecordSetHeader to memory stream.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetFirstRecord">
            <summary>
            Get the first record for override.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetNextRecord">
            <summary>
            Get the next record for overrride.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.IsEof">
            <summary>
            Check if cursor has reached the end of this page.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetRecord(System.Int32)">
            <summary>
            Get record according to index for override.
            </summary>
            <param name="idx">	Record index	</param>
            <returns>			Record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetMaxRecordCount">
            <summary>
            Get max record count for override.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.Dump">
            <summary>
            Dump the current page.
            </summary>
            <returns> true </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetMBB">
            <summary>
            Virtual funtion for getting min boundary box.
            </summary>
            <returns> RECTANGLE_D object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.GetFreePageNo">
            <summary>
            Get free page No.
            </summary>
            <returns> free page No.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DataPage.UpdateEntry(ThinkGeo.MapSuite.Layers.Entry,System.Int32)">
            <summary>
            Update entry after splitting for override.
            </summary>
            <param name="ent">The entry to update.</param>
            <param name="idx">Index of entry.</param>
            <returns>false</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Entry">
            <summary>
            Entry contains rectangle information and manipulation used by ChildPage.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Entry.#ctor">
            <summary>
            DefauLb constructor.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Entry.ToString">
            <summary>
            For debug.
            </summary>
            <returns>Entry's content</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Entry.GetSize(System.Boolean)">
            <summary>
            Get Entry's size.
            </summary>
            <returns> Entry's size</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Entry.#ctor(ThinkGeo.MapSuite.Layers.RecordHeader,ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Constructor
            </summary>
            <param name="rh"> RECORD_HEADER object	</param>
            <param name="rt"> RECTANGLE_D object	</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Entry.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read one Entry.
            </summary>
            <param name="r">BinaryReader object</param>
            <param name="isFloat"></param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Entry.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write one Entry.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat"></param>
            <returns>
            	true for success 
            	false for failure
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex">
            <summary>
            Rtree is a facade class of MapSuiteRtree.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.#ctor">
            <summary>
            DefauLb constructor.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.Dispose">
            <summary>
            This method is targeting releasing or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetBestPageSize(System.Int32)">
            <summary>
            Static method for getting the best page size according to the record count of a ShapeFile.
            </summary>
            <param name="recordCount">Record count of ShapeFile.</param>
            <returns>best page size</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.PageSize">
            <summary>
            Property PageSize.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetRoot">
            <summary>
            Get the root node.
            </summary>
            <returns>root node</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.CreateRectangleIdxFile(System.String,System.Boolean,ThinkGeo.MapSuite.Layers.RtreeSpatialIndexPageSize)">
            <summary>
            Create an index file whose type is rectangle.
            </summary>
            <param name="indexFileName">Index file name</param>
            <param name="isFloat">Indicates whether it is float or not</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.ValidateRtreeIndex">
            <summary>
            Check to ensure RtreeIndex is valid.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.OpenCore">
            <summary>
            Open an existing index file as read only.
            </summary>
            <param name="fileName"> Index file name </param>
            <param name="fileAccess">
            	true for read only
            	false for read and write
            </param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.CloseCore">
            <summary>
            Close a previously opened index file.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.Flush">
            <summary>
            Write memory to disk if modified.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.InsertPoint(System.Double,System.Double,System.String)">
            <summary>
            Insert a point.
            </summary>
            <param name="x">	x coordinate	</param>
            <param name="y">	y coordiante	</param>
            <param name="pointId">Index of record	</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.DeletePoint(System.Double,System.Double)">
            <summary>
            Delete a point.
            </summary>
            <param name="x"> x coordinate</param>
            <param name="y"> y coordinate</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.InsertRectangle(System.Double,System.Double,System.Double,System.Double,System.String)">
            <summary>
            Insert a rectangle into index file.
            </summary>
            <param name="upperLeftX">	First point's x coordinate	</param>
            <param name="upperLeftY">	First point's y coordinate	</param>
            <param name="lowerRightX">	Second point's x coordinate	</param>
            <param name="lowerRightY">	Second point's y coordinate	</param>
            <param name="rectangleId">Record index					</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.DeleteRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Delete a rectangle record from index file.
            </summary>
            <param name="upperLeftX"> First point's x coordinate</param>
            <param name="upperLeftY"> First point's y coordinate</param>
            <param name="lowerRightX"> Second point's x coordinate</param>
            <param name="lowerRightY"> Second point's y coordinate</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetRecordIndexesCompletelyInsideRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Query for shape that contains a specific rectangle.
            </summary>
            <param name="upperLeftX">The minimum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="upperLeftY">The minimum decimalDegreesValue of the y coords of specific rectangle.</param>
            <param name="lowerRightX">The maximum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="lowerRightY">The maximum decimalDegreesValue of the y coords of specific rectangle.</param>
            <returns>Index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetRecordIndexesContainingRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Query for shape that is contained by a specific rectangle.
            </summary>
            <param name="upperLeftX">The minimum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="upperLeftY">The minimum decimalDegreesValue of the y coords of specific rectangle.</param>
            <param name="lowerRightX">The maximum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="lowerRightY">The maximum decimalDegreesValue of the y coords of specific rectangle.</param>
            <returns>Index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetRecordIndexesInsideRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Query for shape that is overlapped by a specific rectangle.
            </summary>
            <param name="upperLeftX">The minimum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="upperLeftY">The minimum decimalDegreesValue of the y coords of specific rectangle.</param>
            <param name="lowerRightX">The maximum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="lowerRightY">The maximum decimalDegreesValue of the y coords of specific rectangle.</param>
            <returns>Index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetRecordIndexesNearestToPoint(System.Double,System.Double,System.Int32)">
            <summary>
            Get records nearest to a specific point, up to the returningRecordCount.
            </summary>
            <param name="x">		x coordinate	</param>
            <param name="y">		y coordinate	</param>
            <param name="returningRecordCount">	Maximum number of records to return</param>
            <returns> index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetNearests(System.Double,System.Double,System.Int32)">
            <summary>
            Query for the [MaxNum] closest shapes to a specific point.
            </summary>
            <param name="x">		x coordinate	</param>
            <param name="y">		y coordinate	</param>
            <param name="MaxNum">	Maximum number to return</param>
            <returns> index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetFeatureCountCore">
            <summary>
            Get the count of all records in all leaf nodes.
            </summary>
            <returns> record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.GetIdsFileFromIdxFile(System.String)">
            <summary>
            Dump all nodes for debugging.
            </summary>
            <returns>dumped contents</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.FileHeader">
            <summary>
             Index file header.
             It is stored in page 0.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileHeader.Init">
            <summary>
            Init struct
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileHeader.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileHeader.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FileHeader.ToString">
            <summary>
            For debug
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Gist_Ext_Id">
            <summary>
            File type Id
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.HeaderPage">
            <summary>
            HeaderPage is the page header in memory.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.HeaderPage.FileHeader">
            <summary>
            Property FileHeader
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.HeaderPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile)">
            <summary>
            Constructor for existing page.
            </summary>
            <param name="rtFile"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.HeaderPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for new page.
            </summary>
            <param name="rtFile"></param>
            <param name="pageNo">	page No.			</param>
            <param name="extId">	file type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.HeaderPage.Read">
            <summary>
            Read FILE_HEADER
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.HeaderPage.Write">
            <summary>
            Write FILE_HEADER
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.HeaderPage.Dump">
            <summary>
            Dump file header.
            </summary>
            <returns>
            	dumped string
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.IdsEngine.IdsHeader.ReadIntFromBytes(System.Byte[],System.Int32)">
            <summary>
            Read the int value from a bytes array.
            </summary>
            <param name="bytes">The bytes array to read from.</param>
            <param name="iStart">The start index (in bytes) to use when reading.</param>
            <returns>The int decimalDegreesValue read from the bytes array.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Leaf">
            <summary>
            A Leaf node. Contains pointers to the real data.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.#ctor(ThinkGeo.MapSuite.Layers.LeafPage)">
            <summary>
            Constructor
            </summary>
            <param name="page">LeafPage object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.GetAllRecordsIDSetInThisNode(ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Override method for getting record ID Set in this node.
            Return records count, add records ID to arraylist object.
            </summary>
            <param name="al">Array list for records' IDs</param>
            <returns>Records' count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.Contains(ThinkGeo.MapSuite.Layers.RECTANGLE_D,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Return the count of records that contains a specific area.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	Array list for records' IDs	</param>
            <returns>			Count of records			</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.Contained(ThinkGeo.MapSuite.Layers.RECTANGLE_D,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Return the count of records contained in RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	Array list for records' IDs	</param>
            <returns>			Count of records			</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.Overlaps(ThinkGeo.MapSuite.Layers.RECTANGLE_D,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Return the number of records that overlap with RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test		</param>
            <param name="al">Array list for records' IDs	</param>
            <returns>Count of record</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.InsertRecord(ThinkGeo.MapSuite.Layers.Record,ThinkGeo.MapSuite.Layers.Node[]@)">
            <summary>
            Insert a record.
            </summary>
            <param name="rec">Record object</param>
            <param name="nodeList"></param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Leaf.FindLeaf(ThinkGeo.MapSuite.Layers.Record,System.Int32@,ThinkGeo.MapSuite.Layers.Leaf@)">
            <summary>
            Override FindLeaf, which finds the leaf node containing a given Record.
            </summary>
            <param name="delRec">	Record for deletion									</param>
            <param name="idx">		If FindLeaf, represents the return index of the record for deletion	</param>
            <param name="leafToDel">Leaf node from which to delete the record</param>
            <returns>
            	true for found
            	false for otherwise
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.LeafPage">
            <summary>
            LeafPage is a block of data in memeory that represents the class Leaf.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
             <summary>
            
             </summary>
             <param name="rtFile"></param>
             <param name="pageNo"></param>
             <param name="extId"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for new page.
            </summary>
            <param name="rtFile"></param>
            <param name="extId"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.CreateRecordObj">
            <summary>
            Create a record object according to type for override.
            </summary>
            <returns> Record object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.GetRecord(System.Int32)">
            <summary>
            Get a record according its index.
            </summary>
            <param name="idx">	record index	</param>
            <returns>			Record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.GetFirstRecord">
            <summary>
            Get the first record.
            </summary>
            <returns>Record object.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.GetNextRecord">
            <summary>
            Get the next record.
            </summary>
            <returns>Record object. If the end of the page is reached, returns null.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.InsertRecord(ThinkGeo.MapSuite.Layers.Record)">
            <summary>
            Insert one record in this page; this page may be deleted
            </summary>
            <param name="rec">Record object.</param>
            <returns>
            true for success
            false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.Compress">
            <summary>
            Compress the current page to free deleted space.
            Gets all records in this page and re-inserts them from the header of the data area.
            </summary>
            <returns>
             true for success
             false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.SimpleInsertRecord(ThinkGeo.MapSuite.Layers.Record)">
            <summary>
            Insert one record into this page.
            </summary>
            <param name="rec">Record object</param>
            <returns>
            true for success
            false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.DeleteRecord(System.Int32)">
            <summary>
            Override function for deleting a record according to its index.
            </summary>
            <param name="idx">Index of the record to be deleted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.GetMaxRecordCount">
            <summary>
            Get max record count.
            </summary>
            <returns> max record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.GetMBB">
            <summary>
            Get the minimum boundary box of all the records in this page.
            </summary>
            <returns> RECTANGLE_D object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LeafPage.Dump">
            <summary>
            Dump the current page for debugging.
            </summary>
            <returns> string containing page contents </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Node">
            <summary>
            Node is an abstract class that implements all common functions in Leaf and Child.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.CreateBytype(ThinkGeo.MapSuite.Layers.DataPage)">
            <summary>
            Create a node by page type.
            </summary>
            <param name="dtPage">DataPage object</param>
            <returns>Node object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.#ctor(ThinkGeo.MapSuite.Layers.DataPage)">
            <summary>
            Constructor.
            </summary>
            <param name="page">DataPage object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetFileType">
            <summary>
            Get file type.
            </summary>
            <returns>file type Id</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.Check">
            <summary>
            Check the integrity of the node.
            </summary>
            <returns>
            	true for OK
            	false for corrupt file
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetSubNode(System.Int32)">
            <summary>
            Get the index Entry's sub node.
            </summary>
            <param name="index">index		</param>
            <returns>			child node	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetLevel">
            <summary>
            Get the level of node.
            </summary>
            <returns>level</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.SetLevel(System.UInt16)">
            <summary>
            Set the level for this node.
            </summary>
            <param name="level">level</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetPageNo">
            <summary>
            Get the page no. of this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.SetPageNo(System.UInt32)">
            <summary>
            Set the page no. for this node.
            </summary>
            <param name="pageNo"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetFirstRecord">
            <summary>
            Get the first record of the current node.
            </summary>
            <returns>Record object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetNextRecord">
            <summary>
            Get the next record.
            </summary>
            <returns>Record object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsEof">
            <summary>
            Test if the cursor has reached the end of the node.
            </summary>
            <returns>
            	true for end
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetRecordCount">
            <summary>
            Return the record count in this node.
            </summary>
            <returns>record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetTotalRecordCount">
            <summary>
            Get the total count of records in the current node and its sub nodes,
            if they are leaf nodes.
            </summary>
            <returns>record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetMBB">
            <summary>
            Get the minimum boundary box of this node.
            </summary>
            <returns>Min boundary RECTANGLE_D object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsContains(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the node contains the specified RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test</param>
            <returns>
            	true for contains
            	false for not
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsContained(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the node is contained by the specified RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test</param>
            <returns>
            	true for contained
            	false for not
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsOverlaps(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the node overlaps with a specific RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test</param>
            <returns>
            	true for overlap
            	false for not
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetAllRecordsIDSetInThisNode(ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Get the record ID Set in this node, including sub nodes if they are leaf nodes.
            Returns records count, add records id to arraylist object.
            </summary>
            <param name="al">Array list for records' IDs</param>
            <returns>Records' count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetNearest(ThinkGeo.MapSuite.Layers.RTreePoint,ThinkGeo.MapSuite.Layers.Node,System.Int32)">
            <summary>
            Get nMax nearest record
            </summary>
            <param name="p">	Query point				    </param>
            <param name="nRoot">Root node					</param>
            <param name="nMax">	The record count you want	</param>
            <returns>Record list</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetNearest(ThinkGeo.MapSuite.Layers.Node,ThinkGeo.MapSuite.Layers.RTreePoint,System.Double,System.Int32,ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Get nMax nearnest record
            </summary>
            <param name="node">				Current node				</param>
            <param name="p">				Query Point					</param>
            <param name="nearest">			Current mindistance			</param>
            <param name="nMax">				The point number you want	</param>
            <param name="nodeStack">		Nodelist needed to search	</param>
            <param name="candidateStack">	Candidate record list		</param>
            <param name="resuLbStack">		Hold resuLb					</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.AddNodeToNodeStack(ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Layers.Node,ThinkGeo.MapSuite.Layers.RTreePoint)">
            <summary>
            Add the current node's subnodes to NodeStack.
            </summary>
            <param name="nodeStack">Nodelist need to search	</param>
            <param name="node">		Current node			</param>
            <param name="p">		Query point				</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.AddCandiatesToResuLbStack(ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@,System.Int32,System.Double)">
            <summary>
            Add record to resuLbStack by nearest.
            </summary>
            <param name="candidateStack">	Candidate record list			</param>
            <param name="resuLbStack">		resuLb list						</param>
            <param name="nMax">				The point number want to search	</param>
            <param name="nearest">			Current mindistance				</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.AddToCandiateStack(ThinkGeo.MapSuite.Layers.Node,ThinkGeo.MapSuite.Layers.RTreePoint,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Add a Leaf node's record to candidateStack and sort them.
            </summary>
            <param name="node">				Leaf node		</param>
            <param name="p">				Query point		</param>
            <param name="candidateStack">	candidateStack	</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.Contains(ThinkGeo.MapSuite.Layers.RECTANGLE_D,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Return the count of records that contains the specific RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	Arraylist for records' ids	</param>
            <returns>			Count of record				</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.Contained(ThinkGeo.MapSuite.Layers.RECTANGLE_D,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Return the count of records contained in RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	array list for records' ids	</param>
            <returns>			Count of record				</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.Overlaps(ThinkGeo.MapSuite.Layers.RECTANGLE_D,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Return the number of records that overlap with RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test		</param>
            <param name="al">arraylist for records' ids	</param>
            <returns>Count of record</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.Dump">
            <summary>
            Dump this node's contents for debugging.
            </summary>
            <returns>node's contents</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetRecord(System.Int32)">
            <summary>
            Get record according its index.
            </summary>
            <param name="idx">	record index	</param>
            <returns>			record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsRoot">
            <summary>
            Test if Node is root node.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsLeaf">
            <summary>
            Test if Node is leaf node.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.IsChild">
            <summary>
            Test if node is child node.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.QuadraticSplit(ThinkGeo.MapSuite.Portable.PclArrayList)">
            <summary>
            Quadratic algorithm for spliting a node.
            </summary>
            <param name="rectList">ArrayListAdapter of RECTANGLE_D for splitting</param>
            <returns>two groups index </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.PickNext(ThinkGeo.MapSuite.Layers.RECTANGLE_D[],ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Layers.RECTANGLE_D@,ThinkGeo.MapSuite.Layers.RECTANGLE_D@)">
            <summary>
            Select one remaining entry for classification as a group
            </summary>
            <param name="rectArr">		RECTANGLE_D[] array for splitting	</param>
            <param name="spRectList">	Resting index of RECTANGLE_D		</param>
            <param name="leftRectList">	Index of left group					</param>
            <param name="rightRectList">Index of right group				</param>
            <param name="mbr1">			MBB of left group					</param>
            <param name="mbr2">			MBB of right group					</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.AddRest(ThinkGeo.MapSuite.Portable.PclArrayList@,ThinkGeo.MapSuite.Portable.PclArrayList@)">
            <summary>
            Add the rest index of RECTANGLE_D to a specific group.
            </summary>
            <param name="spRectList">	Resting index of RECTANGLE_D</param>
            <param name="rectList">		Index of left or right group</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.PickSeeds(ThinkGeo.MapSuite.Layers.RECTANGLE_D[])">
            <summary>
            Select two records to be the first elements of the pages.
            </summary>
            <returns> int array contains two record index</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.AdjustTree(ThinkGeo.MapSuite.Layers.Node,System.Int32,System.Boolean)">
            <summary>
            Called by insert to adjust the parents of the node that
             was modified by the insertion.
             Stops when it reaches the root.
            </summary>
            <param name="n">		The child node that caused the need for adjustment.	</param>
            <param name="index">	For adjusting entry's index							</param>
            <param name="bSplitted">true for split, false for otherwise				</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.UpdateEntry(ThinkGeo.MapSuite.Layers.Node,ThinkGeo.MapSuite.Layers.Entry,System.Int32)">
            <summary>
            Update the specified node's entry.
            </summary>
            <param name="n">	Node object	</param>
            <param name="ent">	Entry object</param>
            <param name="index">index		</param>
            <returns>
            	true for sucess
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.FindLeastEnlargement(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Find the least enlargement entry to contain the specified RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D object	</param>
            <returns>			Entry's index		</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.InsertRecord(ThinkGeo.MapSuite.Layers.Record,ThinkGeo.MapSuite.Layers.Node[]@)">
            <summary>
            Insert record for recursive calling.
            </summary>
            <param name="rec">		Record object	</param>
            <param name="nodelist">	Node array		</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.InsertRecordInThisNode(ThinkGeo.MapSuite.Layers.Record,ThinkGeo.MapSuite.Layers.Node[]@)">
            <summary>
            Insert a record into current node.
            </summary>
            <param name="rec">		Record object	</param>
            <param name="nodeList">	Node array		</param>
            <returns>
            	true for success
            	flase for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.GetFreePageNo">
            <summary>
            Get free page number.
            </summary>
            <returns>page No.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.SplitRoot(ThinkGeo.MapSuite.Layers.Node[])">
            <summary>
            Create a new root according to two nodes.
            </summary>
            <param name="a">Node array that contains two nodes</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.MoveNodeToLast(ThinkGeo.MapSuite.Layers.Node)">
            <summary>
            Move a node to the end of file.
            </summary>
            <param name="node">Node to be moved</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.Delete(ThinkGeo.MapSuite.Layers.Record)">
            <summary>
            Delete a Record.
            </summary>
            <param name="delRec">The record to be deleted.</param>
            <returns>
            	true for deletion
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.FindPointRecordLeaf(ThinkGeo.MapSuite.Layers.Record,System.Int32@,ThinkGeo.MapSuite.Layers.Leaf@,ThinkGeo.MapSuite.Layers.Node)">
            <summary>
            Find a leaf node whose type is point.
            </summary>
            <param name="rec">		Record object to delete				    </param>
            <param name="idx">		Index of record to delete			    </param>
            <param name="leafToDel">Leaf node in which to delete the record </param>
            <param name="subNode">	Node object							    </param>
            <returns>
             true for find
             flase for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.FindRectRecordLeaf(ThinkGeo.MapSuite.Layers.Record,System.Int32@,ThinkGeo.MapSuite.Layers.Leaf@,ThinkGeo.MapSuite.Layers.Node)">
            <summary>
            Find leaf node whose type is rectangle.
            </summary>
            <param name="rec">		Record object to delete				    </param>
            <param name="idx">		Index of record to delete		    	</param>
            <param name="leafToDel">Leaf node in which to delete the record	</param>
            <param name="subNode">	Node object							    </param>
            <returns>
             true for find
             flase for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Node.DeleteRecord(System.Int32)">
            <summary>
            Delete a Record by index
            </summary>
            <param name="idx"></param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.NodeElement">
            <summary>
            Structure that holds NodeElement.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.PageHeader">
            <summary>
             Page header.
             Its size must be 16 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PageHeader.Init">
            <summary>
            Init PAGE_HEADER
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PageHeader.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader r.
            </summary>
            <param name="r">BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PageHeader.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents to BinaryWriter w.
            </summary>
            <param name="w"> BinaryWriter object</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PageHeader.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.PointRecord">
            <summary>
            PointRecord contains point information and manipulation.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.#ctor">
            <summary>
            DefauLb constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.#ctor(ThinkGeo.MapSuite.Layers.RecordHeader,ThinkGeo.MapSuite.Layers.RTreePoint,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="rh"> RECORD_HEADER object </param>
            <param name="pt"> POINT object </param>
            <param name="idx">index of the current record</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.ToString">
            <summary>
            For debug
            </summary>
            <returns>contents of pointrecord</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.PointRecord.Point">
            <summary>
            Property point
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.GetPoint">
            <summary>
            Get point object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read one PointRecord.
            </summary>
            <param name="isFloat">This parameter specifies whether the rTree is using float or double.</param>
            <param name="r">BinaryReader object</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write one PointRecord.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat">This parameter specifies whether the rTree is using float or double.</param>
            <returns>
            	true for success 
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.IsContained(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the record is contained by the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.IsContains(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the record contains the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>false</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.IsOverlaps(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the record overlaps with the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>false</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.GetSize(System.Boolean)">
            <summary>
            Get the size of PointRecord.
            </summary>
            <returns>Size of PointRecord</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.PointRecord.GetArea">
            <summary>
            Get the area of PointRecord.
            </summary>
            <returns>0</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Record">
            <summary>
            Record is an abstract class.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Record.CreateByType(ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Create a record object according to file type.
            </summary>
            <param name="extId">	file ext Id		</param>
            <returns>				record object	</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Record.RecordHeader">
            <summary>
            Property of RecordHeader
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.Record.Data">
            <summary>
            Property of Data
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Record.GetChild">
            <summary>
            Get child page number.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Record.GetRectangle">
            <summary>
            Return the rectangle of this record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Record.GetPoint">
            <summary>
            Get point object for override.
            </summary>
            <returns>null</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RecordElement">
            <summary>
            Structure that holds RecordElement.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RecordHeader">
            <summary>
            Record header; must be 8 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordHeader.GetSize">
            <summary>
            Return the size of this struct.
            </summary>
            <returns> Size of RECORD_HEADER</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordHeader.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordHeader.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w"> BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordHeader.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RecordSetHeader">
            <summary>
            RecordSet header; must be 8 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordSetHeader.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r">BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordSetHeader.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RecordSetHeader.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RectangleRecord">
            <summary>
            RectangleRecrod contains rectangle information and manipulation.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.#ctor">
            <summary>
            DefauLb constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.#ctor(ThinkGeo.MapSuite.Layers.RecordHeader,ThinkGeo.MapSuite.Layers.RECTANGLE_D,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="rh">RECORD_HEADER object</param>
            <param name="rt">	RECTANGLE_D object</param>
            <param name="idx">	Index of record</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read one RectangleRecord.
            </summary>
            <param name="r">BinaryReader object</param>
            <param name="isFloat">Indicitates that it is float.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write one RectangleRecord.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat"> Marks the point value as float.</param>
            <returns>
            	true for success 
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.IsContained(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the record is contained by the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.IsContains(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the record contains the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.IsOverlaps(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the record overlaps with the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.GetSize(System.Boolean)">
            <summary>
            Get size of RectangleRecord.
            </summary>
            <returns>Size of RectangleRecord</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.GetArea">
            <summary>
            Get area of the rectangle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RectangleRecord.ToString">
            <summary>
            For debugging.
            </summary>
            <returns>contents of record</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RECTANGLE_D">
            <summary>
            RECTANGLE_D stores a rectangle and independent functions.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor for constructing based on coordinates.
            </summary>
            <param name="x1"> First point's x coordinate</param>
            <param name="y1"> First point's y coordinate</param>
            <param name="x2"> Second point's x coordinate</param>
            <param name="y2"> Second point's y coordinate</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.GetMinDist(ThinkGeo.MapSuite.Layers.RTreePoint)">
            <summary>
            GetMinDist
            </summary>
            <param name="p">Query point</param>
            <returns>Min distance</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.Normalize">
            <summary>
            Normalize the data to RECTANGLE_D coordinates.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.GetSize(System.Boolean)">
            <summary>
            Return the size of this struct.
            </summary>
            <returns> Size of RECTANGLE_D</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <param name="isFloat"> </param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w"> BinaryWriter object</param>
            <param name="isFloat"></param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.IsContains(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if this RECTANGLE_D contains testRect.
            </summary>
            <param name="testRect"> RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.IsContains(ThinkGeo.MapSuite.Layers.RTreePoint)">
            <summary>
            Test if this RECTANGLE_D contains testPoint.
            </summary>
            <param name="testPoint">POINT object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.IsContained(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if this RECTANGLE_D is contained by testRect.
            </summary>
            <param name="testRect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.IsOverlaps(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if this RECTANGLE_D overlaps with testRect.
            </summary>
            <param name="testRect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.Width">
            <summary>
            Get the rectangle's width.
            </summary>
            <returns> rectangle's width</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.Height">
            <summary>
            Get the rectangle's height.
            </summary>
            <returns> rectangle's height</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.GetArea">
            <summary>
            Get the rectangle's area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.IsEquals(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Test if the current rectangle is equal to testRt.
            </summary>
            <param name="testRt">Rectangle to test</param>
            <returns>
            true for yes
            false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.GetRectangleF">
            <summary>
            Get rectangle object.
            </summary>
            <returns> rectangle object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.GetUnionMbb(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Return a new RECTANGLE_D representing the mbb of the union of this RECTANGLE_D and rt.
            </summary>
            <param name="rt">Specific RECTANGLE_D</param>
            <returns>new RECTANGLE_D representing the mbb of their union</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.GetUnionMbbArea(ThinkGeo.MapSuite.Layers.RECTANGLE_D)">
            <summary>
            Return a new RECTANGLE_D representing the mbb of the union of this RECTANGLE_D and rt.
            </summary>
            <param name="rt">Specific RECTANGLE_D</param>
            <returns>new RECTANGLE_D representing the mbb of their union</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RECTANGLE_D.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RTPage">
            <summary>
            RTPage is a abstract class.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.Flush">
            <summary>
            Write contents of memory to disk, if modified.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for new page.
            </summary>
            <param name="rtFile">		RtreeFile object	</param>
            <param name="extId">	page No.			</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Layers.Gist_Ext_Id)">
            <summary>
            Constructor for existing page.
            </summary>
            <param name="rtFile">		RtreeFile object	</param>
            <param name="pageNo">	page No.			</param>
            <param name="extId">	file type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile,System.UInt32)">
            <summary>
            Constructor for existing page.
            </summary>
            <param name="rtFile">		RtreeFile object	</param>
            <param name="pageNo">	page No.			</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.#ctor(ThinkGeo.MapSuite.Layers.RtreeFile)">
            <summary>
             Constructor for open header page .
            </summary>
            <param name="rtFile">RtreeFile object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.Load">
            <summary>
            Initialize page.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RTPage.PageNo">
            <summary>
            Property page number.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.SetModified">
            <summary>
            Set modified flag.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.GetFileStream">
            <summary>
            Get file stream.
            </summary>
            <returns>filestream object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.GetFileType">
            <summary>
            Get file type .
            </summary>
            <returns>gistExtId</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTPage.GetRtreeFile">
            <summary>
            Get RTFile object.
            </summary>
            <returns>RTFile object</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RtreeFile">
            <summary>
            	The RtreeFile class handles all file read and write operations of Rtree.
            	Each file has a file header and one or more pages. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.#ctor">
            <summary>
            DefauLb constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.Create(System.String,ThinkGeo.MapSuite.Layers.Gist_Ext_Id,ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.OpenStreamLoadingDelegate,System.Boolean)">
            <summary>
            Create point type index file.
            </summary>
            <param name="fileName"> Index file name	</param>
            <param name="extId">	File type id	</param>
            <param name="openStreamLoadingDelegate">The delegate to open the stream.</param>
            <param name="isFloat">True to mark it as single or float.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.InitFileHeader(ThinkGeo.MapSuite.Layers.Gist_Ext_Id,System.Boolean)">
            <summary>
            Init file header according to extId.
            </summary>
            <param name="extId"> File type Id</param>
            <param name="isFloat">True to mark it as float or single.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.Open(System.String,System.Boolean,ThinkGeo.MapSuite.Layers.RtreeSpatialIndex.OpenStreamLoadingDelegate)">
            <summary>
            Open an index file.
            </summary>
            <param name="fileName">		Index file name				</param>
            <param name="isReadOnly">	If file is open as read only</param>
            <param name="openStreamLoadingEvent">The openstream to open the current RTree.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.Close">
            <summary>
            Close a previously opened index file.
            </summary>
            <returns>
            	true for opened
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.Flush">
            <summary>
            Flush contents to disk.
            </summary>
            <returns>
            true for succeed
            false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.IsReadOnly">
            <summary>
            Test if file is read only.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.ReadFileHeader">
            <summary>
            Read the file header from the file.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.WriteFileHeader">
            <summary>
            Write the file header to the file.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.GetFileStream">
            <summary>
            Get current file stream.
            </summary>
            <returns> FileStream object</returns> 
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.GetFileType">
            <summary>
            Get file type.
            </summary>
            <returns> file type Id</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.GetRootNodePage">
            <summary>
            Get root node's page (its page number is 1).
            </summary>
            <returns>DataPage object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RtreeFile.GetPageCount">
            <summary>
            Get the page count of this file.
            </summary>
            <returns>page count</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RTreePoint">
            <summary>
            Point struct.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTreePoint.#ctor(System.Double,System.Double)">
            <summary>
             Constructor.
            </summary>
            <param name="x"> x coordinate</param>
            <param name="y"> y coordinate</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTreePoint.IsEquals(ThinkGeo.MapSuite.Layers.RTreePoint)">
            <summary>
            Test if current point is equal to pt.
            </summary>
            <param name="pt">Point to test</param>
            <returns>
            true for yes
            false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTreePoint.GetSize(System.Boolean)">
            <summary>
            Return the size of the this struct.
            </summary>
            <returns> Size of POINT</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTreePoint.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <param name="isFloat">True to mark it as float or single.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTreePoint.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat">True if we want to save it as float or single.</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RTreePoint.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.Slot">
            <summary>
            Contains a record's offset and length.
            It is stored in the end area of the page.
            Its size must be 4 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Slot.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r">BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Slot.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents to BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.Slot.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs">
            <summary>This class represents the event arguments for the StreamLoading event.</summary>
            <remarks>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the default constructor taking no arguments which is typically not
            used.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor taking no arguments which is typically not
            used.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.#ctor(System.String,System.String)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the default constructor taking no arguments which is typically not
            used.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor taking no arguments which is typically not
            used.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
            <param name="alternateStreamName">
            This parameter represents the key string you will use to find the stream on the
            client end.
            </param>
            <param name="streamType">This parameter represents the stream type string you will use to find the stream on the
            client end.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.#ctor(System.String,System.IO.Stream,ThinkGeo.MapSuite.Layers.GeoFileMode,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the constructor we suggest you you when creating this class.</overloads>
            <remarks>
            This is the constructor we suggest you you when creating this class.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
            <returns>None</returns>
            <param name="alternateStreamName">
            This parameter represents the key string you will use to find the stream on the
            client end.
            </param>
            <param name="alternateStream">
            This parameter should be set in the event by the user to represent the alternate
            stream.
            </param>
            <param name="fileMode">
            This parameter should be set in the event by the user to represent the file mode
            that the alternate stream need to function as.
            </param>
            <param name="fileAccess">
            This parameter should be set in the event by the user to represent the file
            access that the alternate stream need to function as.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.#ctor(System.String,System.String,System.IO.Stream,ThinkGeo.MapSuite.Layers.GeoFileMode,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)" -->
        <member name="P:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.AlternateStreamName">
            <summary>
            This property gets or sets the source of the stream you wish the user to pass
            you.
            </summary>
            <remarks>
            	<para>This is always set by the person who created the event arguments and should
                not be changed by the user.<br/>
            		<br/>
                The streamSource name just needs to be some unique string that will let the user
                know which file or stream you want. For example you could have a streamSourceName
                of "Z:\test.shp" and though the Z drive might not exist it might be a cue for you
                to load "test.shp" from isolated storage. We suggest you use a string that is in
                the file format of "?:\????.???" as this allows is to validate it though we do not
                check if it exists.<br/>
            		<br/>
                Alternate Streams<br/>
            		<br/>
                Where possible we allow you to use stream in place of concreate files on the file
                system. This gives you the flexibility to retrieve data from isolated storage,
                encrypted files, compressed files, fast memory streams or any other stream origin.
                This is typically available where you would pass in a path and file name. Streams
                can be substituted in a number of places such as images, shape files etc. Below
                describes how the system works though specific places may have slightly different
                variations.<br/>
            		<br/>
                 You will create the object that will use the stream normally such as a
                ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these
                classes you typically need to supply a path and file name, while this is still
                required you can pass in a valid path that does not exist such as
                "Z:\ShapeFile1.shp". When we need the stream from you we will give you this string
                so you can find the associated stream. In essence you can use the path and file
                name as a key to kink to the source of your stream.<br/>
            		<br/>
                 When we need the file we will raise the StreamLoading event and allow you to pass
                an alternate stream. In the StreamLoading event we provide you with the path and
                file name you used and we expect for you to create the stream and set it as the
                AlternatStream property along with setting the FileMode and File access appropriate
                to the stream. This helps us know our limits with the stream.</para>
            </remarks>
            <decimalDegreesValue>
            This property gets source of the stream you wish the user to pass you as a
            string.
            </decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.AlternateStream">
            <summary>This property gets and sets the alternate stream you want to use.</summary>
            <decimalDegreesValue>This property gets the alternate stream you want to use.</decimalDegreesValue>
            <remarks>
            When the event is raised the user should be responsible for either ignoring this
            property or setting it. It should default to null and if the user wishes to use an
            alternate stream instead of a file from the disk then they should replace it
            here.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.FileMode">
            <summary>
            This property gets and sets the file mode that the alternate stream need to
            function as.
            </summary>
            <decimalDegreesValue>
            This property gets the file mode that the alternate stream need to function
            as.
            </decimalDegreesValue>
            <remarks>
            You should set the file mode to the mode that best describes the limitations
            inherent to your alternate stream.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.ReadWriteMode">
            <remarks>
            You should set the file access to the mode that best describes the limitations
            inherent to your alternate stream.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
            <summary>
            This property gets and sets the file access that the alternate stream need to
            function as.
            </summary>
            <decimalDegreesValue>
            This property gets the file access that the alternate stream need to function
            as.
            </decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs.StreamType">
            <summary>
            This property gets the the stream type you wish the user to pass
            you. The value represents corresponding stream type:
            If it is "Image File": it represents you need to pass in a stream represents image file, such as .bmp file stream.
            If it is "World File": it represents you need to pass in a stream represents world file, such as .bpw file stream.
            If it is "SHP File": it represents you need to pass in a stream represents .shp file.
            If it is "SHX File": it represents you need to pass in a stream represents .shx file.
            If it is "DBF File": it represents you need to pass in a stream represents .dbf file.
            If it is "DBT File": it represents you need to pass in a stream represents .dbt file.
            If it is "IDX File": it represents you need to pass in a stream represents .idx file.
            If it is "IDS File": it represents you need to pass in a stream represents .ids file.
            If it is "GeoImage": it represents you need to pass in a stream represents GeoImage.
            </summary>
            <remarks>
            	<para>This is always set by the person who created the event arguments and should
                not be changed by the user.<br/>
            		<br/>
                The streamSource name just needs to be some unique string that will let the user
                know which file or stream you want. For example you could have a streamSourceName
                of "Z:\test.shp" and though the Z drive might not exist it might be a cue for you
                to load "test.shp" from isolated storage. We suggest you use a string that is in
                the file format of "?:\????.???" as this allows is to validate it though we do not
                check if it exists.<br/>
            		<br/>
                Alternate Streams<br/>
            		<br/>
                Where possible we allow you to use stream in place of concreate files on the file
                system. This gives you the flexibility to retrieve data from isolated storage,
                encrypted files, compressed files, fast memory streams or any other stream origin.
                This is typically available where you would pass in a path and file name. Streams
                can be substituted in a number of places such as images, shape files etc. Below
                describes how the system works though specific places may have slightly different
                variations.<br/>
            		<br/>
                 You will create the object that will use the stream normally such as a
                ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these
                classes you typically need to supply a path and file name, while this is still
                required you can pass in a valid path that does not exist such as
                "Z:\ShapeFile1.shp". When we need the stream from you we will give you this string
                so you can find the associated stream. In essence you can use the path and file
                name as a key to kink to the source of your stream.<br/>
            		<br/>
                 When we need the file we will raise the StreamLoading event and allow you to pass
                an alternate stream. In the StreamLoading event we provide you with the path and
                file name you used and we expect for you to create the stream and set it as the
                AlternatStream property along with setting the FileMode and File access appropriate
                to the stream. This helps us know our limits with the stream.</para>
            </remarks>
            <decimalDegreesValue>
            This property gets the stream type you wish the user to pass you as a
            string.
            </decimalDegreesValue>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TileImageFormat">
            <summary>Specifies the format of the map image.</summary>
            <remarks>
            If the image is overlaid atop other images, use the PNG image format (which can use
            a transparent background). If you have a low bandwidth network, use the JPEG image format.
            You can reduce the quality of the JPEG image and make its size smaller.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TileImageFormat.Png">
            <summary>
            Specifies the image is in the W3C Portable Network NativeGraphics (PNG) image
            format.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TileImageFormat.Jpeg">
            <summary>
            Specifies the image is in the Joint Photographic Experts Group (JPEG) image
            format.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TileMatrixCell">
            <summary>
            This structure represents the TileMatrixCell  which will be used in the TileMatrix system.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrixCell.#ctor(System.Int64,System.Int64,ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>This is the constructor used to create a TileMatrixCell.</summary>
            <remarks>None</remarks>
            <param name="row">This parameter represents the row number of the TileMatrixCell.</param>
            <param name="column">This parameter represents the column number of the TileMatrixCell.</param>
            <param name="boundingBox">This parameter represents the boundingBox of the TileMatrixCell.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrixCell.Row">
            <summary>
            This property gets or sets the Row number of the stucture.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrixCell.Column">
            <summary>
            This property gets or sets the Column number of the stucture.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TileMatrixCell.BoundingBox">
            <summary>
            This property gets or sets the BoundingBox of the stucture.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrixCell.ToString">
            <summary>This method is an override of the ToString functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrixCell.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrixCell.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrixCell.op_Equality(ThinkGeo.MapSuite.Layers.TileMatrixCell,ThinkGeo.MapSuite.Layers.TileMatrixCell)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="cell1">This parameter represents the first TileMatrixCell to compare.</param>
            <param name="cell2">This parameter represents the second TileMatrixCell to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TileMatrixCell.op_Inequality(ThinkGeo.MapSuite.Layers.TileMatrixCell,ThinkGeo.MapSuite.Layers.TileMatrixCell)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="cell1">This parameter represents the first TileMatrixCell to compare.</param>
            <param name="cell2">This parameter represents the second TileMatrixCell to compare.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TransactionBuffer">
            <summary>
            This class represents the holding place for transactions that have not yet been
            committed.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.#ctor">
            <summary>This is the class constructor.</summary>
            <overloads>This is the default constructor and is typically not used.</overloads>
            <remarks>This is the default constructor and is typically not used.</remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.#ctor(System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Shapes.Feature},System.Collections.ObjectModel.Collection{System.String},System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>This is the class constructor.</summary>
            <overloads>This is the constructor for this class allows you pass in the necessary
            properties in the class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.Clear">
            <summary>
            This method will clear all the items in AddBuffer, EditBuffer and
            DeleteBuffer.
            </summary>
            <returns>None.</returns>
            <remarks>
            This method will clear all the items in AddBuffer, EditBuffer and
            DeleteBuffer.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionBuffer.AddBuffer">
            <summary>This property gets the dictionary buffer that holds InternalFeatures to be added.</summary>
            <decimalDegreesValue>This property gets the dictionary buffer that holds InternalFeatures to be added.</decimalDegreesValue>
            <remarks>
            It is recommended that you use this dictionary for reviewing and not for adding
            new items. The reason is that the Add, Delete and Edit methods to various validation
            checks. For example if you call the DeleteFeature twice it will handle the case that
            you really only want to delete the record once. Another example is if you edit a record
            twice it will replace the existing edit with the new one.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionBuffer.DeleteBuffer">
            <summary>
            This property gets the dictionary buffer that holds InternalFeatures to be
            deleted.
            </summary>
            <decimalDegreesValue>
            This property gets the dictionary buffer that holds InternalFeatures to be
            deleted.
            </decimalDegreesValue>
            <remarks>
            It is recommended that you use this dictionary for reviewing and not for adding
            new items. The reason is that the Add, Delete and Edit methods to various validation
            checks. For example if you call the DeleteFeature twice it will handle the case that
            you really only want to delete the record once. Another example is if you edit a record
            twice it will replace the existing edit with the new one.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionBuffer.EditBuffer">
            <summary>
            This property gets the dictionary buffer that holds InternalFeatures to be
            updated.
            </summary>
            <decimalDegreesValue>
            This property gets the dictionary buffer that holds InternalFeatures to be
            updated.
            </decimalDegreesValue>
            <remarks>
            It is recommended that you use this dictionary for reviewing and not for adding
            new items. The reason is that the Add, Delete and Edit methods to various validation
            checks. For example if you call the DeleteFeature twice it will handle the case that
            you really only want to delete the record once. Another example is if you edit a record
            twice it will replace the existing edit with the new one.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.AddFeature(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>This method allows you to add InternalFeatures to the transaction buffer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="feature">
            This parameter represents the Feature you are adding to the transaction
            buffer.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.AddFeature(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>This method allows you to add a shape into the buffer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be added. </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.AddFeature(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>This method allows you to add a shape into the buffer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be added. </param>
            <param name="columnValues">This parameter represents the feature value to be added. </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.DeleteFeature(System.String)">
            <summary>
            This method allows you to add a placeholder to represent a Feature to be
            deleted.
            </summary>
            <returns>None</returns>
            <remarks>
            This does not remove a feature from the TransactionBuffer but rather it add a "to
            be deleted record". In this way when the TransactionBuffer if processed we know what
            records need to be deleted.
            </remarks>
            <param name="featureId">
            This parameter represents the unique Id for the specific Feature being passed
            in.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.EditFeature(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>This method allows you to add a Feature to be updated.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="feature">This parameter represents the Feature to be updated.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.EditFeature(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>This method allows you to add a shape to be updated.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be updated.
            The shape ID should be the same as the feature you are going to update.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionBuffer.EditFeature(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>This method allows you to add a shape to be updated.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be updated.
            The shape ID should be the same as the feature you are going to update.</param>
            <param name="columnValues">This parameter represents the feature value to be updated.
            The shape ID should be the same as the feature you are going to update.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TransactionResult">
            <summary>This class represents the results of a transaction that was processed.</summary>
            <remarks>
            This class holds the results of a transaction. It can tell the users the number
            of succeeded record and the number of failed records. It also has a dictionary that
            holds the individual reasons that certain records fails by FeatureId. If you are
            implementing this class it is important that you provide as much information about the
            transaction results to your users.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionResult.#ctor">
            <summary>This is the class constructor.</summary>
            <overloads>This is the default constructor and is typically not used.</overloads>
            <returns>None</returns>
            <remarks>This is the default constructor and is typically not used.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.TransactionResult.#ctor(System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},ThinkGeo.MapSuite.Layers.TransactionResultStatus)">
            <summary>This is the class constructor.</summary>
            <overloads>This is the constructor for this class allows you pass in the necessary 
            properties in the class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionResult.TotalSuccessCount">
            <summary>
            This property gets and sets the total number of records that we committed
            successfully.
            </summary>
            <decimalDegreesValue>
            This property gets the total number of records that we committed
            successfully.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionResult.TotalFailureCount">
            <summary>
            This property gets and sets the total number of records that we committed
            unsuccessfully.
            </summary>
            <decimalDegreesValue>
            This property gets the total number of records that we committed
            unsuccessfully.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionResult.TransactionResultStatus">
            <summary>This property gets and sets the result status of the transaction.</summary>
            <decimalDegreesValue>This property gets the result status of the transaction.</decimalDegreesValue>
            <remarks>
            This property returns the results of the transaction. If all of the records
            committed fine then you get a success status. If any of the records fail then you get a
            failure status though some of the records may have committed.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.TransactionResult.FailureReasons">
            <summary>
            This property gets and sets the dictionary that contains the reasons for
            failure.
            </summary>
            <decimalDegreesValue>This property gets the dictionary that contains the reasons for failure.</decimalDegreesValue>
            <remarks>
            If there are failing records we suggest you add the failure reasons to this
            dictionary. It is also suggested that you use the FeatureId as the key of the
            Dictionary.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.TransactionResultStatus">
            <summary>This enumeration represents the results from a FeatureSource transaction.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TransactionResultStatus.Success">
            <summary>This means that each item in the transaction buffer succeeded.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TransactionResultStatus.Failure">
            <summary>
            This means that at least one of the items in the transaction buffer failed. It
            may mean that other record did succeed. This depends on the implementation of the
            specific FeatureSource.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.TransactionResultStatus.Cancel">
            <summary>This means that the transaction was canceled.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.WorldFile">
            <summary>This class represents the values of a world file.</summary>
            <remarks>
            A world file is an attribute file that is associated with a corresponding image file.
            Typically, the world file consists of 6 lines of numbers.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.WorldFile.#ctor">
            <summary>This is the default constructor for the WorldFile class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.WorldFile.#ctor(System.String)">
            <summary>
            This is the constructor that passes the worldFile text.
            </summary>
            <remarks> The worldFileText is typically read from a world file.</remarks>
            <param name="worldFileText">The world file text containing the world file attribute information.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.WorldFile.#ctor(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single)">
            <summary>
            This is the constructor that passes the WorldExtent of the image, the height of
            the image, and the width of the image.
            </summary>
            <param name="worldExtent">This parameter specifies the World Coordinate Extent for the image.</param>
            <param name="imageWidth">This parameter specifies the image width for the image.</param>
            <param name="imageHeight">This parameter specifies the image height for the image.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.WorldFile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            This is a constructor that passes 6 attributes in double associated with the corresponding
            image file.
            </summary>
            <returns>None</returns>
            <param name="horizontalResolution">This parameter specifies the size of pixels in the x direction.</param>
            <param name="rotationRow">This parameter specifies the rotation term for row.</param>
            <param name="rotationColumn">This parameter specifes the rotation term for column.</param>
            <param name="verticalResolution">This parameter specifies the size of pixels in the y direction.</param>
            <param name="upperLeftX">This parameter represents the x coordinate of the center of the upper-leftmost pixel in map units.</param>
            <param name="upperLeftY">This parameter represents the y coordinate of the center of the upper-leftmost pixel in map units.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.WorldFile.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            This is a constructor that passes 6 attributes in float associated with the corresponding
            image file.
            </summary>
            <returns>None</returns>
            <param name="horizontalResolution">This parameter specifies the size of pixels in the x direction.</param>
            <param name="rotationRow">This parameter specifies the rotation term for row.</param>
            <param name="rotationColumn">This parameter specifes the rotation term for column.</param>
            <param name="verticalResolution">This parameter specifies the size of pixels in the y direction.</param>
            <param name="upperLeftX">This parameter represents the x coordinate of the center of the upper-leftmost pixel in map units.</param>
            <param name="upperLeftY">This parameter represents the y coordinate of the center of the upper-leftmost pixel in map units.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.WorldFile.HorizontalResolution">
            <summary>This property gets the horizontal resolution from the world file.</summary>
            <value>This property gets the horizontal resolution from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.WorldFile.RotationRow">
            <summary>This property gets the rotation in row from the world file.</summary>
            <value>This property gets the rotation in row from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.WorldFile.RotationColumn">
            <summary>This property gets the rotation in column from the world file.</summary>
            <value>This property gets the rotation in column from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.WorldFile.VerticalResolution">
            <summary>This property gets the vertical resolution from the world file.</summary>
            <value>This property gets the vertical resolution from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.WorldFile.UpperLeftX">
            <summary>This property gets the upper left Y coordinate from the world file.</summary>
            <value>This property gets the upper left Y coordinate from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.WorldFile.UpperLeftY">
            <summary>This property gets the upper left X coordinate from the world file.</summary>
            <value>This property gets the upper left X coordinate from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawingEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayerDrawing event. It
            is raised before the AdornmentLayer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayerDrawing event. It
            is raised before the AdornmentLayer is drawn. This event allows you to manipulate the
            AdornmentLayer, or draw something with the canvas before the AdornmentLayer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawingEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawingEventArgs.#ctor(ThinkGeo.MapSuite.Layers.AdornmentLayer)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayer">This parameter is the AdornmentLayer that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawingEventArgs.AdornmentLayer">
            <summary>This property gets and sets the AdornmentLayer that will be drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawnEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayerDrawn event. It is raised
            after the AdornmentLayer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayerDrawn event. It is raised
            after the AdornmentLayer is drawn. This event allows you to manipulate the AdornmentLayer,
            or draw something with the canvas after the AdornmentLayer has been drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawnEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawnEventArgs.#ctor(ThinkGeo.MapSuite.Layers.AdornmentLayer)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayer">This parameter is the AdornmentLayer that has been drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayerDrawnEventArgs.AdornmentLayer">
            <summary>This property gets and sets the AdornmentLayer that has been drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawingEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayersDrawing event. It is raised
            before any of the AdornmentLayers are drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayersDrawing event. It is raised
            before any of the AdornmentLayers are drawn. This event allows you to manipulate the
            AdornmentLayers, or draw something with the canvas before any of the AdornmentLayers
            are drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawingEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawingEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.AdornmentLayer})">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayers">This parameter is the AdornmentLayers that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawingEventArgs.AdornmentLayers">
            <summary>This property gets and sets the AdornmentLayers that will be drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawnEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayersDrawn event. It is raised
            after all of the AdornmentLayers have been drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayersDrawn event. It is raised
            after all of the AdornmentLayers have been drawn. This event allows you to manipulate the
            AdornmentLayers, or draw something with the canvas after all of the AdornmentLayers
            have been drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawnEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawnEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.AdornmentLayer})">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayers">This parameter is the AdornmentLayers that have been drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayersDrawnEventArgs.AdornmentLayers">
            <summary>This property gets and sets the AdornmentLayers that have been drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.AdornmentLocation">
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.UseOffsets">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.UpperLeft">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.UpperCenter">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper center point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.UpperRight">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper right point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.CenterLeft">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the center left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.Center">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the center point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.CenterRight">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the center right point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.LowerLeft">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the lower left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.LowerCenter">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the lower center point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.AdornmentLocation.LowerRight">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the lower right point.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.AdornmentLayer">
            <summary>
            This is the base class of AdornmentLayers. The <strong>AdornmentLayer</strong> is
            used to place adornments on the map. Two types of AdornmentLayers are provided:
            <strong>ScaleLineAdornmentLayer</strong> and
            <strong>ScaleBarAdornmentLayer</strong>.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayer.#ctor">
            <summary>This method is the default constructor for the AdornmentLayer.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayer.Location">
            <summary>This property gets and sets the drawing location of the AdornmentLayer.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayer.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for the AdornmentLayer.</summary>
            <remarks>
            This property allows you to specify an X offset. It is useful, when combined with
            a Y offset, to do things like modify the location of the
            adornment.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.AdornmentLayer.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for the AdornmentLayer.</summary>
            <remarks>
            This property allows you to specify a Y offset. It is useful, when combined with
            an X offset, to do things like modify the location of the
            adornment.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayer.DrawCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the AdornmentLayer.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. This method
            draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            You can use the full power of the GeoCanvas to do the drawing.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the geoCanvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labelsInAllLayers, we will throw an ArgumentNullException.</exception>
            <param name="labelsInAllLayers">This parameter represents the labels used for collision detection and duplication checking.</param>
            <param name="canvas">This parameter is the canvas object (or a GeoImage) to draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.AdornmentLayer.GetDrawingLocation(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Single,System.Single)">
            <summary>This method returns the drawing location of the AdornmentLayer.</summary>
            <returns>
            It returns the upper left screen point of where the AdornmentLayer will be
            drawn.
            </returns>
            <param name="canvas">This parameter is the canvas used in drawing.</param>
            <param name="adornmentWidth">This parameter is the width of the adornment.</param>
            <param name="adornmentHeight">This parameter is the height of the adornment</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.EditTools">
            <summary>
            This class is a wrapper class for the FeatureLayer that isolates only the editing
            methods to make them easily accessible to the programmer.
            </summary>
            <remarks>
            This class is a wrapper class for the FeatureLayer that isolates only the editing
            methods to make them easily accessible to the programmer.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor. It is protected and not meant to be used.</overloads>
            <returns>None</returns>
            <remarks>This is the default constructor. It is protected and not meant to be used.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.#ctor(ThinkGeo.MapSuite.Layers.FeatureSource)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the FeatureSource.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="featureSource">
            This parameter is the FeatureSource that the edit operations will pass through
            to.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.EditTools.IsInTransaction">
            <summary>
            This property returns true if the FeatureLayer is in a transaction and false if it
            is not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureLayer is in a transaction and false if it
            is not.
            </decimalDegreesValue>
            <remarks>
            To enter a transaction, you must first call the BeginTransaction method of the
            FeatureLayer. It is possible that some FeatureLayers are read only and do not allow
            edits. To end a transaction, you must either call CommitTransaction or
            RollbackTransaction.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.EditTools.IsTransactionLive">
            <summary>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the FeatureLayer,
            such as spatial queries.
            </summary>
            <decimalDegreesValue>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the
            FeatureLayer.
            </decimalDegreesValue>
            <remarks>
            The live transaction concept means that all of the modifications you perform during
            a transaction are live from the standpoint of the querying methods on the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.EditTools.IsEditable">
            <summary>This property returns whether the FeatureLayer allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns whether the FeatureLayer allows edits or is read only. The
            property returns true if the FeatureLayer allows edits and false if the FeatureLayer is
            read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureLayer accepts editing.
                If you call BeginTransaction and this property is false, then an exception will
                be raised.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.EditTools.TransactionBuffer">
            <summary>This property allows you get and set the transaction buffer.</summary>
            <value>None</value>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.BeginTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not editable, it will throw an InvalidOperationException.</exception>
            <summary>This method starts a new transaction if the FeatureLayer allows editing.</summary>
            <returns>None</returns>
            <remarks>
            This method is used to start a transaction, assuming that the FeatureLayer allows
            editing. There are some additional prerequisites to beginning a transaction, such as ensuring
            that a transaction is not already in progress. You must also be sure that the FeatureSource has
            been opened.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Add(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <overloads>This overload allows you to pass in a shape.</overloads>
            <param name="shape">
            This parameter represents the new shape that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Add(ThinkGeo.MapSuite.Shapes.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <overloads>This overload allows you pass in a Feature.</overloads>
            <param name="feature">
            This parameter represents the new Feature that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Add(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <overloads>This overload allows you pass in a Feature.</overloads>
            <summary>This overload allows you pass in a Feature.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <param name="shape">
            This parameter represents the new BaseShape that will be added to the
            transaction.
            </param>
            <param name="columnValues">
            This parameter represents DBF information of the new BaseShape.
            </param>
            <returns>
            This string is the ID that will uniquely identify this BaseShape while it is in a
            transaction.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the shape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnValues, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.ScaleUp(System.String,System.Double)">
            <summary>
            This method increases the size of the feature by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            This method is useful when you would like to increase the size of the Feature. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <param name="featureId">This parameter is the Id of the Feature you want to scale.</param>
            <param name="percentage">This is the percentage by which to increase the Feature's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.ScaleDown(System.String,System.Double)">
            <summary>
            This method decreases the size of the feature by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            This method is useful when you would like to decrease the size of the Feature. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will expand the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <param name="featureId">This parameter is the Id of the Feature you want to scale.</param>
            <param name="percentage">This is the percentage by which to decrease the Feature's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.TranslateByDegree(System.String,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the Feature from one location to another based on a distance
            and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance unit is based on a DistanceUnit you specify in the
            distanceUnit parameter, regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method is a helpful function that allows you to easily edit InternalFeatures
                directly in the FeatureSource without having to retrieve them, convert them to a
                shape, manipulate them and put them back into the FeatureSource.<br/>
            		<br/>
                This method moves the Feature from one location to another based on angleInDegrees
                and the distance parameter. With this overload, it is important to note that the
                distance units are based on the specified distanceUnit parameter. For example, if your
                Feature is in decimal degrees and you call this method with a specified distanceUnit of
                miles, you're going to move this shape a number of miles based on the distance and
                angleInDegrees. In this way, you could easily move a shape in decimal degrees five
                miles to the north.</para>
            	<para>If you pass a distance of 0, the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees that is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance that is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <returns>None</returns>
            <param name="featureId">This parameter is the Feature you want to move.</param>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with zero being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographicUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure of the translate.
            For example, if you select miles as your distanceUnit, then the distance will be
            calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.TranslateByOffset(System.String,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the Feature from one location to another based on a X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method is a helpful function that allows you to easily edit InternalFeatures
                directly in the FeatureSource without having to retrieve them, convert them to a
                shape, manipulate them and put them back into the FeatureSource.<br/>
            		<br/>
                This method moves the Feature from one location to another based on an X and Y
                offset distance. With this overload, it is important to note that the
                distance units are based on the specified distanceUnit parameter. For example, if your
                Feature is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this Feature one unit of the distanceUnit in the
                horizontal direction and one unit of the distanceUnit in the vertical direction.
                In this way, you could easily move a Feature in decimal degrees five miles on the X
                axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape that has no points, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <param name="featureId">This parameter is the Feature you want to move.</param>
            <param name="xOffset">
            This is the number of horizontal units of movement in the DistanceUnit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffset">
            This is the number of horizontal units of movement in the DistanceUnit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="offsetUnit">
            	<para>This is the DistanceUnit you would like to use as the measure of the
                translate. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Rotate(System.String,ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the Feature any number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method is a helpful function that allows you to easily edit InternalFeatures
                directly in the FeatureSource without having to retrieve them, convert them to a
                shape, manipulate them and put them back into the FeatureSource.<br/>
            		<br/>
                This method rotates the Feature based on a pivot point by a number of degrees. By
                placing the pivot point in the center of the Feature, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the Feature, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <returns>None</returns>
            <param name="featureId">This parameter is the Feature you want to rotate.</param>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Union(System.String,ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the union of the Feature and the target shapes, which are defined as the
            set of all points in the Feature or the target shape.
            </summary>
            <returns>None</returns>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            	<br/>
            This is useful for adding area shapes together to form a larger area shape.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that has no points, it will throw an InvalidOperationException.</exception>
            <overloads>This overload allows you pass in an AreaBaseShape.</overloads>
            <param name="featureId">This parameter is the Feature you want to add the new area to.</param>
            <param name="targetShape">The shape you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Union(System.String,ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the union of the Feature and the target features, which are defined as the
            set of all points in the Feature or the target shape.
            </summary>
            <returns>None</returns>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            	<br/>
            This is useful for adding area shapes together to form a larger area shape.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null featureId, we will throw an ArgumentNullException.</exception>
            <overloads>This overload allows you pass in a Feature.</overloads>
            <param name="featureId">This parameter is the Feature you want to add the new area to.</param>
            <param name="targetAreaFeature">The feature you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.GetDifference(System.String,ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the difference between two shapes, which are defined as the set of all
            points that lie in the Feature but not in the targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.
            </remarks>
            <returns>None</returns>
            <param name="featureId">This is the Feature you want to remove area from.</param>
            <param name="targetShape">The shape you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.GetDifference(System.String,ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the difference between two features, which are defined as the set of all
            points which lie in the Feature but not in the targetFeature.
            </summary>
            <returns>None</returns>
            <param name="featureId">This is the Feature you want to remove area from.</param>
            <param name="targetAreaFeature">The feature you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Delete(System.String)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method deletes a Feature from an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <summary>This method deletes a Feature from an existing transaction.</summary>
            <returns>None</returns>
            <param name="id">
            This string is the Id of the feature in the FeatureLayer that you wish to
            delete.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Update(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <overloads>
            This overload allows you to pass in a shape and the Id to the Feature it will
            update.
            </overloads>
            <param name="shape">The shape you wish to update in the transaction. The Id of the Shape should be the feature Id which you wish to update.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Update(ThinkGeo.MapSuite.Shapes.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <overloads>This overload allows you pass in a Feature.</overloads>
            <param name="feature">The Feature you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.Update(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <overloads>
            This overload allows you to pass in a shape and the columnValues to the Feature it will
            update.
            </overloads>
            <param name="shape">The shape you wish to update in the transaction. The Id of the Shape should be the feature id which you wish to update.</param>
            <param name="columnValues">The column values you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.RollbackTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method will cancel an existing transaction. It will free up the internal
                memory cache of any InternalFeatures added, updated or deleted. You will need to ensure
                that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>
            This method will cancel an existing transaction. It will free up the internal
            memory cache of any InternalFeatures added, updated or deleted.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.EditTools.CommitTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>
            The returned decimalDegreesValue of this method is a TransactionResult class, which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any errors that were encountered during the
            committing of the transaction.
            </returns>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of data. It
                will then pass back the results of the commit, including any error(s) received. Finally,
                it will free up the internal memory cache of any InternalFeatures added, updated
                or deleted. You will need to ensure that you have started a transaction by calling
                BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.FeatureLayer">
            <summary>This class represents a layer that is comprised of feature data.</summary>
            <remarks>
            This abstract class is the basis for all feature-based layers in the system. Its
            methods and properties deal with feature data manipulation. Some of the classes that
            currently inherit from this are ShapeFileFeatureLayer, OracleFeatureLayer and so on.<br/>
            	<br/>
            When creating your own FeatureLayer, you need only to set a FeatureSource and create a
            useful constructor; the class will take care of the rest. There are no required
            abstract members. It may be helpful for you to add additional properties specific to
            your FeatureSource.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.FeatureLayer.DrawingFeatures">
            <summary>This event is raised when features are about to be drawn in the layer.</summary>
            <remarks>
            This event is raised when features are about to be drawn in the layer. In the event
            arguments, there is a collection of features to be drawn. You can easily add or remove
            items from this collection so that extra items will draw or not draw.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.#ctor">
            <summary>This is a constructor for this class.</summary>
            <returns>None</returns>
            <remarks>This is a constructor for this class.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.OnDrawingFeatures(ThinkGeo.MapSuite.Layers.DrawingFeaturesEventArgs)">
            <summary>This method raises the DrawingFeatures event.</summary>
            <returns>None</returns>
            <remarks>
            	<list type="bullet">
            		<item>You can call this method from a derived class to enable it to raise the
                    event. This may be useful if you plan to extend the FeatureLayer and you need
                    access to the event.<br/>
            			<br/>
                    This event is meant to allow you to add or remove the features to be drawn.</item>
            	</list>
            </remarks>
            <param name="e">This parameter represents the event arguments for the event.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.WrappingMode">
            <summary>
            Thie property gets or sets whether allow wrap date line.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.EditTools">
            <summary>
            This property gets the EditTools that allow you to easily edit InternalFeatures in the
            Feature Layer.
            </summary>
            <value>
            This property gets the EditTools that allow you to easily edit InternalFeatures in the
            Feature Layer.
            </value>
            <remarks>
            The EditTools are supplied as an easily accessible wrapper for the editing
            methods of the FeatureSource.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.FeatureIdsToExclude">
            <summary>
            A collection of strings representing record id of features not to get in the Layer.
            </summary>
            <remarks>
            This string collection is a handy place to specify what records not to get from the source.
            Suppose you have a shape file of roads and you want to hide the roads within a particular
            rectangle, simply execute GetFeaturesInsideBoundingBox() and add the id of the return
            features to the collection and forget about them. Since you can set this by Layer it
            makes is easy to determine what to and what not to.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.QueryTools">
            <summary>
            This property gets the QueryTools that allow you to easily query Features from the
            Feature Layer.
            </summary>
            <value>
            This property gets the QueryTools that allow you to easily query Features from the
            Feature Layer.
            </value>
            <remarks>
            This property gets the QueryTools that allow you to easily query Features from the
            Feature Layer. The QueryTools are supplied as an easily accessible wrapper for the
            query methods of the FeatureSource.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.FeatureSource">
            <summary>This property gets the FeatureSource for the FeatureLayer.</summary>
            <value>This property gets the FeatureSource for the FeatureLayer.</value>
            <remarks>
            The FeatureSource is the provider of data to the FeatureLayer. There are different
            FeatureSource classes to match the various ways that feature data is stored. It is
            important that, when you inherit from the FeatureLayer, in the constructor you set
            the FeatureSource you want to use.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.DrawingQuality">
            <summary>
            This property gets and sets the general drawing quality for the FeatureLayer's
            canvas.
            </summary>
            <value>
            This property gets the general drawing quality for the FeatureLayer's
            canvas.
            </value>
            <remarks>
            The DrawingQuality enumeration allows you to control, in a macro sense, the drawing
            quality that will be used in the GeoCanvas. Each GeoCanvas, which is responsible for
            drawing of the features, may have its own specialized drawing quality properties. What the
            DrawingQuality enumeration does is define some general guidelines for each GeoCanvas.
            For example, if you set the DrawingQuality to HighSpeed, then inside of the
            PlatformGeoCanvas there is a profile for HighSpeed. This profile sets specific
            properties, such as the smoothing mode and composing drawing mode of the
            PlatformGeoCanvas. As each GeoCanvas may have different drawing quality properties, this
            offers a general way to control drawing quality and speed.<br/>
            	<br/>
            If you need complete control over how a specific GeoCanvas will draw, then you can
            set the DrawingQuality to Custom. This will tell the specific GeoCanvas to use the
            properties on its own object instead of one of the pre-defined profiles. If one of the
            profiles -- such as HighSpeed or HighQuality -- is set, then the specific GeoCanvas ignores its
            own properties for drawing quality.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.ZoomLevelSet">
            <summary>
            This property gets and sets the ZoomLevelSet, which contains the specific zoom
            levels for the FeatureLayer.
            </summary>
            <value>
            This property gets the ZoomLevelSet, which contains the specific zoom levels for
            the FeatureLayer.
            </value>
            <remarks>
            The ZoomLevelSet is a class that contains all of the ZoomLevels for the
            FeatureLayer. Each ZoomLevel contains the styles that are used to determine how to draw the
            InternalFeatures.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.FeatureLayer.IsOpenCore">
            <summary>
            This property returns true if the FeatureLayer is open and false if it is
            not.
            </summary>
            <value>
            This property returns true if the FeatureLayer is open and false if it is
            not.
            </value>
            <remarks>
            Various methods on the FeatureLayer require that it be in an open state. If one of
            those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the FeatureLayer Open method. The
            method will raise an exception if the current FeatureLayer is already open.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.DrawCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>
            This method will draw the FeatureLayer source based on the parameters
            provided.
            </summary>
            <returns>None</returns>
            <remarks>
            The DrawCore will be called when the layer is being drawn. It will check if the InternalFeatures are
            within the extent and whether it is within a defined zoom level. If these parameters
            are met, then it will apply the styles of the proper zoom level to the InternalFeatures for
            drawing. Lastly, it will draw InternalFeatures on the GeoImage or native image passed in to the
            method.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer is not opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labeledInLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the worldExtent, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <param name="canvas">
            This parameter is the GeoCanvas used to Draw the layer.
            </param>
            <param name="labelsInAllLayers">This parameter is not used for ImageLayers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.SetupTools">
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method SetupToolsCore.
                The SetupTools method allows you to create the QueryTool, EditTools and other tools
                you may need on your object. We created this method so that if you want to extend
                one of the tool classes, you can override the SetupToolsCore and create any class you
                want.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>This method sets up the EditTools and QueryTools objects.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.SetupToolsCore">
            <remarks>
            <para>This method is the concrete wrapper for the abstract method SetupTools.
            The SetupTools method allows you to create the QueryTool, EditTools and other tools
            you may need on your object. We created this method so that if you want to extend
            one of the tool classes, you can override the SetupToolsCore and create any class you
            want.</para>
            </remarks>
            <summary>This method sets up the EditTools and QueryTools objects.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureLayer so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The Open
            method plays an important role, as it is responsible for initializing the FeatureLayer.
            Most methods on the FeatureLayer will throw an exception if the state of the FeatureLayer
            is not opened. When the map draws each FeatureLayer, it will open the layer as one of its first
            steps, then after it is finished drawing with that FeatureLayer it will close it. In
            this way we are sure to release all resources used by the FeatureLayer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The close method plays an important role in the life cycle of the FeatureLayer. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureLayer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.FeatureLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the FeatureLayer.</summary>
            <returns>This method returns the bounding box of the FeatureLayer.</returns>
            <remarks>
            This method is called from the concrete public method GetBoundingBox. It returns
            the bounding box of the FeatureLayer.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.QueryTools">
            <summary>This is a helper class that allows you to execute various queries.</summary>
            <remarks>
            This is a helper class that allows you to execute various queries. It wraps
            the query functionality of the FeatureSource and provides a simpler and more focused
            set of APIs.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor, though it is typically not intended to be
            used.
            </overloads>
            <remarks>
            This is the default constructor, though it is typically not intended to be
            used.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.#ctor(ThinkGeo.MapSuite.Layers.FeatureSource)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a FeatureSouce that will provide the
            functionality for this class's methods.
            </overloads>
            <remarks>
            Each of the calls in this class thunk through to the FeatureSource passed
            in.
            </remarks>
            <returns>None</returns>
            <param name="featureSource">
            This parameter is the FeatureSource that will provide the functionality for this
            class's methods.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesByColumnValue(System.String,System.String,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesByColumnValue(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesByColumnValue(System.String,System.String)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that contain the target shape.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that contain the TargetShape you passed in.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that contain the specified target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that contain the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and
            the spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that contain the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            	<para><strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that contain the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and
            the spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that contain the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that contain the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and
            the spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetFeature.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that contain the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that contain the target feature.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target shape.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that cross the TargetShape you passed in.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<strong>Crossing</strong> - The Geometries share some but not all interior points, and the
                dimension of the intersection is less than that of at least one of the Geometries.<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target shape.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features which crosses the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the Internalfeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the Internalfeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.</para>
            	<para></para>
            	<para><strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that disjoint the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.</para>
            	<para></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that disjoint the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that disjoint the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Shapes.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are outside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are outside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are outside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are outside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are outside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are outside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are outside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are outside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are inside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are inside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are inside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are inside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are inside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are inside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are inside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are inside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">This parameter is the feature you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            feature.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">This parameter is the feature you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            feature.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <param name="searchRadius">
            Limit the maximize distance proximately to search closest records.
            </param>
            <param name="unitOfSearchRadius">
            The unit of searchRadius parameter.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <param name="searchRadius">
            Limit the maximize distance proximately to search closest records.
            </param>
            <param name="unitOfSearchRadius">
            The unit of searchRadius parameter.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc..
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeatureById(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method returns an InternalFeature based on an Id provided.</summary>
            <returns>This method returns an InternalFeature based on an Id provided.</returns>
            <remarks>This method returns an InternalFeature based on an Id provided.</remarks>
            <param name="id">This parameter is the unique Id for the feature you want to find.</param>
            <param name="returningColumnNames">
            This parameter is a list of column names you want returned with the
            Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeatureById(System.String,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns an InternalFeature based on an Id provided.</summary>
            <returns>This method returns an InternalFeature based on an Id provided.</returns>
            <remarks>This method returns an InternalFeature based on an Id provided.</remarks>
            <param name="id">This parameter is the unique Id for the feature you want to find.</param>
            <param name="returningColumnNamesType">
            This parameter is a list of column names you want returned with the
            Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </remarks>
            <param name="ids">This parameter is the collection of Ids you want to find.</param>
            <param name="returningColumnNames">
            This parameter is a list of column names you want returned with the
            Features.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </remarks>
            <param name="ids">This parameter is the collection of Ids you want to find.</param>
            <param name="returningColumnNamesType">
            This parameter is a list of column names you want returned with the
            Features.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetBoundingBoxById(System.String)">
            <summary>This method returns the bounding box for the Id specified.</summary>
            <returns>This method returns the bounding box for the Id specified.</returns>
            <remarks>This method returns the bounding box for the Id specified.</remarks>
            <param name="id">
            This parameter is the unique Id of the feature for which you want to find the bounding
            box.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetBoundingBoxesByIds(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method returns a collection of bounding boxes based on the collection of Ids
            provided.
            </summary>
            <returns>
            This method returns a collection of bounding boxes based on the collection of Ids
            provided.
            </returns>
            <remarks>
            This method returns a collection of bounding boxes based on the collection of Ids
            provided.
            </remarks>
            <param name="ids">This parameter is the collection of Ids you want to find.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetColumns">
            <summary>This method returns the collection of columns for this FeatureSource.</summary>
            <returns>This method returns the collection of columns for this FeatureSource.</returns>
            <remarks>This method returns the collection of columns for this FeatureSource.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetCount">
            <summary>This method returns the count of all of the InternalFeatures in the FeatureSource.</summary>
            <returns>This method returns the count of all of the InternalFeatures in the FeatureSource.</returns>
            <remarks>This method returns the count of all of the InternalFeatures in the FeatureSource.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetAllFeatures(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return value is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetAllFeatures(ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return value is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.GetFirstFeaturesWellKnownType">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the well known type that represents the first feature from FeatureSource.</summary>
            <returns>This method returns the well known type that represents the first feature from FeatureSource.</returns>
            <remarks>
            	<para>
                The default implementation of GetCountCore uses the GetAllRFeaturesCore method to
                get WellKnownType of the first feature from all features. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient.
                </para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.QueryTools.CanExecuteSqlQuery">
            <summary>
            This property specifies whether FeatureSource can excute a SQL query or not.
            If it is false, then it will throw an exception when the following APIs are called: ExecuteScalar, ExecuteNonQuery, ExecuteQuery
            </summary>
            <remarks>The default implementation is false.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.ExecuteNonQuery(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.ExecuteScalar(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than use the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The SQL statement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.QueryTools.ExecuteQuery(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than use the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The SQL statement to be excuted.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RasterLayer">
            <summary>This abstract class is the basis for all image-based layers in the system.</summary>
            <remarks>
            This abstract class is the basis for all image-based layers in the system. Its
            methods and properties deal with image manipulation. Currently, some classes that
            inherit from this are EcwRasterLayer, MrSidRasterLayer, GridRasterLayer and so on.<br/>
            	<br/>
            When creating your own RasterLayer, you need only to set a RasterSource and create a
            useful constructor; the class will take care of the rest. There are no required
            abstract members. It may be helpful for you to add additional properties specific to
            your ImageSource.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.#ctor">
            <summary>
            This is a constructor for the class. If you use this constructor, you should set
            the properties you need manually.
            </summary>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you should set the properties you need
            manually.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterLayer.ImageSource">
            <summary>This property gets and sets the ImageSource used by the RasterLayer.</summary>
            <value>This property gets the ImageSource used by the RasterLayer.</value>
            <remarks>
            The set for this property is protected and only intended to be used by developers
            who are creating their own ImageSources. This is the main property to set for developers who are creating
            their own RasterLayer derivatives.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterLayer.UpperThreshold">
            <summary>
            This property gets and sets the upper threshold in the scale at which to display the
            image.
            </summary>
            <value>This property gets the upper threshold in the scale at which to display the image.</value>
            <remarks>
            Above the upper threshold in scale, the image will not be displayed. This, in
            conjunction with the LowerThreshold property, allows you to create a band in which it is
            suitable to display the image source. By default, the upper threshold is double.max and
            lower threshold is double.min. This means the image should always display.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterLayer.LowerThreshold">
            <remarks>
            Below the lower threshold in scale, the image will not be displayed. This, in
            conjunction with the UpperThreshold property, allows you to create a band in which it is
            suitable to display the image source. By default, the upper threshold is double.max and
            lower threshold is double.min. This means the image should always display.
            </remarks>
            <summary>
            This property gets and sets the lower threshold in the scale at which to display the
            image.
            </summary>
            <value>This property gets the lower threshold in the scale at which to display the image.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterLayer.HasProjectionText">
            <summary>
            This property returns true if the RasterLayer contains projection parameters and false if
            it does not contain any projection parameters.
            </summary>
            <value>
            This property returns true if the RasterLayer contains projection parameters and false if
            it does not contain any projection parameters.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterLayer.ScaleFactor">
            <summary>
            The scale factor when drawing the primitive image. For example I am looking for an image with 100*100px, If the 
            ScaleFactor is set to 2, it means the component will get the image with 200*200px.  We want to keep it as 1 (by default)
            for most cases. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.GetProjectionText">
            <summary>This method returns the projection parameters of the current layer.</summary>
            <returns>This method returns the projection parameters of the current layer.</returns>
            <remarks>This method returns the projection parameters of the current layer.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RasterLayer.IsOpenCore">
            <summary>
            This property returns true if the RasterLayer is open and false if it is
            not.
            </summary>
            <value>
            This property returns true if the RasterLayer is open and false if it is
            not.
            </value>
            <remarks>
            Various methods on the RasterLayer require that it be in an open state. If one
            of those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the RasterLayer's Open method. The
            method will raise an exception if the current RasterLayer is already open.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.GetHorizontalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the horizontal resolution of the image.</summary>
            <returns>This method returns the horizontal resolution of the image.</returns>
            <remarks>
            This method returns the horizontal resolution of the image.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.GetVerticalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the vertical resolution of the image.</summary>
            <returns>This method returns the vertical resolution of the image.</returns>
            <remarks>
            This method returns the vertical resolution of the image.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterLayer.</summary>
            <returns>This method returns the bounding box of the RasterLayer.</returns>
            <remarks>This method returns the bounding box of the RasterLayer.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.OpenCore">
            <summary>
            This method opens the RasterLayer so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            The open method plays an important rol,e as it is responsible for initializing the
            RasterLayer. Most methods on the RasterLayer will throw an exception if the state of
            the RasterLayer is not opened. When the map draws each layer, it will open the
            RasterLayer as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            RasterLayer.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.CloseCore">
            <summary>
            This method opens the RasterLayer so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            The close method plays an important role in the life cycle of the RasterLayer. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed RasterLayer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.DrawCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>
            This method will draw the image from the GeoImage source based on the parameters
            provided.
            </summary>
            <returns>None</returns>
            <remarks>
            The DrawCore method will be called when the layer is being drawn. It will determine if
            the image is within the extent and the threshold defined. If these
            parameters are met, it will query the RasterSource for an image and then apply
            the other various properties (such as transparency, etc.) on the image. Lastly, it will draw
            the image on the GeoImage or native image passed into the method.
            </remarks>
            <param name="canvas">
            This parameter is the GeoCanvas used to Draw the RasterLayer.
            </param>
            <param name="labelsInAllLayers">This parameter is not used for ImageLayers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </summary>
            <returns>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </returns>
            <remarks>
            This method is used to determine whether the RasterLayer needs to draw based on the
            current extent and the the threshold parameters provided.
            </remarks>
            <param name="currentExtent">
            This parameter is the current extent that you want determine is within the thresholds
            defined.
            </param>
            <param name="upperThreshold">This parameter is the upper threshold used to test the extent.</param>
            <param name="lowerThreshold">This parameter is the lower threshold used to test the extent.</param>
            <param name="canvasWidth">This parameter is the width of the canvas.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RasterLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.GeographyUnit,System.Single)">
            <summary>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </summary>
            <returns>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </returns>
            <remarks>
            This method is used to determine whether the RasterLayer needs to draw based on the
            current extent and the the threshold parameters provided.
            </remarks>
            <param name="currentExtent">
            This parameter is the current extent that you want determine is within the thresholds
            defined.
            </param>
            <param name="upperThreshold">This parameter is the upper threshold used to test the extent.</param>
            <param name="lowerThreshold">This parameter is the lower threshold used to test the extent.</param>
            <param name="canvasWidth">This parameter is the width of the canvas.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
            <param name="dpi">This parameter is the dpi of the current extent.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel">
            <summary>
            This enumeration is used on a ZoomLevel to allow its styles to be applied to
            other zoom levels.
            </summary>
            <remarks>
            This enumeration is used on a ZoomLevel to allow its styles to be applied to
            other zoom levels.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.None">
            <summary>Default; the apply-until-zoom-level feature will not be enabled.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level01">
            <summary>The zoom level's styles will be applied to zoom level 1.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level02">
            <summary>The zoom level's styles will be applied to zoom level 2.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level03">
            <summary>The zoom level's styles will be applied to zoom level 3.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level04">
            <summary>The zoom level's styles will be applied to zoom level 4.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level05">
            <summary>The zoom level's styles will be applied to zoom level 5.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level06">
            <summary>The zoom level's styles will be applied to zoom level 6.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level07">
            <summary>The zoom level's styles will be applied to zoom level 7.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level08">
            <summary>The zoom level's styles will be applied to zoom level 8.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level09">
            <summary>The zoom level's styles will be applied to zoom level 9.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level10">
            <summary>The zoom level's styles will be applied to zoom level 10.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level11">
            <summary>The zoom level's styles will be applied to zoom level 11.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level12">
            <summary>The zoom level's styles will be applied to zoom level 12.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level13">
            <summary>The zoom level's styles will be applied to zoom level 13.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level14">
            <summary>The zoom level's styles will be applied to zoom level 14.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level15">
            <summary>The zoom level's styles will be applied to zoom level 15.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level16">
            <summary>The zoom level's styles will be applied to zoom level 16.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level17">
            <summary>The zoom level's styles will be applied to zoom level 17.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level18">
            <summary>The zoom level's styles will be applied to zoom level 18.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level19">
            <summary>The zoom level's styles will be applied to zoom level 19.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ApplyUntilZoomLevel.Level20">
            <summary>The zoom level's styles will be applied to zoom level 20.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DrawingAttributionLayerEventArgs.Cancel">
            <summary>
            This property gets and sets a value that determines whether you want to cancel the Overlay from
            drawing.
            </summary>
            <value>This property gets a value that determines whether you want to cancel the Overlay from drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DrawingAttributionLayerEventArgs.GeoCanvas">
            <summary>
            This property gets and sets the GeoCanvas we are drawing
            on.
            </summary>
            <value>This property gets the GeoCanvas we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.DrawingFeaturesEventArgs">
            <summary>
            This is the event arguments class for the DrawingFeatures event of the
            FeatureLayer.
            </summary>
            <remarks>
            This is the event arguments class for the DrawingFeatures event of the
            FeatureLayer. You can use the FeaturesToDraw property to add and remove features to draw
            before the FeatureLayer actually draws them.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DrawingFeaturesEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DrawingFeaturesEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Layers.ZoomLevel)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="featuresToDraw">This parameter represents the faatures that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DrawingFeaturesEventArgs.FeaturesToDraw">
            <summary>This property gets the collection of InternalFeatures that will draw.</summary>
            <decimalDegreesValue>This property gets the collection of InternalFeatures that will draw.</decimalDegreesValue>
            <remarks>
            This property gets the collection of InternalFeatures that will draw. You can add, remove
            or edit items in this collection and they will be considered for drawing in the
            FeatureLayer.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.DrawingWrappingFeaturesFeatureLayerEventArgs">
            <summary>
            This is the event arguments class for the DrawingFeatures event of the
            FeatureLayer.
            </summary>
            <remarks>
            This is the event arguments class for the DrawingFeatures event of the
            FeatureLayer. You can use the FeaturesToDraw property to add and remove features to draw
            before the FeatureLayer actually draws them.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DrawingWrappingFeaturesFeatureLayerEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.DrawingWrappingFeaturesFeatureLayerEventArgs.#ctor(System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="featuresToDraw">This parameter represents the faatures that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DrawingWrappingFeaturesFeatureLayerEventArgs.FeaturesToDraw">
            <summary>This property gets the collection of InternalFeatures that will draw.</summary>
            <decimalDegreesValue>This property gets the collection of InternalFeatures that will draw.</decimalDegreesValue>
            <remarks>
            This property gets the collection of InternalFeatures that will draw. You can add, remove
            or edit items in this collection and they will be considered for drawing in the
            FeatureLayer.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.DrawnAttributionLayerEventArgs.GeoCanvas">
            <summary>
            This property gets and sets the GeoCanvas we are drawing
            on.
            </summary>
            <value>This property gets the GeoCanvas we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs">
            <summary>
            This is the event arguments class for the LayerDrawing event on the MapEngine class. It
            is raised before the layer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayerDrawing event on the MapEngine class. It
            is raised before the layer is drawn. This event allows you to cancel, manipulate the
            Layer, or draw something with the canvas before the Layer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs.#ctor(ThinkGeo.MapSuite.Layers.Layer,ThinkGeo.MapSuite.Shapes.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the Layer to be drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="currentLayer">This parameter is the layer you will be drawing.</param>
            <param name="worldExtent">This parameter is the world extent you are drawing.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs.Cancel">
            <summary>
            This property gets and sets the value that indicates you want to cancel the layer from
            drawing.
            </summary>
            <value>This property gets the value that indicates you want to cancel the layer from drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs.CurrentLayer">
            <summary>This property gets and sets current layer that will be drawn.</summary>
            <value>This property gets current layer that will be drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent that will be drawn.</summary>
            <value>This property gets the world extent that will be drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawingEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image that we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image that we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.LayerDrawnEventArgs">
            <summary>
            This is the event arguments class for the LayerDrawn event on the MapEngine class. It
            is raised after a layer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayerDrawn event on the MapEngine class. It
            is raised after the layer is drawn. This event allows you to manipulate the
            Layer, or draw something with the canvas after the Layer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayerDrawnEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayerDrawnEventArgs.#ctor(ThinkGeo.MapSuite.Layers.Layer,ThinkGeo.MapSuite.Shapes.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the Layer to be drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="currentLayer">This parameter is the layer that has drawn.</param>
            <param name="worldExtent">This parameter is the world extent that has drawn.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawnEventArgs.CurrentLayer">
            <summary>This property gets and sets layer that has drawn.</summary>
            <value>This property gets current layer that has drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawnEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent to draw.</summary>
            <value>This property gets the world extent to draw.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayerDrawnEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image that we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image that we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs">
            <summary>
            This is the event arguments class for the LayersDrawing event on the MapEngine class. It
            is raised before any of the layers are drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayersDrawing event on the MapEngine class. It
            is raised before any of the layers are drawn. This event allows you to cancel, manipulate the
            Layer, or draw something with the canvas before the Layer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.Layer},ThinkGeo.MapSuite.Shapes.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the layers to be drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="layers">This parameter is the layers that will be drawn.</param>
            <param name="worldExtent">This parameter is the world extent you are drawing.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs.Cancel">
            <summary>
            This property gets and sets the value that indicates you want to cancel all of the layers from
            drawing.
            </summary>
            <value>This property gets the value that indicates you want to cancel all of the layers from drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent that will be drawn.</summary>
            <value>This property gets the world extent that will be drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image that we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image that we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawingEventArgs.Layers">
            <summary>This property gets and sets the layers you will be drawing.</summary>
            <value>This property gets the layers you will be drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.LayersDrawnEventArgs">
            <summary>
            This is the event arguments class for the LayersDrawn event on the MapEngine class. It
            is raised after all of the layers are drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayersDrawn event on the MapEngine class. It
            is raised after the layers are drawn. This event allows you to draw something
            with the canvas after all of the Layers are drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayersDrawnEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.LayersDrawnEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.Layer},ThinkGeo.MapSuite.Shapes.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the layers that were drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="layers">This parameter is the layers that were drawn.</param>
            <param name="worldExtent">This parameter is the world extent you are drawing.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawnEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent to draw.</summary>
            <value>This property gets the world extent to draw.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawnEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.LayersDrawnEventArgs.Layers">
            <summary>This property gets and sets the layers that have been drawn.</summary>
            <value>This property gets the layers that have been drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.WrappingMode.None">
            <summary> Overlay will not wraps at the date line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.WrappingMode.WrapDateline">
            <summary> Overlay wraps at the date line.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ZoomLevel">
            <summary>This class defines how InternalFeatures will be drawn based on their scale.</summary>
            <remarks>
            This class defines how InternalFeatures will be drawn based on their scale. Inside of the
            ZoomLevelSet there are a number of zoom levels. We will determine which ZoomLevel to
            use based on which one has the Scale property closest to the current scale. The
            matching one will define the styles that will be used to draw the InternalFeatures on the map.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevel.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, you should set the
            require properties on the class manually.
            </overloads>
            <remarks>
            This is the default constructor. If you use this constructor, you should set the
            require properties on the class manually.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevel.#ctor(System.Double)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to provide the scale for this ZoomLevel.</overloads>
            <returns>None</returns>
            <remarks>This constructor allows you to provide the scale for this ZoomLevel.</remarks>
            <param name="scale">This paramter is the scale for the ZoomLevel.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.IsActive">
            <summary>This property gets and sets whether the ZoomLevel is active and should draw.</summary>
            <value>This property gets whether the ZoomLevel is active and should draw.</value>
            <remarks>
            Setting the value to false means that this zoom level will not be considered
            in the ZoomLevelSet and thus will not draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.Scale">
            <summary>This property gets and sets the scale for the ZoomLevel.</summary>
            <value>This property gets and sets the scale for the ZoomLevel.</value>
            <remarks>The scale</remarks>
            <requirements>
            The scale is the ratio of a single unit of distance on the map to the equivalent
            distance on the ground. For example, a scale of 1:1 means that one foot on the ground
            would be displayed as one foot on the screen. A scale of 1:1,000 means that one foot on
            the screen is equal to 1,000 feet on the ground.
            </requirements>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.DefaultAreaStyle">
            <summary>This property gets and sets the default AreaStyle used to draw.</summary>
            <value>This property gets the default AreaStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.DefaultLineStyle">
            <summary>This property gets and sets the default LineStyle used to draw.</summary>
            <value>This property gets the default LineStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.DefaultPointStyle">
            <summary>This property gets and sets the default PointStyle used to draw.</summary>
            <value>This property gets the default PointStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.DefaultTextStyle">
            <summary>This property gets and sets the default TextStyle used to draw.</summary>
            <value>This property gets the default TextStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.ApplyUntilZoomLevel">
            <summary>
            This property gets and sets the zoom to which we will use this zoom level's
            styles.
            </summary>
            <value>This property gets the zoom to which we will use this zoom level's styles.</value>
            <remarks>
            This property allows you to apply the current ZoomLevel's styles across many
            ZoomLevels. For example, you may want to display roads as a thin line from
            ZoomLevel10 through ZoomLevel15. To accomplish this easily, you can set the correct styles
            on ZoomLevel10 and then set its ApplyUntilZoomLevel property to Level15. This will mean
            that Level10's style will be used until Level15. There is no need to set Level11,
            Level12, Level13 and so on.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.Name">
            <summary>This property gets and sets the name for the ZoomLevel.</summary>
            <value>This property gets the name for the ZoomLevel.</value>
            <remarks>
            The name is user defined. It is useful to set, as it may be used for higher level
            components such as legends, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevel.CustomStyles">
            <summary>This property gets a collection of custom styles used to draw.</summary>
            <value>This property gets a collection of custom styles used to draw.</value>
            <remarks>
            This is a collection of styles to draw. If you only need to draw one style, then
            we suggest you do not use this collection and instead use one of the default styles, such as
            DefaultAreaStyle, DefaultLineStyle, DefaultTextStyle, etc.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevel.GetRequiredColumnNames">
            <remarks>
            In this method, we return the column names that are required for the styles to
            draw the feature properly. For example, if you have a style that colors areas blue when
            a certain column value is over 100, then you need to be sure you include the column
            name. This will ensure that the column data is returned to you in the feature when it
            is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            styles to properly draw.
            </summary>
            <returns>This method returns a collection containing the required column names.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevel.Draw(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the ZoomLevel.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the Layer based on the extent you provided.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <param name="canvas">This parameter is the Canvas used to draw the InternalFeatures.</param>
            <param name="features">This parameter is the collection of features that we will draw.</param>
            <param name="currentLayerLabels">This parameter is the collection of labels in the current layer.</param>
            <param name="allLayerLabels">This parameter is the collection of labels in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevel.Draw(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the ZoomLevel.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the Layer based on the extent you provided.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <param name="canvas">This parameter is the Canvas used to draw the InternalFeatures.</param>
            <param name="shapes">This parameter is the collection of shapes that we will draw.</param>
            <param name="currentLayerLabels">This parameter is the collection of labels in the current layer.</param>
            <param name="allLayerLabels">This parameter is the collection of labels in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevel.DrawCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the ZoomLevel.</summary>
            <returns>None</returns>
            <remarks>
            This method draws the representation of the Layer based on the extent you
            provided.
            </remarks>
            <param name="canvas">This parameter is the Canvas used to draw the InternalFeatures.</param>
            <param name="features">This parameter is the collection of feature that we will draw.</param>
            <param name="currentLayerLabels">This parameter is the collection of labels in the current layer.</param>
            <param name="allLayerLabels">This parameter is the collection of labels in all layers.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ZoomLevelSet">
            <summary>This class represents a collection of ZoomLevels.</summary>
            <remarks>
            This class represents a collection of ZoomLevels. Each ZoomLevel has a different
            scale and can store Styles that determine how InternalFeatures draw.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>
            This constructor is where we set the default scales for each ZoomLevel. If you
            inherit from this class to create your own custom ZoomSet, then you should not call the
            base constructor if you want to supply your own custom ZoomLevels.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.Name">
            <summary>This property gets and sets the name for the ZoomSet.</summary>
            <decimalDegreesValue>This property gets the name for the ZoomSet.</decimalDegreesValue>
            <remarks>
            The name is user defined. It is useful to set, as it may be used for higher level
            components such as legends, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.CustomZoomLevels">
            <summary>This property gets the custom zoom levels from the zoomLevelSet.</summary>
            <remarks>None</remarks>
            <value>This property gets the custom zoom levels from the zoomLevelSet.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel01">
            <summary>This property gets the ZoomLevel for Level01.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level01.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel02">
            <summary>This property gets the ZoomLevel for Level02.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level02.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel03">
            <summary>This property gets the ZoomLevel for Level03.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level03.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel04">
            <summary>This property gets the ZoomLevel for Level04.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level04.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel05">
            <summary>This property gets the ZoomLevel for Level05.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level05.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel06">
            <summary>This property gets the ZoomLevel for Level06.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level06.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel07">
            <summary>This property gets the ZoomLevel for Level07.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level07.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel08">
            <summary>This property gets the ZoomLevel for Level08.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level08.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel09">
            <summary>This property gets the ZoomLevel for Level09.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level09.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel10">
            <summary>This property gets the ZoomLevel for Level10.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level10.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel11">
            <summary>This property gets the ZoomLevel for Level11.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level11.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel12">
            <summary>This property gets the ZoomLevel for Level12.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level12.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel13">
            <summary>This property gets the ZoomLevel for Level13.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level13.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel14">
            <summary>This property gets the ZoomLevel for Level14.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level14.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel15">
            <summary>This property gets the ZoomLevel for Level15.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level15.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel16">
            <summary>This property gets the ZoomLevel for Level16.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level16.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel17">
            <summary>This property gets the ZoomLevel for Level17.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level17.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel18">
            <summary>This property gets the ZoomLevel for Level18.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level18.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel19">
            <summary>This property gets the ZoomLevel for Level19.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level19.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ZoomLevelSet.ZoomLevel20">
            <summary>This property gets the ZoomLevel for Level20.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level20.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetZoomLevel(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the map in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetZoomLevel(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,ThinkGeo.MapSuite.GeographyUnit,System.Single)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the map in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
            <param name="dpi">This parameter is the dpi of the extent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetZoomLevelForDrawing(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,ThinkGeo.MapSuite.GeographyUnit,System.Single)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a canvas
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, map unit and a canvas
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the canvas in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
            <param name="dpi">This parameter is the dpi of the extent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetZoomLevelForDrawing(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a canvas
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, map unit and a canvas
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the canvas in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetZoomLevels">
            <summary>This method return all of the zoomLevels in the zoomLevelSet.</summary>
            <returns>This method return all of the zoomlevels in the zoomLevelSet.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetLowerZoomLevelScale(System.Double,ThinkGeo.MapSuite.Layers.ZoomLevelSet)">
            <summary>
            ZoomToScale in, the result is less than input
            </summary>
            <param name="currentScale"></param>
            <param name="zoomLevelSet"></param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ZoomLevelSet.GetHigherZoomLevelScale(System.Double,ThinkGeo.MapSuite.Layers.ZoomLevelSet)">
            <summary>
            ZoomToScale out, the result is greater than input
            </summary>
            <param name="currentScale"></param>
            <param name="zoomLevelSet"></param>
            <returns></returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer">
            <summary>
            This layer is backed by memory and is typically used for temporary
            features.
            </summary>
            <remarks>
            This layer is backed by memory and is typically used for temporary features. You
            can use the MapShapes layer for user-drawn InternalFeatures, InternalFeatures that come from an
            external device such as a GPS unit, or any InternalFeatures that are not saved to disk or
            a database.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to
            specify the FeatureSource column manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to specify the FeatureSource column
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the FeatureSource columns and features for the layer.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="featureSourceColumns">This parameter is the FeatureSourceColumn in this class that you want to use.</param>
            <param name="features">This parameter represents the features in this class that you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the FeatureSource columns and shapes for the layer.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="featureSourceColumns">This parameter is the in this class that you want to use.</param>
            <param name="shapes">This parameter represents the shapes in this class that you want to use.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.Columns">
            <summary>
            This property gets the columns of data for the InternalFeatures in this
            Layer.
            </summary>
            <decimalDegreesValue>This property gets the columns of data for the InternalFeatures in this Layer.</decimalDegreesValue>
            <remarks>
            You should set the column names for the data that the InternalFeatures will hold. For
            example, if you have some features that represent road signs, then one column you may
            want to add is "Sign Type". Then, for every Feature you add to the layer, you need to add
            the "Sign Type" and a value to the InternalFeatures' ColumnValues dictionary. If you provide
            this information, then you can use things like ValueStyles, Labeling, etc. based on the
            columns you have defined.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.InternalFeatures">
            <summary>This property gets the dictionary that holds your InternalFeatures.</summary>
            <decimalDegreesValue>This property gets the dictionary that holds your InternalFeatures.</decimalDegreesValue>
            <remarks>
            The dictionary is a quick way to access your InternalFeatures. You can easily add,
            remove or edit features in this dictionary and they instantly take effect in the layer.
            You can always use the EditTools to do the same thing, but this is a shortcut, as
            the data is backed in memory so it is very pliable.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In InMemoryFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.GetColumns">
            <summary>
            This method returns the columns of data for the InternalFeatures in this
            Layer.
            </summary>
            <decimalDegreesValue>This method returns the columns of data for the InternalFeatures in this Layer.</decimalDegreesValue>
            <remarks>
            You should set the column names for the data that the InternalFeatures will hold. For
            example, if you have some features that represent road signs, then one column you may
            want to add is "Sign Type". Then, for every Feature you add to the layer, you need to add
            the "Sign Type" and a value to the InternalFeatures' ColumnValues dictionary. If you provide
            this information, then you can use things like ValueStyles, Labeling, etc. based on the
            columns you have defined.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The open
            method plays an important role, as it is responsible for initializing the Layer. Most
            methods on the Layer will throw an exception if the state of the Layer is not opened.
            When the map draws each layer, the layer will be opened as one of its first steps; then, after it
            is finished drawing with that layer, it will close it. In this way, we are sure to
            release all resources used by the Layer.<br/>
            	<br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.BuildIndex">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayer.Clear">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If you attempt to call this method on a feature source which is in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If you attempt to call this method on a feature source which is not opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method will clear all the features included in the feature source.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayerExceptionDescription">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayerExceptionDescription.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayerExceptionDescription.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayerExceptionDescription.AddTransactionError">
            <summary>
              Looks up a localized string similar to The add transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayerExceptionDescription.DeleteTransactionError">
            <summary>
              Looks up a localized string similar to The delete transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureLayerExceptionDescription.UpdateTansactionError">
            <summary>
              Looks up a localized string similar to The update transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource">
            <summary>
            This class represents a FeatureSource backed by memory, more specifically an in
            memory collection InternalFeatures.
            </summary>
            <remarks>
            You can use this kind of FeatureSource when your InternalFeatures come from an external
            source which there is no FeatureSource specifically designed for it. An exmaple may be
            real time GPS locations. Another example might be location that a user selected by
            clicking on the screen.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn})">
            <summary>
            Create a new instance of the InMemoryFeatureSource class.
            </summary>
            <remarks>By calling this API to create a new instance of InMemoryFeatureSource, there will
            have no features in the created featureSource. After this, you can added the feature to the
            instance , and another even better opion is call another overloads constructor by passing
            the features too.</remarks>
            <param name="featureSourceColumns">The featuresSourceColumns to instance the InMemoryFeatureSource.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            Create a new instance of the InMemoryFeatureSource class by passing a featureSourceColumns and an initial features.
            </summary>
            <param name="featureSourceColumns">The featuresSourceColumns to instance the InMemoryFeatureSource.</param>
            <param name="features">The features to instance the InMemoryFeatureSource.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape})">
            <summary>
            Create a new instance of the InMemoryFeatureSource class by passing a featureSourceColumns and an initial shapes to construct the shapes.
            </summary>
            <param name="featureSourceColumns">The featuresSourceColumns to instance the InMemoryFeatureSource.</param>
            <param name="shapes">The shapes to contruct the features used to instance the InMemoryFeatureSource.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.Columns">
            <summary>
            This property gets the columns of data for the InternalFeatures in this
            Layer.
            </summary>
            <decimalDegreesValue>This property gets the columns of data for the InternalFeatures in this Layer.</decimalDegreesValue>
            <remarks>
            You should set the column names for the data that the InternalFeatures will hold. For
            example, if you have some features that represent road signs, then one column you may
            want to add is "Sign Type". Then, for every Feature you add to the layer, you need to add
            the "Sign Type" and a value to the InternalFeatures' ColumnValues dictionary. If you provide
            this information, then you can use things like ValueStyles, Labeling, etc. based on the
            columns you have defined.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.InternalFeatures">
            <summary>This property returns the underlying InternalFeatures stored in memory.</summary>
            <decimalDegreesValue>This property returns the underlying InternalFeatures stored in memory.</decimalDegreesValue>
            <remarks>
            This property allows you to modify and inspect the InternalFeatures held by this
            FeatureSource in memory. You can use this as a quick way to add, update or remove
            InternalFeatures.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.BuildIndex">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.Clear">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If you attempt to call this method on a feature source which is in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If you attempt to call this method on a feature source which is not opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method will clear all the features included in the feature source.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data that you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live,
            this method will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.InMemoryFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            When overriding you will be responsible for getting a list of all of the columns
            supported by the FeatureSource. In this way the FeatureSource will know what columns
            are available and will remove any extra columns when making calls to other core
            methods. For example if you have a FeatureSource that has three columns of information
            and the user calls a method and requests four columns of information, something they
            can do with custom fields, we will first compare what they are asking for to the
            results of the GetColumnsCore. In this way we can strip out custom columns before
            calling other Core methods which are only responsible for returning data in the
            FeatureSource. For more information on custom fields you can see the documentation on
            the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas">
            <summary>
            This class represents a canvas that is used to draw geographic shapes with GDI+.
            </summary>
            <remarks>
            	<para>This class allows you to use GDI+ drawing to render your features.<br/>
            		<br/>
                The basic flow of the use of the class is to first call BeginDrawing and pass
                in a image along with its world extent.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.#ctor">
            <remarks>None</remarks>
            <summary>This method is the default constructor for the GdiPlusGeoCanvas.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.CompositingQuality">
            <summary>This property returns or sets the quality level to use during compositing.</summary>
            <remarks>
            	<para>This property is used for GDI+ drawing. The excerpt below is from the GDI+
                documentation:<br/>
                <br/>
                Compositing is done during rendering when the source pixels are
                combined with the destination pixels to produce the resultant pixels. The quality
                of compositing directly relates to the visual quality of the output and is
                inversely proportional to the render time. The higher the quality, the slower the
                render time. This is because the higher the quality level, the more surrounding
                pixels need to be taken into account during the composite. The linear quality
                setting (AssumeLinear) compromises by providing better quality than the default
                quality at a slightly lower speed.</para>
            </remarks>
            <decimalDegreesValue>This property returns the quality level to use during compositing.</decimalDegreesValue>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a CompositingQuality that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.SmoothingMode">
            <summary>This property returns or sets the rendering quality for this GeoCanvas.</summary>
            <decimalDegreesValue>This property returns the rendering quality for this GeoCanvas.</decimalDegreesValue>
            <remarks>
            	<para>This property is used for GDI+ drawing. The excerpt below is from the GDI+
                documentation:<br/>
            		<br/>
            		<br/>
                The smoothing mode specifies whether lines, curves, and the edges of filled areas
                use smoothing (also called antialiasing). One exception is that path gradient
                brushes do not obey the smoothing mode. Areas filled using a PathGradientBrush are
                rendered the same way (aliased) regardless of the SmoothingMode property.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a SmoothingMode that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.HasKeyColor">
            <summary>
            This property indicates whether a GdiPlusGeoCanvas has the KeyColor or not. If it has no
            KeyColor, it will throw an exception when you get or set the value of KeyColors property.
            </summary>
            <remarks>The default value is true.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.InterpolationMode">
            <summary>
                Gets or sets the interpolation mode associated with this System.Drawing.Graphics.
            </summary>
            <value>One of the System.Drawing.Drawing2D.InterpolationMode values.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.TextRenderingHint">
            <remarks>
            	<para>This property is used for GDI+ drawing. The excerpt below is from the GDI+
                documentation:<br/>
            		<br/>
                The text rendering hint specifies whether text renders with antialiasing.</para>
            </remarks>
            <summary>
            This property returns or sets the rendering mode for text associated with this
            GeoCanvas.
            </summary>
            <decimalDegreesValue>
            This property returns the rendering mode for text associated with this
            GeoCanvas.
            </decimalDegreesValue>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a TextRenderHint that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.ClearCore(ThinkGeo.MapSuite.Drawing.GeoBrush)">
            <summary>
            This method clears the native images with a specified brush.
            </summary>
            <param name="fillBrush">The brush to clear the native image.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.DrawAreaCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF[]},ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This method draws the area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter is the area point in screen coordinates.</param>
            <param name="outlinePen">This parameter describes the outline GeoPen that will be used to draw the area.</param>
            <param name="fillBrush">This parameter describes the GeoBrush that will be used to draw the area.</param>
            <param name="xOffset"> This parameter determines the X offset for the area to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the area to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines pen and brush drawing order.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.DrawLineCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single)">
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <summary>Draws a LineShape on the GeoCanvas.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter represents the line points in screen coordinates.</param>
            <param name="linePen">
            This parameter describes the GeoPen that will be used to draw the
            LineShape.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the line to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the line to be drawn.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.DrawEllipseCore(ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>Draws the point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="screenPoint">This parameter is the point in screen coordinates.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset of the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset of the ellipse to be drawn.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines pen and brush drawing order.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.DrawScreenImageWithoutScalingCore(ThinkGeo.MapSuite.Drawing.GeoImage,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.DrawScreenImageCore(ThinkGeo.MapSuite.Drawing.GeoImage,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a scaled image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width at which the image will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height at which the image will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.DrawTextCore(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.GeoPen,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingTextAlignment)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string as the text parameter, we will throw an ArgumentException.</exception>
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
            <param name="haloPen"> This parameter specifies the HaloPen that will be used to draw the text, when the HaloPen effect is needed.</param>
            <param name="xOffset"> This parameter determines the X offset for the text to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the text to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the text to be drawn.</param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.MeasureTextCore(System.String,ThinkGeo.MapSuite.Drawing.GeoFont)">
            <summary>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </summary>
            <remarks>This method is typically used for labeling, to determine whether labels overlap.</remarks>
            <returns>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </returns>
            <param name="text">This parameter represents the text you want to measure.</param>
            <param name="font">This parameter represents the font of the text you want to measure.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string as the text parameter, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.BeginDrawingCore(System.Object,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.GeographyUnit)">
            <remarks>
            This is the first method that needs to be called before any drawing takes place.
            Calling this method will set the IsDrawing property to true. When you finish drawing,
            you must call EndDrawing to commit the changes to the image.
            </remarks>
            <summary>This method begins the act of drawing on the GeoCanvas.</summary>
            <param name="nativeImage">This parameter represents the image you want the GeoCanvas to draw on.</param>
            <param name="worldExtent">This parameter is the world extent of the canvasImage.</param>
            <param name="drawingMapUnit">This parameter is the map unit of the canvasImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.EndDrawingCore">
            <summary>This method ends drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.FlushCore">
            <summary>This method flush drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.ToNativeImageCore(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>This method returns a native image object from the specified GeoCanvas.</summary>
            <returns>This method returns a native image object from the specified GeoCanvas.</returns>
            <remarks>
            It is faster to provide a native image object to the canvas for drawing. In some
            cases, you may not know what the native image type is. For example, for GDI+ it is a
            bitmap class, but in GDI it may be a handled to an HBitmap. If you are not sure how to
            create the native image object, you should first create a GeoImage and then call this
            method and it will pass back the native image object. You can then use it to get
            excellent drawing performance on the GeoCanvas.
            </remarks>
            <param name="image">This parameter is the GeoCanvas you want to convert to a native image.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.ToGeoImageCore(System.Object)">
            <summary>This method returns a GeoImage from a native image object.</summary>
            <returns>This method returns a GeoImage from a native image object.</returns>
            <remarks>
            This method will allows you to convert your native image object to a GeoImage.
            Many times, when you work with a GeoCanvas, you may not know the format of the native
            image. Using this method you can always convert it back to a GeoImage, which is a stream
            of a TIFF.
            </remarks>
            <param name="nativeImage">
            This parameter is the native image object you want to convert to a
            GeoImage.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.GetStreamFromGeoImage(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>This method returns a stream that represents the GeoImage in TIFF format.</summary>
            <returns>This method returns a stream that represents the GeoImage in TIFF format.</returns>
            <remarks>
            This method allows you to get the stream out of a GeoImage. The stream is a
            memory stream and the bytes are in TIFF format. Once you have the stream, you can then save it to
            whatever format you need.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to convert to a stream.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.FillBackground(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Drawing.GeoBrush)">
            <summary>This method fills the specified GeoImage with the specified GeoBrush.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to fill a GeoImage with the specific fill style of the GeoBrush you
            pass in. It is useful for setting backgrounds.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to set the background on.</param>
            <param name="brush">This parameter is the GeoBrush you want to fill the background with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.ConvertGeoImageToMemoryStream(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>This method converts a GeoImage to a memory stream.</summary>
            <overloads>This overload saves the bytes to the memory stream in TIFF format.</overloads>
            <returns>This method converts a GeoImage to a memory stream.</returns>
            <remarks>
            This method is used to get a TIFF memory stream from a GeoImage using the
            canvas-specific methods. If you need to get a format other than TIFF, you can
            use the other overload which allows you to specify the output format.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to convert to a stream.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.ConvertGeoImageToMemoryStream(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Drawing.GeoImageFormat)">
            <summary>This method converts a GeoImage to a memory stream.</summary>
            <overloads>
            This overload saves the bytes to the memory stream in the format you
            specify.
            </overloads>
            <returns>
            The return is a memory stream with the bytes formatted according to the image format
            you specify.
            </returns>
            <remarks>
            This method allows you to save the GeoImage to any format you specify. This
            allows you to convert it to a PNG, or a variety of other formats, and then save it to
            disk.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to convert to a memory stream.</param>
            <param name="imageFormat">This parameter is the image format you want the stream to be in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.GetCanvasWidthCore(System.Object)">
            <summary>
            This method gets the canvas width of the specified native image object.
            </summary>
            <param name="nativeImage">The native image will be used to get the canvas width.</param>
            <returns>The returning canvas width.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvas.GetCanvasHeightCore(System.Object)">
            <summary>
            This method gets the canvas height of the specified native image object.
            </summary>
            <param name="nativeImage">The native image will be used to get the canvas height.</param>
            <returns>The returning canvas height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.PlatformGeoCanvasHelper.GetGdiBrushFromGeoTextureBrush(ThinkGeo.MapSuite.Drawing.GeoTextureBrush,System.Boolean)">
            <summary>
            </summary>
            <param name="brush"></param>
            <param name="ignoreDrawingRectangleF">
            GeoTextureBrush allow DrawingRectangleF as negative values, but GdiPlus TextureBrush doesn't.
            In PrinterGeoCanva we have sceniaro of negative DrawingRectangleF.
            Ao using ignoreDrawingRectangleF for printerGeoCanvas only, that we can keep compatable with old code
            </param>
            <returns></returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoBrush">
            <summary>
            Defines objects used to fill the interiors of AreaBaseShapes, such as
            MultiPolygonShape, PolygonShape, EllipseShape, and other AreaBaseShapes.
            </summary>
            <remarks>
            	<para>This is an abstract base class and cannot be instantiated. To create a
                GeoBrush object, use classes derived from GeoBrush, such as GeoSolidBrush.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoBrush.#ctor">
            <summary>This is the constructor for the GeoBrush</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoBrush.Id">
            <summary>
            The id of the GeoBrush. This is always used as a key when in the cached brushes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoBrush.CloneDeep">
            <summary>Create a copy of GeoBrush using the deep clone process.</summary>
            <returns>A cloned GeoBrush.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoBrush.CloneDeepCore">
            <summary>Create a copy of GeoBrush using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoBrush.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoCanvas">
            <summary>
            This class represents a canvas that is used to draw geographic shapes. It is
            intended to be inherited for the implementation of different drawing systems, such as GDI+ or
            WPF.
            </summary>
            <remarks>
            	<para>This class allows you to implement different drawing systems, such as GDI+,
                GDI, or WPF. It can also be used for other systems, such as PDF.<br/>
            		<br/>
                The basic flow of the use of the class is to first call BeginDrawing and pass
                in an image along with its world extent.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.#ctor">
            <summary>This method is the default constructor for the GeoCanvas.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.CurrentScale">
            <summary>
            This property gets the current scale of the canvas.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this property when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.FontDisplayDensity">
            <summary>
            This property gets and sets the current device pixel ratio of platform. It would be used by scale text and icon from map.
            Android: it's "Application.Context.Resources.DisplayMetrics.Density".
            iOS: it's "UIScreen.MainScreen.Scale".
            Others: it's default value "1".
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.CloneDeep">
            <summary>Create a copy of GeoCanvas using the deep clone process.</summary>
            <returns>A cloned GeoCanvas.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.CloneDeepCore">
            <summary>Create a copy of GeoCanvas using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoCanvas.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.Clear(ThinkGeo.MapSuite.Drawing.GeoBrush)">
            <summary>This method clears the current GeoCanvas using the color specified.</summary>
            <remarks>Use this method to clear the GeoCanvas.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.ClearCore(ThinkGeo.MapSuite.Drawing.GeoBrush)">
            <summary>This method clears the current GeoCanvas using the color specified.</summary>
            <remarks>
            	<para>Use this method to clear the GeoCanvas.</para>
            	<para>This method is designed to be overridden by the deriving class.</para>
            </remarks>
            <param name="fillBrush">This parameter specifies the the brush that will be used to clear the GeoCanvas.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the area feature.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            area.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.AreaBaseShape,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the area shape.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            area.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="feature">This parameter is the AreaShape in well-known binary format.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.AreaBaseShape,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="shape">This parameter is the area shape to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill Brush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="feature">This parameter is the AreaFeature to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.AreaBaseShape,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="shape">This parameter is the area shape to be drawn.</param>
            <param name="outlinePen">This parameter describes the outline pen that will be used to draw the AreaShape.</param>
            <param name="fillBrush">
            This parameter describes the fill Brush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="feature">This parameter is the AreaFeature to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature that will be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature that will be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushingDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Shapes.AreaBaseShape,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="shape">This parameter is the area shape to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawArea(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF[]},ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="screenPoints">This parameter is the AreaShape in well-known binary format.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawAreaCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF[]},ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="screenPoints">This parameter is the AreaShape in well-known binary format.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the line feature.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Shapes.LineBaseShape,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the line shape to be drawn by GeoCannvas.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the line feature to be drawn by GeoCannvas.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Shapes.LineBaseShape,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the line shape to be drawn by GeoCannvas.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawLine(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single)">
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <summary>Draws the LineShape on the GeoCanvas.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter is the LineShape in well-known binary format.</param>
            <param name="linePen">
            This parameter describes the GeoPen that will be used to draw the
            LineShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawLineCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single)">
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <summary>Draws the LineShape on the GeoCanvas.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter is the LineShape in well-known binary format.</param>
            <param name="linePen">
            This parameter describes the GeoPen that will be used to draw the
            LineShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>Draws a point on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>Draws a point on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="centerPointFeature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the the GeoBrush will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the the GeoBrush will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder"> This parameter determines the PenBrushDrawingOrder used when drawing the ellipse.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder"> This parameter determines the PenBrushDrawingOrder used when drawing the ellipse.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoint">This parameter is the center point in screen coordinate.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder"> </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawEllipseCore(ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoint">This parameter is the center point in well-known binary format.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the screenPoint to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the screenPoint to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the ellipse.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawWorldImageWithoutScaling(ThinkGeo.MapSuite.Drawing.GeoImage,System.Double,System.Double,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>
            	<para>Drawing an image unscaled is faster than using the API that scales it.</para>
            	<para>The X &amp; Y in work coordinates is where the center of the image will be
                drawn.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawWorldImageWithoutScaling(ThinkGeo.MapSuite.Drawing.GeoImage,System.Double,System.Double,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>
            	<para>Drawing an image unscaled is faster than using the API that scales it.</para>
            	<para>The X &amp; Y in work coordinates is where the center of the image will be
                drawn.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInWorld">The X coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawScreenImageWithoutScaling(ThinkGeo.MapSuite.Drawing.GeoImage,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>
            	<para>Drawing an image unscaled is faster than using the API that scales it.</para>
            	<para>The X &amp; Y in work coordinates is where the center of the image will be
                drawn.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawScreenImageWithoutScalingCore(ThinkGeo.MapSuite.Drawing.GeoImage,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawWorldImage(ThinkGeo.MapSuite.Drawing.GeoImage,System.Double,System.Double,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>Draws a scaled image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawWorldImage(ThinkGeo.MapSuite.Drawing.GeoImage,System.Double,System.Double,System.Double,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a world image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="imageScale">
            The scale at which you want to draw the image. The final width and height will be caculated based on the scale.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawWorldImage(ThinkGeo.MapSuite.Drawing.GeoImage,System.Double,System.Double,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a world image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawScreenImage(ThinkGeo.MapSuite.Drawing.GeoImage,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a screen image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawScreenImageCore(ThinkGeo.MapSuite.Drawing.GeoImage,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a scaled image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawTextWithScreenCoordinate(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoBrush,System.Single,System.Single,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
            <overloads>This overload allows you to specify the location in screen coordinates.</overloads>
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas at specific screen coordinates. It
                provides you with a number of overloads that allow you to control how the text is drawn. This is
                useful especially when adding things such as legends, titles, etc.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="upperLeftXInScreen">
            This parameter is the upper left horizontal point in screen coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="upperLeftYInScreen">
            This parameter is the upper left vertical point in screen coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawTextWithWorldCoordinate(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoBrush,System.Double,System.Double,ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
            <overloads>This overload allows you to specify the location in world coordinates.</overloads>
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas at specific screen coordinates. It
                provides you with a number of overloads that allow you to control how the text is drawn. This is
                useful especially when adding things such as legends, titles, etc.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="upperLeftXInWorld">
            This parameter is the upper left horizontal point in world coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="upperLeftYInWorld">
            This parameter is the upper left horizontal point in world coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawText(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoBrush,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.DrawingLevel)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawText(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.GeoPen,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="haloPen"> This parameter specifies the HaloPen that will be used to draw the text, when the HaloPen effect is needed.</param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the text to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the text to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the text to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawTextCore(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoBrush,ThinkGeo.MapSuite.Drawing.GeoPen,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.ScreenPointF},ThinkGeo.MapSuite.Drawing.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush"> This parameter specifies the kind of fill you want to use to draw the text.</param>
            <param name="haloPen"> This parameter specifies the HaloPen that will be used to draw the text, when the HaloPen effect is needed.</param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the text to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the text to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the text to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.MeasureText(System.String,ThinkGeo.MapSuite.Drawing.GeoFont)">
            <summary>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </summary>
            <returns>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </returns>
            <remarks>This method is typically used for labeling, to determine whether labels overlap.</remarks>
            <param name="text">This parameter represents the text you want to measure.</param>
            <param name="font">This parameter represents the font of the text you want to measure.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.MeasureTextCore(System.String,ThinkGeo.MapSuite.Drawing.GeoFont)">
            <summary>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </summary>
            <remarks>This method is typically used for labeling, to determine whether labels overlap.</remarks>
            <returns>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </returns>
            <param name="text">This parameter represents the text you want to measure.</param>
            <param name="font">This parameter represents the font of the text you want to measure.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.BeginDrawing(System.Object,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>This method begins the act of drawing on the GeoCanvas.</summary>
            <remarks>
            This is the first method that needs to be called before any drawing takes place.
            Calling this method will set the IsDrawing property to true. When you finish drawing,
            you must call EndDrawing to commit the changes to the image.
            </remarks>
            <param name="nativeImage">This parameter represents the image you want the GeoCanvas to draw on.</param>
            <param name="worldExtent">This parameter is the world extent of the canvasImage.</param>
            <param name="drawingMapUnit">This parameter is the map unit of the canvasImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.BeginDrawingCore(System.Object,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.GeographyUnit)">
            <remarks>
            This is the first method that needs to be called before any drawing takes place.
            Calling this method will set the IsDrawing property to true. When you finish drawing,
            you must call EndDrawing to commit the changes to the image.
            </remarks>
            <summary>This method begins the act of drawing on the GeoCanvas.</summary>
            <param name="nativeImage">This parameter represents the image you want the GeoCanvas to draw on.</param>
            <param name="worldExtent">This parameter is the world extent of the canvasImage.</param>
            <param name="drawingMapUnit">This parameter is the map unit of the canvasImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.ToNativeImage(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>
            This method converts a GeoImage to a commonly-used object. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="image">The target geoImage to convert.</param>
            <returns>The returning object containing the same information as the passed-in geoImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.ToNativeImageCore(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>
            This method converts a GeoImage to a commonly-used object. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be used in its sub-concrete classes.
            </remarks>
            <param name="image">The target geoImage to convert.</param>
            <returns>The returning object containing the same information as the passed-in geoImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.ToGeoImage(System.Object)">
            <summary>
            This method converts an oboject to a GeoImage. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The target object to be converted.</param>
            <returns>The returning GeoImage containing the same information as the passed-in nativeImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.ToGeoImageCore(System.Object)">
            <summary>
            This method converts an oboject to a GeoImage. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The target object to be converted.</param>
            <returns>The returning GeoImage containing the same information as the passed-in nativeImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.EndDrawing">
            <summary>This method ends drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.GetCanvasWidth(System.Object)">
            <summary>
            This method gets the canvas width of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image that will be used to get the image width.</param>
            <returns>The returning canvas width.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.GetCanvasWidthCore(System.Object)">
            <summary>
            This method gets the canvas width of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image that will be used to get the image width.</param>
            <returns>The returning canvas width.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.GetCanvasHeight(System.Object)">
            <summary>
            This method gets the canvas height of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image that will be used to get the image height.</param>
            <returns>The returning canvas height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.GetCanvasHeightCore(System.Object)">
            <summary>
            This method gets the canvas height of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image will be used to get the image height.</param>
            <returns>The returning canvas height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.EndDrawingCore">
            <summary>This method ends drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This methods should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.GetStreamFromGeoImage(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>
            Get the stream from the passed-in GeoImage.  This API is an abstract API and will be implemented in each concrete sub-class.
            </summary>
            <param name="image">The parameter specifies the image to get the stream from.</param>
            <returns>The returning stream retrieved from the passed-in image.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.DrawingQuality">
            <summary>This property returns the drawing quality when rendering on the GeoCanvas.</summary>
            <remarks>
            The DrawingQuality specifies whether BaseLineShapes, BasePointShapes, and
            BaseAreaShapes use anti-aliasing methods or other techniques that control the quality. In
            some cases you may want a higher quality rendering, and in other cases higher speed is
            more desirable. It is up to the implementer of the derived GeoCanvas class to control
            exactly what this setting means.
            </remarks>
            <decimalDegreesValue>This property returns the drawing quality that will be used when rendering on the GeoCanvas.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.MapUnit">
            <summary>This property returns the MapUnit passed in on the BeginDrawingAPI in the GeoCanvas.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.Width">
            <summary>This property gets the width of the canvas.</summary>
            <decimalDegreesValue>This property gets the width of the canvas.</decimalDegreesValue>
            <remarks>
            This property reflects the width of the canvas image that was passed in on
            BeginDrawing.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.Height">
            <summary>This property gets the height of the canvas.</summary>
            <decimalDegreesValue>This property gets the height of the canvas.</decimalDegreesValue>
            <remarks>
            This property reflects the height of the canvas image that was passed in on
            BeginDrawing.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.CurrentWorldExtent">
            <summary>
            This property gets the adjusted current extent based on what was set when
            BeginDrawing was called.
            </summary>
            <remarks>
            The extent that gets passed in on BeginDrawing is adjusted for the height and
            width of the physical media being drawn on. For example if the current extent is wider
            than taller but the bitmap being drawn on is square then the current extent needs to be
            adjusted. The extent will be adjusted larger so that we ensure that the entire original
            extent will still be represented.
            </remarks>
            <decimalDegreesValue>
            This property gets the adjusted current extent based on what was set when
            BeginDrawing was called.
            </decimalDegreesValue>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.HasKeyColor">
            <summary>
            This property indicates whether a GeoCanvas has the KeyColor or not. If it has no
            KeyColor, it will throw an exception when you get or set the value of KeyColors property.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.KeyColors">
            <summary>
            Gets a value represents a collection of key colors. If HasKeyColor property is false, it will throw exception when you use KeyColors.
            </summary>
            <remarks>It will make these colors transparent when draw image.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.NativeImage">
            <summary>
            The same reference to the parameter 'nativeImage' in BeginDrawing function.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.IsDrawing">
            <summary>This property gets the drawing status of the GeoCanvas.</summary>
            <decimalDegreesValue>This property gets the drawing status of the GeoCanvas.</decimalDegreesValue>
            <remarks>
            This property is set to true when the BeginDrawing method is called, and
            false after the EndDrawing method is called.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.Dpi">
            <summary>
            The DPI value for the final drawing result, only valid when HasDpi set to true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoCanvas.ScaleFactor">
            <summary>
            Gets or sets the scale factor, this is a value number of device pixels per logical coordinate point.
            </summary>
            <remarks>
            The coordinate space used by application developers is measured in logical points. High-resolution (Retina) 
            displays will have more than a single physical pixel per logical point and this property specifies the 
            scale factor.
            </remarks>
            <value>
            The scale factory value.
            </value>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.Flush">
            <summary>This method flush drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoCanvas.FlushCore">
            <summary>This method flush drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoFont">
            <summary>
            This class represents a font that is used to label features on a
            GeoCanvas.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoFont.#ctor">
            <overloads>This overload creates the GeoFont using its default property values.</overloads>
            <remarks>None</remarks>
            <summary>
            This constructor creates a GeoFont to be used for labeling features on a
            GeoCanvas.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoFont.#ctor(System.String,System.Single)">
            <summary>
            This constructor creates a GeoFont to be used for labeling features on a
            GeoCanvas.
            </summary>
            <overloads>
            This overload creates the GeoFont by specifying the font name and font
            size.
            </overloads>
            <remarks>None</remarks>
            <param name="fontName">This parameter represents the name of the font to be used.</param>
            <param name="size">This parameter represents the size of the font to be used.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null or empty string as the fontName, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a size value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoFont.#ctor(System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles)">
            <summary>
            This constructor creates a GeoFont to be used for labeling features on a
            GeoCanvas.
            </summary>
            <overloads>
            This overload creates the GeoFont by specifying the font name, font size and font
            style.
            </overloads>
            <remarks>None</remarks>
            <param name="fontName">This parameter represents the name of the font to be used.</param>
            <param name="size">This parameter represents the size of the font to be used.</param>
            <param name="style">This parameter represents the style of the font to be used.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null or empty string as the fontName, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a size value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a style that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.IsBold">
            <summary>This property gets the bold property of the font.</summary>
            <value>This property gets the bold property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.IsStrikeout">
            <summary>This property gets the strikeout property of the font.</summary>
            <value>This property gets the strikeout property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.IsItalic">
            <summary>This property gets the italic property of the font.</summary>
            <value>This property gets the italic property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.IsUnderline">
            <summary>This property gets the underline property of the font.</summary>
            <value>This property gets the underline property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.FontName">
            <summary>This property gets the font name property of the font.</summary>
            <value>This property gets the font name property of the font.</value>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null or empty string as the FontName, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.Size">
            <summary>This property gets the font size property of the font.</summary>
            <value>This property gets the font size property of the font.</value>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a size value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoFont.Style">
            <summary>This property gets the font style property of the font.</summary>
            <value>This property gets the font style property of the font.</value>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a Style that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoPen">
            <summary>This class represents a GeoPen, which is used to draw lines on a GeoCanvas.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.#ctor">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen with its default values.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.#ctor(ThinkGeo.MapSuite.Drawing.GeoBrush)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoBrush.</overloads>
            <remarks>None</remarks>
            <param name="brush">This parameter represents the brush that will be used to draw the line.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the brush, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.#ctor(ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoColor.</overloads>
            <remarks>None</remarks>
            <param name="color">This parameter represents the color that will be used to draw the line.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the color, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.#ctor(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoColor and a line width.</overloads>
            <remarks>None</remarks>
            <param name="color">This parameter represents the color that will be used to draw the line.</param>
            <param name="width">This parameter represents the width of the line.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a width value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.#ctor(ThinkGeo.MapSuite.Drawing.GeoBrush,System.Single)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoBrush and a line width.</overloads>
            <remarks>None</remarks>
            <param name="brush">This parameter represents the brush that will be used to draw the line.</param>
            <param name="width">This parameter represents the width of the line.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the brush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a width value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.SetLineCap(ThinkGeo.MapSuite.Drawing.DrawingLineCap,ThinkGeo.MapSuite.Drawing.DrawingLineCap,ThinkGeo.MapSuite.Drawing.GeoDashCap)">
            <summary>This method allows you to set the start, end and dash caps at one time.</summary>
            <remarks>None</remarks>
            <param name="startCap">This parameter specifies the start cap to be used.</param>
            <param name="endCap">This parameter specifies the end cap to be used.</param>
            <param name="dashCap">This parameter specifies the dash cap to be used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a endCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a dashCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.Brush">
            <summary>This property gets and sets the brush for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the brush for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the brush, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.Color">
            <summary>This property gets and sets the GeoColor for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the GeoColor for this GeoPen.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.DashCap">
            <summary>This property gets and sets the dash cap for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the dash cap for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a DashCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.DashPattern">
            <summary>This property gets the dash pattern for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the dash pattern for this GeoPen.</decimalDegreesValue>
            <remarks>Assigning a value other than null (Nothing in Visual Basic) to this property will set the DashStyle property for this GeoPen to Custom.
            The elements in the dashArray array set the length of each dash and space in the dash pattern. The first element sets the length of a dash, the second element sets the length of a space, the third element sets the length of a dash, and so on.
            The length of each dash and space in the dash pattern is the product of the element value in the array and the width of the GeoPen.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the DashPattern, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.DashStyle">
            <summary>This property gets and sets the dash style for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the dash style for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a DashStyle that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.EndCap">
            <summary>This property gets and sets the end cap for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the end cap for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a EndCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.LineJoin">
            <summary>This property gets and sets the line join for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the line join for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a LineJoin that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.MiterLimit">
            <summary>This property gets and sets the miter limit for this GeoPen.</summary>
            <decimalDegreesValue>This property gets set the miter limit for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.StartCap">
            <summary>This property gets and sets the start cap for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the start cap for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a StartCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.Width">
            <summary>This property gets and sets the width for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the width for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a width value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoPen.Id">
            <summary>
            The id of the GeoBrush. This is always used as a key when in the cached brushes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.CloneDeep">
            <summary>Create a copy of GeoPen using the deep clone process.</summary>
            <returns>A cloned GeoPen.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoPen.CloneDeepCore">
            <summary>Create a copy of GeoPen using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoPen.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingFontStyles">
            <summary>This enumeration specifies the type of font style for drawing text.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingFontStyles.Regular">
            <summary>This member represents standard text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingFontStyles.Bold">
            <summary>This member represents bold text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingFontStyles.Italic">
            <summary>This member represents italic text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingFontStyles.Underline">
            <summary>This member represents underlined text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingFontStyles.Strikeout">
            <summary>This member represents strikeout text.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingGraphicsUnit">
            <summary>This enumeration represents the graphics unit.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingLevel">
            <summary>This enumeration represents the drawing level used in the GeoCanvas.</summary>
            <remarks>
            This enumeration is used to control the drawing level. If you draw an item on the first
            level and another item on the second level, the second level item will occlude the first. In this way,
            you can layer various drawing symbols to get unique effects. For example, you can create
            a road by first drawing a wide black line on level one, followed by a thinner white line on
            level two. The white line will draw on top of the black line and create the illusion
            of an outlined road. Adding a centered dashed line on level three will create a
            centerline.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLevel.LevelOne">
            <summary>The first drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLevel.LevelTwo">
            <summary>The second drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLevel.LevelThree">
            <summary>The third drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLevel.LevelFour">
            <summary>The fourth drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLevel.LabelLevel">
            <summary>The level for label drawing</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingLineCap">
            <summary>
            	<para>This enumeration represents the available cap styles with which a GeoPen
                object can end a line.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.Round">
            <summary>This member specifies a round line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.AnchorMask">
            <summary>
            This member specifies a mask used to check whether a line cap is an anchor
            cap.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.ArrowAnchor">
            <summary>This member specifies an arrow-shaped anchor cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.Custom">
            <summary>This member specifies a custom line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.DiamondAnchor">
            <summary>This member specifies a diamond anchor cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.Flat">
            <summary>This member specifies a flat line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.NoAnchor">
            <summary>This member specifies no anchor.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.RoundAnchor">
            <summary>This member specifies a round anchor cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.Square">
            <summary>This member specifies a square line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.SquareAnchor">
            <summary>This member specifies a square anchor line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineCap.Triangle">
            <summary>This member specifies a triangular line cap.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingLineJoin">
            <remarks>None</remarks>
            <summary>
            	<para>This enumeration specifies how to join consecutive line or curve
                segments.</para>
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineJoin.Bevel">
            <summary>Specifies a beveled join. This produces a diagonal corner.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineJoin.Miter">
            <summary>
            Specifies a mitered join. This produces a sharp corner or a clipped corner,
            depending on whether the length of the miter exceeds the miter limit.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineJoin.MiterClipped">
            <summary>
            Specifies a mitered join. This produces a sharp corner or a beveled corner,
            depending on whether the length of the miter exceeds the miter limit.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingLineJoin.Round">
            <summary>
            Specifies a circular join. This produces a smooth, circular arc between the
            lines.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingPenAlignment">
            <summary>
            Specifies the alignment of a GeoPen object in relation to the theoretical,
            zero-width line.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingPenAlignment.Center">
            <summary>Specifies that the GeoPen object is centered over the theoretical line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingPenAlignment.Inset">
            <summary>
            Specifies that the GeoPen is positioned on the inside of the theoretical
            line.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingPenAlignment.Left">
            <summary>Specifies the GeoPen is positioned to the left of the theoretical line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingPenAlignment.Outset">
            <summary>Specifies the GeoPen is positioned on the outside of the theoretical line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingPenAlignment.Right">
            <summary>Specifies the GeoPen is positioned to the right of the theoretical line.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.DrawingQuality">
            <summary>This enumeration specifies the drawing quality of the GeoCanvas.</summary>
            <remarks>
            This enumeration does not specifically utilize high speed or high quality
            drawing. Those factors are determined by the implementor of the GeoCanvas. Each GeoCanvas can
            accomplish these various items in different ways.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingQuality.Default">
            <summary>The default drawing quality, balanced between speed and quality.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingQuality.HighQuality">
            <summary>The high quality (but low speed) drawing quality.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingQuality.HighSpeed">
            <summary>The low quality (but high speed) drawing quality.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingQuality.CanvasSettings">
            <summary>
            This option indicates that you will change the settings directly on the
            canvas.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoBrushes">
            <summary>
            Provides a collection of predefined GeoBrushes
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoColor">
            <summary>This structure represents a color for drawing on a GeoCanvas.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>This constructor creates a new color.</summary>
            <overloads>This constructor allows you to specify the red, green, and blue component.</overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a red value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a green value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a blue value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="red">This parameter specifies the red component of the color.</param>
            <param name="green">This parameter specifies the green component of the color.</param>
            <param name="blue">This parameter specifies the blue component of the color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>This constructor creates a new color.</summary>
            <overloads>
            This constructor allows you to specify the red, green, blue, and alpha
            component.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a red value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a blue value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a green value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a alpha value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="alpha">
            This parameter specifies the alpha, or transparent, component of the
            color.
            </param>
            <param name="red">This parameter specifies the red component of the color.</param>
            <param name="green">This parameter specifies the green component of the color.</param>
            <param name="blue">This parameter specifies the blue component of the color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.#ctor(System.Int32,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <overloads>This overload creates a transparent version of another color.</overloads>
            <summary>This constructor creates a new color.</summary>
            <returns>None</returns>
            <remarks>
            You can use this overload to create a transparent version of another
            color.
            </remarks>
            <param name="alpha">
            This parameter specifies the alpha component. An alpha of 0 is totally
            transparent.
            </param>
            <param name="color">This parameter specifies the base color.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.IsTransparent">
            <summary>
            Verify if the GeoColor is transparent, it is considered to be transparent if the Alpha Value is 0.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.AlphaComponent">
            <summary>This property returns the alpha component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the alpha component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.RedComponent">
            <summary>This property returns the red component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the red component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.GreenComponent">
            <summary>This property returns the green component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the green component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.BlueComponent">
            <summary>This property returns the blue component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the blue component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.Hue">
            <summary>This property returns the hue component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the hue component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.Saturation">
            <summary>This property returns the saturation component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the saturation component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.Luminance">
            <summary>This property returns the luminance component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the luminance component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.GeographicColors">
            <summary>This method returns a list of commonly-used predefined geographic colors.</summary>
            <decimalDegreesValue>This method returns a list of commonly-used predefined geographic colors.</decimalDegreesValue>
            <remarks>
            You can use these as colors to represent many different types of geographic
            features.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.StandardColors">
            <summary>This method returns a list of commonly-used predefined colors.</summary>
            <decimalDegreesValue>This method returns a list of commonly-used predefined colors.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColor.SimpleColors">
            <summary>This method returns a list of simple predefined colors.</summary>
            <decimalDegreesValue>This method returns a list of simple predefined colors.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.GetColorsInHueFamily(ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>
            This method returns a collection of GeoColors based on the same hue that is
            passed in.
            </summary>
            <remarks>
            This method is useful when you want to get a number of colors that have the same
            hue. For example, you can use this in maps that represent class breaks. If you passed in a red hue,
            then the method would return variations such as light red, dark red, pastel red, etc.
            </remarks>
            <returns>
            This method returns a collection of GeoColors based on the same hue that is
            passed in.
            </returns>
            <param name="baseColor">This parameter is the color on which you want to base the color collection.</param>
            <param name="numbersOfColors">
            This parameter represents the number of colors you want returned from the
            method.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfColors value that is not between 1 and 255, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.GetColorsInQualityFamily(ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>
            This method returns a collection of GeoColors based on the same quality (luminosity and saturation) that is
            passed in.
            </summary>
            <returns>
            This method returns a collection of GeoColors based on the same quality (luminosity and saturation) that is
            passed in.
            </returns>
            <remarks>
            This method is useful when you want to get a number of different colors that have the same
            quality. For example, you can use this in maps that represent countries or connected places. If you
            passed in bright red, then the method would return variants such as bright blue, bright green,
            etc. If you passed in dark red, you would get dark blue, dark green, etc.
            </remarks>
            <param name="baseColor">This parameter is the color on which you want to base the color collection.</param>
            <param name="numberOfColors">
            This parameter represents the number of colors you want returned from the
            method.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfColors value that is not between 1 and 255, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.FromArgb(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This method returns a GeoColor based on the Alpha, Red, Green, and Blue
            components.
            </summary>
            <returns>
            This method returns a GeoColor based on the Alpha, Red, Green, and Blue
            components.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a alpha value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a red value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a green value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a blue value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This overload lets you specify each component.</overloads>
            <param name="alpha">
            This parameter specifies the alpha, or transparent, component of the
            color.
            </param>
            <param name="red">This parameter specifies the red component of the color.</param>
            <param name="green">This parameter specifies the green component of the color.</param>
            <param name="blue">This parameter specifies the blue component of the color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.FromArgb(System.Int32,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>
            This method returns a GeoColor based on the Alpha, Red, Green, and Blue
            components.
            </summary>
            <overloads>This method creates a transparent version of another color.</overloads>
            <returns>
            You can use this overload to create a transparent version of another
            color.
            </returns>
            <param name="alpha">
            This parameter determines how transparent the color is. An alpha of 0 means it is
            totally transparent.
            </param>
            <param name="baseColor">This parameter is the color you want to apply the transparency to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.FromAhsl(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            This parameter specifies the red component of the color. This method returns a
            GeoColor based on the Alpha, Hue, Saturation, and Luminosity components.
            </summary>
            <remarks>None</remarks>
            <param name="alpha">
            This parameter specifies the alpha, or transparent, component of the
            color.
            </param>
            <param name="hue">This parameter specifies the hue component of the color.</param>
            <param name="saturation">This parameter specifies the saturation component of the color.</param>
            <param name="luminance">This parameter specifies the luminance component of the color.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a alpha value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a hue value which is not between 0 and 360, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a saturation value which is not between 0 and 1, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a luminance value which is not between 0 and 1, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.FromOle(System.Int32)">
            <summary>This method returns a GeoColor from an OLE color.</summary>
            <returns>This method returns a GeoColor from an OLE color.</returns>
            <remarks>None</remarks>
            <param name="oleColor">This parameter represents the OLE color you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.FromHtml(System.String)">
            <summary>This method returns a GeoColor from an HTML color (either in hexadecimal or a named color).</summary>
            <returns>This method returns a GeoColor from an HTML color (either in hexadecimal or a named color).</returns>
            <remarks>None</remarks>
            <param name="htmlColor">This parameter represents the HTML color that you want to convert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a htmlColor value which is not valid, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.GetRandomGeoColor(ThinkGeo.MapSuite.Drawing.RandomColorType)">
            <summary>
            Creates a random <strong>GeoColor</strong> structure based on the specific
            ColorType
            </summary>
            <overloads>Creates a GeoColor structure with random color</overloads>
            <param name="colorType">A <strong>ColorType</strong> defines types of color.</param>
            <returns>A <strong>GeoColor</strong> structure the method created.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.GetRandomGeoColor(System.Int32,ThinkGeo.MapSuite.Drawing.RandomColorType)">
            <summary>Creates a random <strong>GeoColor</strong> structure</summary>
            <overloads>Creates a <strong>GeoColor</strong> structure with random color</overloads>
            <returns>A <strong>GeoColor</strong> structure the method created.</returns>
            <param name="alpha"><para>The alpha component. Valid values are 0 through
            255.</para></param>
            <param name="colorType">A <strong>ColorType</strong> defines types of color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.FromWin32(System.Int32)">
            <summary>This method returns a GeoColor from a Win32 color.</summary>
            <returns>This method returns a GeoColor from a Win32 color.</returns>
            <remarks>None</remarks>
            <param name="win32Color">This parameter represents the Win32 color you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.ToOle(ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method returns an OLE color from a GeoColor.</summary>
            <remarks>None</remarks>
            <returns>This method returns an OLE color from a GeoColor.</returns>
            <param name="color">This parameter represents the GeoColor you want to convert.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the drawingColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.ToHtml(ThinkGeo.MapSuite.Drawing.GeoColor)">
            <remarks>None</remarks>
            <summary>This method returns an HTML color from a GeoColor.</summary>
            <returns>This method returns an HTML color from a GeoColor.</returns>
            <param name="color">This parameter represents the GeoColor you want to convert.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the drawingColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.ToWin32(ThinkGeo.MapSuite.Drawing.GeoColor)">
            <example>
            None
            </example>
            <summary>This method returns a Win32 color from a GeoColor.</summary>
            <returns>This method returns a Win32 color from a GeoColor.</returns>
            <param name="color">This parameter represents the GeoColor you want to convert.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the drawingColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.op_Equality(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <returns>This method returns the equality of the two instances.</returns>
            <param name="geoColor1">This parameter represents the first GeoColor to compare.</param>
            <param name="geoColor2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetGeoColor, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceGeoColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.op_Inequality(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <returns>This method returns the inequality of the two instances.</returns>
            <param name="geoColor1">This parameter represents the first GeoColor to compare.</param>
            <param name="geoColor2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetGeoColor, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceGeoColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <returns>This method returns the Equals functionality.</returns>
            <remarks>None</remarks>
            <param name="obj">
            This parameter is the object you want to check to see if it is equal to the current
            instance.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the obj, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoColor.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <returns>This method returns the hash code.</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoColors">
            <summary>
            This class is a collection of predefined colors
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ActiveBorder">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ActiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ActiveCaptionText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.AppWorkspace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Control">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ControlDark">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ControlDarkDark">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ControlLight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ControlLightLight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ControlText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Desktop">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.GrayText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Highlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.HighlightText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.HotTrack">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.InactiveBorder">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.InactiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.InactiveCaptionText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Info">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.InfoText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Menu">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MenuText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ScrollBar">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Window">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.WindowFrame">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.WindowText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Transparent">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.AliceBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.AntiqueWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Aqua">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Aquamarine">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Azure">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Beige">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Bisque">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Black">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BlanchedAlmond">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Blue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BlueViolet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Brown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BurlyWood">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.CadetBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Chartreuse">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Chocolate">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Coral">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.CornflowerBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Cornsilk">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Crimson">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Cyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkCyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkGoldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkKhaki">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkMagenta">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkOliveGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkOrange">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkOrchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkSalmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkSlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkSlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkViolet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DeepPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DeepSkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DimGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DodgerBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Firebrick">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.FloralWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ForestGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Fuchsia">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Gainsboro">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.GhostWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Gold">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Goldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Gray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Green">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.GreenYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Honeydew">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.HotPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.IndianRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Indigo">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Ivory">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Khaki">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Lavender">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LavenderBlush">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LawnGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LemonChiffon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightCoral">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightCyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightGoldenrodYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightSalmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightSkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightSlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightSteelBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Lime">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LimeGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Linen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Magenta">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Maroon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumAquamarine">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumOrchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumPurple">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumSlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumSpringGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MediumVioletRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MidnightBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MintCream">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MistyRose">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Moccasin">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.NavajoWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Navy">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.OldLace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Olive">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.OliveDrab">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Orange">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.OrangeRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Orchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleGoldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleVioletRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PapayaWhip">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PeachPuff">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Peru">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Pink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Plum">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PowderBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Purple">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Red">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.RosyBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.RoyalBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SaddleBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Salmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SandyBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SeaShell">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Sienna">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Silver">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Snow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SpringGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.SteelBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Tan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Teal">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Thistle">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Tomato">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Turquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Violet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Wheat">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.White">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.WhiteSmoke">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Yellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.YellowGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ButtonFace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ButtonHighlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.ButtonShadow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.GradientActiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.GradientInactiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MenuBar">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.MenuHighlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.DarkYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.LightOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a transparent GeoColor.</decimalDegreesValue>
            <summary>This property returns a transparent GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PaleOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BrightRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BrightBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BrightYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BrightGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.BrightOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PastelRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PastelBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PastelYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PastelGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.PastelOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoColors.Copper">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Copper GeoColor.</decimalDegreesValue>
            <summary>This property returns a Copper GeoColor.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoDashCap">
            <summary>
            	<para>This enumeration represents the type of graphic shape to use on both ends of
                each dash in a dashed line.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoDashCap.Flat">
            <summary>Specifies a square cap that squares off both ends of each dash.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoDashCap.Round">
            <summary>Specifies a circular cap that rounds off both ends of each dash.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoDashCap.Triangle">
            <summary>Specifies a triangular cap that points both ends of each dash.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeographicColors">
            <summary>
            This class is a convenient way to access a predefined set of geographic
            colors.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Sand">
            <summary>This property returns a Sand GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Sand GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Grass">
            <summary>This property returns a Grass GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Grass GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Dirt">
            <summary>This property returns a Dirt GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Dirt GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Mountains">
            <summary>This property returns a Mountains GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Mountains GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Lake">
            <summary>This property returns a Lake GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Lake GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.DeepOcean">
            <summary>This property returns a DeepOcean GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DeepOcean GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.ShallowOcean">
            <summary>This property returns a ShallowOcean GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a ShallowOcean GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Tundra">
            <summary>This property returns a Tundra GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Tundra GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Forest">
            <summary>This property returns a Forest GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Forest GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Ice">
            <summary>This property returns a Ice GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Ice GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Swamp">
            <summary>This property returns a Swamp GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Swamp GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Road">
            <summary>This property returns a Road GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Road GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.Highway">
            <summary>This property returns a Highway GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Highway GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.InnerState">
            <summary>This property returns a Interstate GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Interstate GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.LocalRoad">
            <summary>This property returns a LocalRoad GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LocalRoad GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeographicColors.MajorRoad">
            <summary>This property returns a MajorRoad GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a MajorRoad GeoColor.</decimalDegreesValue>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoHatchBrush">
            <summary>This class represents a brush that fills with various patterns.</summary>
            <remarks>This class represents a brush that fills with various patterns.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoHatchBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoHatchStyle,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a foreground color for the pattern
            fill.
            </overloads>
            <returns>None</returns>
            <remarks>
            You will use this constructor when you want to only specify the foreground color
            of the pattern and leave the background transparent.
            </remarks>
            <param name="hatchStyle">This property is the hatch pattern you want to use to fill the area.</param>
            <param name="foregroundColor">This property is the foreground color you want to use for the pattern.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoHatchBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoHatchStyle,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a foreground and background color for the
            pattern fill.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to choose both the background and foreground color
            for the pattern.
            </remarks>
            <param name="hatchStyle">This property is the hatch pattern you want to use to fill the area.</param>
            <param name="foregroundColor">This property is the foreground color you want to use for the pattern.</param>
            <param name="backgroundColor">This property is the background color you want to use for the pattern.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoHatchBrush.HatchStyle">
            <summary>This property gets and sets the pattern you want to use for the fill.</summary>
            <value>This property gets the pattern you want to use for the fill.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoHatchBrush.ForegroundColor">
            <summary>This property gets and sets the foreground color for the fill pattern.</summary>
            <value>This property gets the foreground color for the fill pattern.</value>
            <remarks>In this case the background color will be transparent.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoHatchBrush.BackgroundColor">
            <summary>This property gets and sets the background color for the fill pattern.</summary>
            <remarks>In this case the foreground color will be transparent.</remarks>
            <value>This property gets the background color for the fill pattern.</value>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoHatchStyle">
            <summary>
            This enumeration defines the various kinds of hatch patterns that can be used to
            fill areas using the GeoHatchBrush.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Horizontal">
            <summary>A Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Vertical">
            <summary>A Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.ForwardDiagonal">
            <summary>A Forward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.BackwardDiagonal">
            <summary>A Backward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LargeGrid">
            <summary>A Large Grid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DiagonalCross">
            <summary>A Diagonal Cross pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent05">
            <summary>A 05 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent10">
            <summary>A 10 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent20">
            <summary>A 20 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent25">
            <summary>A 25 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent30">
            <summary>A 30 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent40">
            <summary>A 40 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent50">
            <summary>A 50 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent60">
            <summary>A 60 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent70">
            <summary>A 70 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent75">
            <summary>A 75 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent80">
            <summary>A 80 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Percent90">
            <summary>A 90 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LightDownwardDiagonal">
            <summary>A Light Downward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LightUpwardDiagonal">
            <summary>A Light Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DarkDownwardDiagonal">
            <summary>A Dark Downward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DarkUpwardDiagonal">
            <summary>A Dark Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.WideDownwardDiagonal">
            <summary>A Wide Downward Diagonal pattern fill.</summary>        
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.WideUpwardDiagonal">
            <summary>A Wide Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LightVertical">
            <summary>A Light Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LightHorizontal">
            <summary>A Light Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.NarrowVertical">
            <summary>A Narrow Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.NarrowHorizontal">
            <summary>A Narrow Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DarkVertical">
            <summary>A Dark Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DarkHorizontal">
            <summary>A Dark Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DashedDownwardDiagonal">
            <summary>A Dashed Downward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DashedUpwardDiagonal">
            <summary>A Dashed Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DashedHorizontal">
            <summary>A Dashed Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DashedVertical">
            <summary>A Dashed Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.SmallConfetti">
            <summary>A Small Confetti pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LargeConfetti">
            <summary>A Large Confetti pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.ZigZag">
            <summary>A Zig Zag pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Wave">
            <summary>A Wave pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DiagonalBrick">
            <summary>A Diagonal Brick pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.HorizontalBrick">
            <summary>A Horizontal Brick pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Weave">
            <summary>A Weave pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Plaid">
            <summary>A Plaid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Divot">
            <summary>A Divot pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DottedGrid">
            <summary>A Dotted Grid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.DottedDiamond">
            <summary>A Dotted Diamond pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Shingle">
            <summary>A Shingle pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Trellis">
            <summary>A Trellis pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Sphere">
            <summary>A Sphere pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.SmallGrid">
            <summary>A Small Grid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.SmallCheckerBoard">
            <summary>A Small Checker Board pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.LargeCheckerBoard">
            <summary>A Large Checker Board pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.OutlinedDiamond">
            <summary>A Outlined Diamond pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.SolidDiamond">
            <summary>A Solid Diamond pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Min">
            <summary>A Min pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Max">
            <summary>A Max pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoHatchStyle.Cross">
            <summary>A Cross pattern fill.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush">
            <summary>Encapsulates a <strong>GeoBrush</strong> with a linear gradient.</summary>
            <remarks>
            	<para>This class encapsulates both two-color gradients and custom multicolor
                gradients.</para>
            	<para></para>
            	<para>All linear gradients are defined along a line specified either by the width
                of a rectangle or by two points.</para>
            	<para></para>
            	<para>By default, a two-color linear gradient is an even horizontal linear blend
                from the starting color to the ending color along the specified line.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.#ctor">
            <summary>
            Create a new instance of the GeoLinearGradientBrush with default settings.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection)">
            <summary>
            Create an instance of GeoLinearGradientBrush by passing a gradient start color and
            gradient end color followed by the gradient direction enum.
            </summary>
            <param name="startColor">
            This parameter specifies the starting <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="endColor">
            This parameter specifies the endding <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="direction">
            This parameter specifies the <strong>GeoLinearGradientDirection</strong>
            enumeration of the <strong>GeoLinearGradientBrush</strong>.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Create an instance of GeoLinearGradientBrush by passing a gradient start color and
            gradient end color followed by the gradient direction angle.
            </summary>
            <param name="startColor">
            This parameter specifies the starting <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="endColor">
            This parameter specifies the endding <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="directionAngle">
            This parameter specifies the direction angle value of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.StartColor">
            <summary>Gets or sets the starting <strong>GeoColor</strong> of the gradient.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.EndColor">
            <summary>Gets or sets the ending <strong>GeoColor</strong> of the gradient.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.DirectionAngle">
            <summary>
            Gets or sets the Direction angle of the
            <strong>GeoLinearGradientBrush</strong>.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoLinearGradientBrush.WrapMode">
            <summary>
            Gets or sets a <strong>GeoWrapMode</strong> enumeration that indicates the wrap
            mode for the <strong>GeoLinearGradientBrush</strong>.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection">
            <summary>
            Specifies the direction of a linear gradient.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.LeftToRight">
            <summary>
            Specifies the color should change in a horizontal direction from the left of the
            display to the right of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.RightToLeft">
            <summary>
            Specifies the color should change in a horizontal direction from the right of the
            display to the left of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.TopToBottom">
            <summary>
            Specifies the color should change in a horizontal direction from the top of the
            display to the bottom of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.BottomToTop">
            <summary>
            Specifies the color should change in a horizontal direction from the bottom of the
            display to the top of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.UpperLeftToLowerRight">
            <summary>
            Specifies the color should change in a horizontal direction from the upper left of
            the display to the lower right of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.LowerRightToUpperLeft">
            <summary>
            Specifies the color should change in a horizontal direction from the lower right of
            the display to the upper leftof the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.LowerLeftToUpperRight">
            <summary>
            Specifies the color should change in a horizontal direction from the lower left of
            the display to the upper right of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoLinearGradientDirection.UpperRightToLowerLeft">
            <summary>
            Specifies the color should change in a horizontal direction from the upper right of
            the display to the lower left of the display.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoPens">
            <summary>
            Provides a collection of predefined GeoPens
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoSolidBrush">
            <summary>
            	<para>This class defines a GeoBrush of a single color. Brushes are used to fill
                area shapes on a GeoCanvas.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoSolidBrush.#ctor">
            <summary>This is the constructor used to create a new GeoSolidBrush.</summary>
            <overloads>This constructor creates a GeoSolidBrush in the color black.</overloads>
            <remarks>None</remarks>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoSolidBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This is the constructor used to create a new GeoSolidBrush.</summary>
            <overloads>This constructor creates a GeoSolidBrush by passing in a GeoColor.</overloads>
            <remarks>None</remarks>
            <param name="color">This parameter represent the color of the GeoSolidBrush.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoSolidBrush.Color">
            <summary>This property gets or sets the color of the GeoSolidBrush.</summary>
            <decimalDegreesValue>This property gets the color of the GeoSolidBrush.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoTextureBrush">
            <summary>This class is used to fill an area with a image texture.</summary>
            <remarks>
            This class is used to fill an area with a image texture. For example, you may have
            a small bitmap that looks like marble, which you can then use to fill in an area
            feature.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This overload allows you to pass in the image for the texture.</overloads>
            <returns>None</returns>
            <remarks>
            You will use this constructor when you want to use the Tile wrap mode and you
            want the image fill to encompass the entire shape.
            </remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the image as well as a screen rectangle that
            determines how much of the area is filled.
            </overloads>
            <returns>None</returns>
            <remarks>
            This method allows you to pass in a rectangle in screen coordinates to determine
            how much of the area is textured.
            </remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
            <param name="rectangleF">
            This parameter is a rectangle (in screen coordinates) that specifies the area you want
            to use for the texture.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Drawing.GeoWrapMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the image and the wrap mode.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
            <param name="wrapMode">
            This parameter determines the way the texture wraps when the area to fill is
            larger than the texture.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Drawing.GeoImage,ThinkGeo.MapSuite.Drawing.GeoWrapMode,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the image as well as a screen rectangle that
            determines how much of the area is filled along with the wrap mode.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
            <param name="wrapMode">
            This parameter determines the way the texture wraps when the area to fill is
            larger than the texture.
            </param>
            <param name="rectangleF">
            This parameter is a rectangle (in screen coordinates) that specifies the area you want
            to use for the texture.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.GeoImage">
            <summary>This property gets and sets the GeoImage used for the texture fill.</summary>
            <value>This property gets the GeoImage used for the texture fill.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.DrawingRectangleF">
            <summary>This property gets and sets the screen rectangle used to fill the texture.</summary>
            <value>This property gets the screen rectangle used to fill the texture.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.GeoTextureBrush.GeoWrapMode">
            <summary>
            This property gets and sets the wrap mode that is used to determine how an area
            is filled if the area is larger than the texture.
            </summary>
            <value>
            This property gets the wrap mode that is used to determine how an area is filled
            if the area is larger than the texture.
            </value>
            <remarks>
            This property gets and sets the wrap mode that is used to determine how an area
            is filled if the area is larger than the texture.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.GeoWrapMode">
            <summary>
            This enumeration determines how a texture is filled in with a GeoTextureBrush when the
            area to be filled is larger than the texture.
            </summary>
            <remarks>
            This will allow you to achieve a number of different effects. We suggest you try
            them out with your own textures and see which one looks best for your image.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoWrapMode.Tile">
            <summary>The texture is tiled to fill the entire area.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoWrapMode.Clamp">
            <summary>The texture will not be tiled.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoWrapMode.TileFlipX">
            <summary>Reverse the texture horizontally and then tile the texture.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoWrapMode.TileFlipY">
            <summary>Reverse the texture vertically and then tile the texture.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.GeoWrapMode.TileFlipXY">
            <summary>Reverse the texture horizontally and vertically and then tile the texture.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.LineDashStyle">
            <summary>
            	<para>This enumeration specifies the style of dashed lines drawn with a GeoPen
                object.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.LineDashStyle.Solid">
            <summary>Specifies a solid line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.LineDashStyle.Custom">
            <summary>Specifies a user-defined custom dash style.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.LineDashStyle.DashDot">
            <summary>Specifies a line consisting of a repeating pattern of dash-dot.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.LineDashStyle.DashDotDot">
            <summary>Specifies a line consisting of a repeating pattern of dash-dot-dot.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.LineDashStyle.Dot">
            <summary>Specifies a line consisting of dots.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.LineDashStyle.Dash">
            <summary>Specifies a line consisting of dashes.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder">
            <summary>This enumeration determines whether the brush or the pen draws first.</summary>
            <remarks>
            This controls if the outline pen or the fill brush will draw first. The
            difference in drawing is subtle, but noticeable. If you draw the outline first and then the brush, the
            brush fill will slightly bleed into the outline and make the outline appear thinner.  If you draw
            the brush first, then the pen will display its normal outline width.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder.BrushFirst">
            <summary>The fill brush will draw first.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder.PenFirst">
            <summary>The outline pen will draw first.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.RandomColorType">
            <summary>
            Defines values represent which kind of color will use for randomly.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.RandomColorType.All">
            <summary>
            This item represents all random color.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.RandomColorType.Pastel">
            <summary>
            This item represents pastel color.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.RandomColorType.Bright">
            <summary>
            This item represents bright color.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingExceptionMode.Default">
            <summary>
            Default mode used in MapSuite component.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingExceptionMode.ThrowException">
            <summary>
            This item means the exception will be throw out and the rest of drawing will be terminated.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Drawing.DrawingExceptionMode.DrawException">
            <summary>
            This item means that we will catch the exception and draw it to show error happens, while the user 
            cannot catch it any more.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.SimpleColors">
            <summary>
            This class is a convenient way to access a predefined set of simple
            colors.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Transparent">
            <summary>This property returns a Transparent GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Transparent GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Black">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Black GeoColor.</decimalDegreesValue>
            <summary>This property returns a Black GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Red">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Red GeoColor.</decimalDegreesValue>
            <summary>This property returns a Red GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Blue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Blue GeoColor.</decimalDegreesValue>
            <summary>This property returns a Blue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Yellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Yellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a Yellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Green">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Green GeoColor.</decimalDegreesValue>
            <summary>This property returns a Green GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Orange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Orange GeoColor.</decimalDegreesValue>
            <summary>This property returns a Orange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.DarkRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.DarkBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.DarkYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.DarkGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.DarkOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.LightRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.LightBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.LightYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.LightGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.LightOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a transparent GeoColor.</decimalDegreesValue>
            <summary>This property returns a transparent GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PaleRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PaleBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PaleYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PaleGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PaleOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.BrightRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.BrightBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.BrightYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.BrightGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.BrightOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PastelRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PastelBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PastelYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PastelGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.PastelOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Silver">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Silver GeoColor.</decimalDegreesValue>
            <summary>This property returns a Silver GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Gold">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Gold GeoColor.</decimalDegreesValue>
            <summary>This property returns a Gold GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.Copper">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Copper GeoColor.</decimalDegreesValue>
            <summary>This property returns a Copper GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.SimpleColors.White">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a White GeoColor.</decimalDegreesValue>
            <summary>This property returns a White GeoColor.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Drawing.StandardColors">
            <summary>
            This class is a convenient way to access a predefined set of standard
            colors.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ActiveBorder">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ActiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ActiveCaptionText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.AppWorkspace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Control">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ControlDark">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ControlDarkDark">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ControlLight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ControlLightLight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ControlText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Desktop">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.GrayText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Highlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.HighlightText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.HotTrack">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.InactiveBorder">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.InactiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.InactiveCaptionText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Info">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.InfoText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Menu">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MenuText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ScrollBar">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Window">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.WindowFrame">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.WindowText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Transparent">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.AliceBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.AntiqueWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Aqua">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Aquamarine">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Azure">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Beige">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Bisque">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Black">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.BlanchedAlmond">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Blue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.BlueViolet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Brown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.BurlyWood">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.CadetBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Chartreuse">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Chocolate">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Coral">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.CornflowerBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Cornsilk">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Crimson">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Cyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkCyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkGoldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkKhaki">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkMagenta">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkOliveGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkOrange">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkOrchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkSalmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkSlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkSlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DarkViolet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DeepPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DeepSkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DimGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.DodgerBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Firebrick">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.FloralWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ForestGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Fuchsia">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Gainsboro">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.GhostWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Gold">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Goldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Gray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Green">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.GreenYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Honeydew">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.HotPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.IndianRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Indigo">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Ivory">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Khaki">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Lavender">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LavenderBlush">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LawnGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LemonChiffon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightCoral">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightCyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightGoldenrodYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightSalmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightSkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightSlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightSteelBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LightYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Lime">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.LimeGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Linen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Magenta">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Maroon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumAquamarine">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumOrchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumPurple">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumSlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumSpringGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MediumVioletRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MidnightBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MintCream">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MistyRose">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Moccasin">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.NavajoWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Navy">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.OldLace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Olive">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.OliveDrab">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Orange">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.OrangeRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Orchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PaleGoldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PaleGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PaleTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PaleVioletRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PapayaWhip">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PeachPuff">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Peru">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Pink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Plum">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.PowderBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Purple">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Red">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.RosyBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.RoyalBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SaddleBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Salmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SandyBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SeaShell">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Sienna">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Silver">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Snow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SpringGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.SteelBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Tan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Teal">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Thistle">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Tomato">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Turquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Violet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Wheat">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.White">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.WhiteSmoke">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.Yellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.YellowGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ButtonFace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ButtonHighlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.ButtonShadow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.GradientActiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.GradientInactiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MenuBar">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Drawing.StandardColors.MenuHighlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Portable.ZipStorer">
            <summary>
            Unique class for compression/decompression file. Represents a Zip file.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Portable.ZipStorer.Compression">
            <summary>
            Compression method enumeration
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.Compression.Store">
            <summary>Uncompressed storage</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.Compression.Deflate">
            <summary>Deflate compression method</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry">
            <summary>
            Represents an entry in Zip file directory
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.Method">
            <summary>Compression method</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.FilenameInZip">
            <summary>Full path and filename as stored in Zip</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.FileSize">
            <summary>Original file size</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.CompressedSize">
            <summary>Compressed file size</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.HeaderOffset">
            <summary>Offset of header information inside Zip storage</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.FileOffset">
            <summary>Offset of file inside Zip storage</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.HeaderSize">
            <summary>Size of header information</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.Crc32">
            <summary>32-bit checksum of entire file</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.ModifyTime">
            <summary>Last modification time of file</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.Comment">
            <summary>User comment for file</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.EncodeUTF8">
            <summary>True if UTF8 encoding for filename and comments, false if default (CP 437)</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry.ToString">
            <summary>Overriden method</summary>
            <returns>Filename in Zip</returns>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.EncodeUTF8">
            <summary>True if UTF8 encoding for filename and comments, false if default (CP 437)</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Portable.ZipStorer.ForceDeflating">
            <summary>Force deflate algotithm even if it inflates the stored file. Off by default.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.Create(System.String,System.String)">
            <summary>
            Method to create a new storage file
            </summary>
            <param name="_filename">Full path of Zip file to create</param>
            <param name="_comment">General comment for Zip file</param>
            <returns>A valid ZipStorer object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.Create(System.IO.Stream,System.String)">
            <summary>
            Method to create a new zip storage in a stream
            </summary>
            <param name="_stream"></param>
            <param name="_comment"></param>
            <returns>A valid ZipStorer object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.Open(System.String,System.IO.FileAccess)">
            <summary>
            Method to open an existing storage file
            </summary>
            <param name="_filename">Full path of Zip file to open</param>
            <param name="_access">File access mode as used in FileStream constructor</param>
            <returns>A valid ZipStorer object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.Open(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Method to open an existing storage from stream
            </summary>
            <param name="_stream">Already opened stream with zip contents</param>
            <param name="_access">File access mode for stream operations</param>
            <returns>A valid ZipStorer object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.AddFile(ThinkGeo.MapSuite.Portable.ZipStorer.Compression,System.String,System.String,System.String)">
            <summary>
            Add full contents of a file into the Zip storage
            </summary>
            <param name="_method">Compression method</param>
            <param name="_pathname">Full path of file to add to Zip storage</param>
            <param name="_filenameInZip">Filename and path as desired in Zip directory</param>
            <param name="_comment">Comment for stored file</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.AddStream(ThinkGeo.MapSuite.Portable.ZipStorer.Compression,System.String,System.IO.Stream,System.DateTime,System.String)">
            <summary>
            Add full contents of a stream into the Zip storage
            </summary>
            <param name="_method">Compression method</param>
            <param name="_filenameInZip">Filename and path as desired in Zip directory</param>
            <param name="_source">Stream object containing the data to store in Zip</param>
            <param name="_modTime">Modification time of the data to store</param>
            <param name="_comment">Comment for stored file</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.Close">
            <summary>
            Updates central directory (if pertinent) and close the Zip storage
            </summary>
            <remarks>This is a required step, unless automatic dispose is used</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.ReadCentralDir">
            <summary>
            Read all the file records in the central directory
            </summary>
            <returns>List of all entries in directory</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.ExtractFile(ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry,System.String)">
            <summary>
            Copy the contents of a stored file into a physical file
            </summary>
            <param name="_zfe">Entry information of file to extract</param>
            <param name="_filename">Name of file to store uncompressed data</param>
            <returns>True if success, false if not.</returns>
            <remarks>Unique compression methods are Store and Deflate</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.ExtractFile(ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry,System.IO.Stream)">
            <summary>
            Copy the contents of a stored file into an opened stream
            </summary>
            <param name="_zfe">Entry information of file to extract</param>
            <param name="_stream">Stream to store the uncompressed data</param>
            <returns>True if success, false if not.</returns>
            <remarks>Unique compression methods are Store and Deflate</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.RemoveEntries(ThinkGeo.MapSuite.Portable.ZipStorer@,System.Collections.Generic.List{ThinkGeo.MapSuite.Portable.ZipStorer.ZipFileEntry})">
            <summary>
            Removes one of many files in storage. It creates a new Zip file.
            </summary>
            <param name="_zip">Reference to the current Zip object</param>
            <param name="_zfes">List of Entries to remove from storage</param>
            <returns>True if success, false if not</returns>
            <remarks>This method only works for storage of type FileStream</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Portable.ZipStorer.Dispose">
            <summary>
            Closes the Zip file stream
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.ExtendedHelper.GetVersion">
            <summary>
            Get the current ThinkGeo.MapSuite.dll file version.
            </summary>
            <returns>A string representing the file version of MapSuiteCore.dll.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.ExtendedHelper.ShowProductCenter">
            <summary>
            Show Product Center
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.ExtendedHelper.BuildFourColorColumn(System.String,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            This method returns all features in the FeatureSource, the features contain the "Color" column. 
            The column has a range of 1, 2, 3, 4, and each value represents a color.
            </summary>
            <returns>
            This method returns four color features in the FeatureSource. 
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.MapSuiteLicenseStatus">
            <summary>
            map suite license status order by the eval invalid then full invalid then eval valid then full valid.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.GeoCollection`1">
            <summary>
            This class is a collection with some methods specialized for dealing with Layers
            and other spatial classes.
            </summary>
            <remarks>
            We have added some helpful methods like MoveUp, MoveDown, etc. These help when you
            are manipulating Layers.
            </remarks>
            <typeparam name="T">This parameter is the item you want a collection of.</typeparam>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.GeoCollection`1.Item(System.String)">
            <summary>This property gets and sets the object.</summary>
            <decimalDegreesValue>This property gets the object.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.GetKeys">
            <summary>This method returns a collection of the keys in the collection.</summary>
            <returns>This method returns a collection of the keys in the collection.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.Add(System.String,`0)">
            <summary>
            This method adds an item to the collection by specifying the item and a
            key.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key to find the item.</param>
            <param name="item">This parameter is the item you want added to the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.Add(`0)">
            <summary>
            This method adds an item to the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method adds an item to the collection, and the item's key will be a random GUID.</remarks>
            <param name="item">This parameter is the item you want added to the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into the System.Collections.ObjectModel.Collection&lt;T&gt; at
            the specified index.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">index is less than zero.  -or- index is greater than System.Collections.ObjectModel.Collection&lt;T&gt;.Count.</exception>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert. The value can be null for reference types.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.Insert(System.Int32,System.String,`0)">
            <summary>
            Inserts an element into the System.Collections.ObjectModel.Collection&lt;T&gt; at
            the specified index and key.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">index is less than zero.  -or- index is greater than System.Collections.ObjectModel.Collection&lt;T&gt;.Count.</exception>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="key">The key to find the item.</param>
            <param name="item">The object to insert. The value can be null for reference types.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.Remove(System.String)">
            <summary>This method removes an item from the collection based on the specified key.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key of the item you want to remove.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.RemoveItem(System.Int32)">
            <summary>This method removes an item from the collection based on the specified index.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="index">This parameter is the index of the item you want to remove.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveUp(System.Int32)">
            <summary>This method moves an item up in the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="index">This parameter is the index of the item in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveUp(System.String)">
            <summary>This method moves an item up in the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key of the item in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveUp(`0)">
            <summary>This method moves an item up in the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="item">This parameter is the item you want to move up in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveDown(System.Int32)">
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This method moves an item down in the collection.</summary>
            <param name="index">This parameter is the index of the item in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveDown(System.String)">
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This method moves an item down in the collection.</summary>
            <param name="key">This parameter is the key of the item in the dictionary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveDown(`0)">
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This method moves an item down in the collection.</summary>
            <param name="item">This parameter is the item you want to move down in the dictionary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveToTop(System.Int32)">
            <summary>
            This method moves the item at the specified index to the top of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item at the specified index to the top of the collection.</remarks>
            <param name="index">This parameter is the index of the item you want move to the top of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveToTop(System.String)">
            <summary>
            This method moves the item with the specified key to the top of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item with the specified key to the top of the collection.</remarks>
            <param name="key">This parameter is the key of the item you want move to the top of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveToTop(`0)">
            <summary>
            This method moves the item specified to the top of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item specified to the top of the collection.</remarks>
            <param name="item">This parameter is the item you want move to the top of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveToBottom(System.Int32)">
            <summary>
            This method moves the item at the specified index to the bottom of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item at the specified index to the bottom of the collection.</remarks>
            <param name="index">This parameter is the index of the item you want move to the bottom of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveToBottom(System.String)">
            <summary>
            This method moves the item with the specified key to the bottom of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item with the specified key to the bottom of the collection.</remarks>
            <param name="key">This parameter is the key of the item you want move to the bottom of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveToBottom(`0)">
            <summary>
            This method moves the item specified key to the bottom of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item specified key to the bottom of the collection.</remarks>
            <param name="item">This parameter is the item you want move to the bottom of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveTo(System.Int32,System.Int32)">
            <summary>
            This method moves the item at fromIndex to the location of toIndex in the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item at fromIndex to the location of toIndex in the collection.</remarks>
            <param name="fromIndex">This parameter is the index of the item you want move from in the collection.</param>
            <param name="toIndex">This parameter is the target index that you want to move the item to in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveTo(System.String,System.Int32)">
            <summary>
            This method moves the item with the key you specified to the location of toIndex in the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item with the key you specified to the location of toIndex in the collection.</remarks>
            <param name="key">This parameter is the key of item you want to move in the collection.</param>
            <param name="toIndex">This parameter is the target index that you want to move the item to in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.MoveTo(`0,System.Int32)">
            <summary>
            This method moves the item you specified to the location of toIndex in the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item you specified to the location of toIndex in the collection.</remarks>
            <param name="item">This parameter is the item you want to move in the collection.</param>
            <param name="toIndex">This parameter is the target index that you want to move the item to in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.Contains(System.String)">
            <summary>This method returns whether an item is in the collection based on the specified key.</summary>
            <returns>This method returns whether an item is in the collection based on the specified key.</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key of the item you are searching for.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.ClearItems">
            <summary>This method clears the items from the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.GeoCollection`1.SetItem(System.Int32,`0)">
            <summary>This method allows you to set an item based on the index.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="index">This parameter is the index of the item you want to set.</param>
            <param name="item">This parameter is the item you want to set.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.GeographyUnit">
            <summary>Units describing the way geographies are stored in a data source.</summary>
            <remarks>
            The geography unit defines how your map data is stored. More specifically, it
            describes what the change in X and Y mean in relationship to the data itself. For
            example, if your data is stored in a geographic unit of feet, an increase of one
            on the x-axis means that you've moved one foot in the X direction. Nearly all map data is
            stored using three simple units, which are decimal degrees, feet, and meters. It is
            important to note that this has very little to do with the projection that the data is
            in.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.GeographyUnit.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.GeographyUnit.DecimalDegree">
            <summary>Decimal Degrees</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.GeographyUnit.Feet">
            <summary>Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.GeographyUnit.Meter">
            <summary>Meters </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PointLineRelationship">
            <summary>
            The topology relationship between point and line.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PointLineRelationship.Left">
            <summary>
            The point is at the left of the line.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PointLineRelationship.Right">
            <summary>
            The point is at the right of the line.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PointLineRelationship.OnLine">
            <summary>
            The point is on the line.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.AreaBaseShape">
            <summary>
            This abstract class is the root of all area-based shapes, such as RectangleShape
            and PolygonShape.
            </summary>
            <remarks>
            	<para>This class is used as the base class for area shapes such as:<br/>
            		<br/>
                PolygonShape<br/>
                RectangleShape<br/>
                MultiPolygonShape<br/>
                EllipseShape<br/>
                RingShape<br/>
            		<br/>
                It can be inherited from to create your own specialized area geometry. If you
                choose to do this, your new class must conform to one of the well-known text standard
                shapes in order for the base implementations to work properly.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.#ctor">
            <summary>This is the default constructor for AreaBaseShape.</summary>
            <remarks>This constructor simply calls the base constructor.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetPerimeter(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on a LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetPerimeterCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on a LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value.  For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetArea(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on a AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetAreaCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on a AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the area inside the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleUp(ThinkGeo.MapSuite.Shapes.AreaBaseShape,System.Double)">
            <summary>
            This method returns a new area shape that has been scaled up by the percentage
            given in the percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter is the shape to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleUp(ThinkGeo.MapSuite.Shapes.Feature,System.Double)">
            <summary>
            This method returns a new area shape that has been scaled up by the percentage
            given in the percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter is the feature to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleUp(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape. as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleUpCore(System.Double)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleDown(ThinkGeo.MapSuite.Shapes.AreaBaseShape,System.Double)">
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </remarks>
            <summary>
            This method returns a new area shape that has been scaled down by the percentage
            given in the percentage parameter.
            </summary>
            <param name="targetShape">This parameter is the shape to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleDown(ThinkGeo.MapSuite.Shapes.Feature,System.Double)">
            <returns>
            This method is useful when you would like to decrease the size of the feature. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to decrease the size of the feature. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </remarks>
            <summary>
            This method returns a new area feature that has been scaled down by the percentage
            given in the percentage parameter.
            </summary>
            <param name="targetFeature">This parameter is the shape to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleDown(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.ScaleDownCore(System.Double)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetConvexHull">
            <summary>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </summary>
            <returns>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetConvexHullCore">
            <summary>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </summary>
            <returns>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetIntersection(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the intersection of the current shape and the target shape,
            defined as the set of all points which lie in both the current shape and the target
            shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in both the current shape and the target shape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetIntersection(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the intersection of the current shape and the target feature,
            defined as the set of all points which lie in both the current shape and the target
            feature.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in both the current shape and the target feature.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feature you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetIntersectionCore(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the intersection of the current shape and the target shape,
            defined as the set of all points which lie in both the current shape and the target
            shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in both the current shape and the target shape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape">The shape you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Union(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the union of the current shape and the target shape, defined
            as the set of all points in the current shape or the target shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target shape.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">The shape you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Union(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the union of the current shape and the target feature, defined
            as the set of all points in the current shape or the target feature.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target feature.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeature">The feature you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.UnionCore(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the union of the current shape and the target shapes, defined
            as the set of all points in the current shape or the target shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target shape.<br/>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">The shape you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Union(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            This method returns the union of the current shape and the target features, defined
            as the set of all points in the current shape or the target features.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target features.<br/>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetFeatures, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeatures">The target features you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Union(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.AreaBaseShape})">
            <summary>
            This method returns the union of the specified area shapes.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points that
            lie within the shapes you specified.<br/>
            	<br/>
            	<br/>
            	<br/>
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.<br/>
            	<br/>
            	<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapes, we will throw an ArgumentNullException.</exception>
            <param name="areaShapes">The shapes you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetDifference(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the difference between two shapes, defined as the set of all
            points which lie in the current shape but not in the targetShape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape but not in the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetDifference(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the difference between current shape and the specified feature, defined as the set of all
            points which lie in the current shape but not in the targetShape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape but not in the target feature.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feture you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetDifferenceCore(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the difference between two shapes, defined as the set of all
            points which lie in the current shape but not in the targetShape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape but not in the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape">The shape you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetSymmetricalDifference(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the symmetrical difference between two shapes, defined as the
            set of all points which lie in the current shape or the targetShape but not
            both.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape or the targetShape but not both.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the symmetrical difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetSymmetricalDifference(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the symmetrical difference between current shape and the specified feature, defined as the
            set of all points which lie in the current shape or the targetFeature but not
            both.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape or the targetFeature but not both.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feature you are trying to find the symmetrical difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.GetSymmetricalDifferenceCore(ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns the symmetrical difference between two shapes, defined as the
            set of all points which lie in the current shape or the targetShape but not
            both.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape or the targetShape but not both.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">>In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape">The shape you are trying to find the symmetrical difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Split(ThinkGeo.MapSuite.Shapes.AreaBaseShape,ThinkGeo.MapSuite.Shapes.AreaBaseShape)">
            <summary>
            This method returns a collection of MultiPolygonShapes split by the specified
            parameters.
            </summary>
            <overloads>This overload allows you split two area type shapes.</overloads>
            <returns>
            This method returns a collection of MultiPolygonShape split by the specified
            parameters.
            </returns>
            <remarks>None.</remarks>
            <param name="areaToSplit">This parameter represents the shape to be split.</param>
            <param name="areaToSplitBy">This parameter represents the shape that will be used to perform the split.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Split(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns a collection of Features split by the specified
            parameters.
            </summary>
            <overloads>This overload allows you split two area type features.</overloads>
            <returns>
            This method returns a collection of Features split by the specified
            parameters.
            </returns>
            <remarks>None.</remarks>
            <param name="areaToSplit">This parameter represents the feature to be split.</param>
            <param name="areaToSplitBy">This parameter represents the feature that will be used to perform the split.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Simplify(ThinkGeo.MapSuite.Shapes.AreaBaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="targetShape">This parameter specifies the area shape to be simplfied.</param>
            <param name="targetShapeUnit">This parameter specifies the geographic unit of the shape you are performing the operation</param>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="toleranceUnit">This parameter specifes the distance unit of the tolerance.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Simplify(ThinkGeo.MapSuite.Shapes.AreaBaseShape,System.Double,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="targetShape">This parameter specifies the area shape to be simplfied.</param>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Simplify(ThinkGeo.MapSuite.GeographyUnit,System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="shapeUnit">This parameter specifies the geographic unit of this current shape you are performing the operation</param>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="toleranceUnit">This parameter specifes the distance unit of the tolerance.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.Simplify(System.Double,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.AreaBaseShape.SimplifyCore(System.Double,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.BaseShape">
            <summary>
            The abstract class from which area shapes, line shapes, and point shapes inherit
            from.
            </summary>
            <remarks>
            The BaseShape is the lowest level shape in the shapes hierarchy. Directly
            inherited from BaseShape are AreaShape, LineShape and PointShape. The methods and
            properties on BaseShape are the lowest common denominator for all the various kinds of
            shapes. It marked abstract and is designed only to be inherited from.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.#ctor">
            <summary>This is the default constructor for BaseShape.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.BaseShape.Id">
            <summary>
            The id of the shape.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.BaseShape.Tag">
            <summary>
            The tag of the shape.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.CreateShapeFromWellKnownData(System.String)">
            <summary>This method creates a BaseShape from a string of well-known text.</summary>
            <remarks>
            	<para>This method creates a BaseShape from a string of well-known text. Well-known
                text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <returns>
            The return type is a higher level shape constructed from the well-known text you
            passed into the method. Though the object is a higher level shape, such as a
            PolygonShape or MultiPointShape, you will need to cast it to that shape in order to use
            its unique properties.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <param name="wellKnownText"><para>A string representing the geometry in well-known text format.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.LoadFromWellKnownData(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownText">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownText(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a stringthat represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.CreateShapeFromWellKnownData(System.Byte[])">
            <summary>This method creates a BaseShape from a string of well-known binary.</summary>
            <remarks>
            This method creates a BaseShape from a string of well-known binary. Well-known
            binary allows you to describe geometries as a binary array. Well-known binary is useful
            when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <returns>
            The return type is a higher level shape constructed from the well-known binary
            you passed into the method. Though the object is a higher level shape, such as a
            PolygonShape or MultiPointShape, you will need to cast it to that shape in order to use
            its unique properties.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null in the bytes parameter will throw an ArgumentNullException.</exception>
            <param name="wellKnownBinary">
            	<para>An array of bytes representing the geometry in well-known binary
                format.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.LoadFromWellKnownData(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null in the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null in the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownBinary">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownBinary(ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <overloads>This overload allows you to specify the byte order.</overloads>
            <param name="byteOrder">This parameter is the byte order used to encode the well-known binary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies if the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetBoundingBox">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownType">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.CloneDeep">
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByOffset(ThinkGeo.MapSuite.Shapes.BaseShape,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a shape repositioned from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns a shape repositioned from one location to another based on an X and Y
            offset distance.
            </returns>
            <param name="targetShape">This parameter is the basis of the moved shape.</param>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByOffset(ThinkGeo.MapSuite.Shapes.Feature,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a feature repositioned from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the feature's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a feature repositioned from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns a feature repositioned from one location to another based on an X and Y
            offset distance.
            </returns>
            <param name="targetFeature">This parameter is the basis of the moved feature.</param>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByOffset(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the base shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByOffset(System.Double,System.Double)">
            <summary>
            This method moves a base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset, the offset unit is same with the shape unit(both
            of them can be considered as Meter.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the base shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByDegree(ThinkGeo.MapSuite.Shapes.BaseShape,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a shape repositioned from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns a shape repositioned from one location to another based on a
            distance and a direction in degrees.
            </returns>
            <param name="targetShape">This parameter is the basis of the move.</param>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the one specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the measure for the
            move. For example, if you select miles as your distance unit, then the distance
            will be calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByDegree(ThinkGeo.MapSuite.Shapes.Feature,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a feature repositioned from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the feature's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a feature repositioned from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this feature a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns a feature repositioned from one location to another, based on a
            distance and a direction in degrees.
            </returns>
            <param name="targetFeature">This parameter is the basis of the move.</param>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the feature, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the measure for the
            move. For example, if you select miles as your distance unit, then the distance
            will be calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByDegree(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure of the translate.
            For example if you select miles as your distanceUnit then the distance will be
            calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByDegree(System.Double,System.Double)">
            <summary>
            This method moves a base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance and the shape has the same unit(both of them can be considered as Meter).
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0 then the operation is ignored.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure of the translate.
            For example if you select miles as your distanceUnit then the distance will be
            calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Rotate(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method returns a shape rotated by a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method returns a shape rotated by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the shape you can achieve
                in-place rotation. By moving the pivot point outside of the center of the shape you
                can translate the shape in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <returns>
            This method returns a shape rotated by a number of degrees based on a pivot
            point.
            </returns>
            <param name="sourceBaseShape">This parameter is the basis for the rotation.</param>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Rotate(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method returns a feature rotated by a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method returns a feature rotated by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the feature you can achieve
                in-place rotation. By moving the pivot point outside of the center of the feature you
                can translate the feature in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <returns>
            This method returns a shape rotated by a number of degrees based on a pivot
            point.
            </returns>
            <param name="targetFeature">This parameter is the basis for the rotation.</param>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Rotate(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates a shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method returns a shape rotated by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the shape you can achieve
                in-place rotation. By moving the pivot point outside of the center of the shape you
                can translate the shape in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates a shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates a shape by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the shape you can achieve
                in-place rotation. By moving the pivot point outside of the center of the shape you
                can translate the shape in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.BaseShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <value>This property specifies if the shape can be rotated.</value>
            <remarks>
            If this property returns false and you attempt to call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetShortestLineTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the shortest LineShape between this shape and the targetShape
            parameter.
            </summary>
            <returns>
            A LineShape representing the shortest distance between the shape you're calling the
            method on and the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns a LineShape representing the shortest distance between the
            shape you're calling the method on and the targetShape. In some instances, based on the
            GeographicType or Projection, the line may not be straight. This effect is similar to
            what you might see on an international flight when the displayed flight path is
            curved.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The geographic unit of the Shape you are trying to find the distance to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetShortestLineTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the shortest LineShape between this shape and the targetFeature.
            parameter.
            </summary>
            <returns>
            A MultiLineShape representing the shortest distance between the shape you're calling the
            method on and the targetFeature.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns a MultiLineShape representing the shortest distance between the
            shape you're calling the method on and the targetShape. In some instances, based on the
            GeographicType or Projection, the line may not be straight. This is effect is similar to
            what you might see on an international flight when the displayed flight path is
            curved.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetFeature"><para>The feature you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The geographic unit of the feature you are trying to find the distance to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetShortestLineToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the shortest LineShape between this shape and the targetShape
            parameter.
            </summary>
            <returns>
            A LineShape representing the shortest distance between the shape you're calling the
            method on and the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns a LineShape representing the shortest distance between the
            shape you're calling the method on and the targetShape. In some instances, based on the
            GeographicType or Projection, the line may not be straight. This is effect is similar to
            what you might see on an international flight when the displayed flight path is
            curved.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The geographic unit of the shape you are trying to find the distance to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetClosestPointTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">The geographic unit of the shape you are trying to find the closet point to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetClosestPointTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            feature.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetFeature.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetFeature which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetFeature, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target feature.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetFeature to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetFeature"><para>The feature you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">The geographic unit of the feature you are trying to find the closet point to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">The geographic unit of the shape you are trying to find the closet point to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetCenterPoint">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry, such as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetCenterPointCore">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry, such as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Buffer(System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape. In this case, you will be using the rounded
            RoundedBufferCapStyle and the default 8 quadrant segments. The distance unit
            is determined by the distanceUnit argument.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <overloads>
            This overload allows you to specify the distance in your choice of unit and
            uses defaults for everything else.
            </overloads>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Buffer(System.Double,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <overloads>
            This overload allows you to specify the distance in your choice of unit,
            specify the number of quadrant segments and uses defaults for everything else.
            </overloads>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape. In this case, you will be using the rounded
            RoundedBufferCapStyle. The distance unit is determined by the distanceUnit
            argument.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number of quadrant segments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">
            The quadrant segments are the number of points in each quarter circle. A good
            default is 8, but if you want smoother edges you can increase this number. The valid
            range for this number is from 3 to 100.
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Buffer(System.Double,System.Int32,ThinkGeo.MapSuite.Shapes.BufferCapType,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <overloads>This overload allows you to specify every parameter.</overloads>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number of quadrant segments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a bufferCapType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">
            The quadrant segments are the number of points in each quarter circle. A good
            default is 8, but if you want smoother edges you can increase this number. The valid
            range for this number is from 3 to 100.
            </param>
            <param name="bufferCapType">
            The bufferCapType determines how the caps of the buffered object look. They
            range from rounded to squared off.
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.BufferCore(System.Double,System.Int32,ThinkGeo.MapSuite.Shapes.BufferCapType,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a bufferCapType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid quadrantSegments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape. In this case, you will be using the rounded
            RoundedBufferCapStyle and the default 8 quadrant segments. The distance unit
            is determined by the distanceUnit argument.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <overloads>
            This overload allows you to specify the distance in your choice of unit and
            uses defaults for everything else.
            </overloads>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">The number of quadrantSegments used in the buffer logic.</param>
            <param name="bufferCapType">The bufferCapType used in the buffer logic.</param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetDistanceTo(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            In this method we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">This parameter is the unit of the shape you are getting the distance to.</param>
            <param name="distanceUnit">
            This parameter is the unit of the distance you want the return value to be
            in.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetDistanceTo(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetFeature.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetFeature in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            In this method we compute the closest distance between a shape and a feature. The
            returned unit will be in the unit of distance specified.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetFeature"><para>The feature you are trying to find the distance to.</para></param>
            <param name="shapeUnit">This parameter is the unit of the shape which is contained in the targetFeature you are getting the distance to.</param>
            <param name="distanceUnit">
            This parameter is the unit of the distance you want the return value to be
            in.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            In this method we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit"> the geographic unit of the targetShape.</param>
            <param name="distanceUnit">The returning distance unit.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Register(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Register(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointFeature in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointFeature in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Validate(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsDisjointed(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have no points in
            common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have no points in
            common.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsDisjointed(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature have no points in
            common.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature have no points in
            common.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The feature you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsDisjointedCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have no points in
            common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have no points in
            common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Intersects(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Intersects(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature have at least one
            point in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IntersectsCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Touches(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Touches(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns of the current shape and the targetFeature have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns of the current shape and the targetFeature have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature which contains a shape that you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.TouchesCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Crosses(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Crosses(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature share some but not
            all interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.CrossesCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsWithin(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </summary>
            <returns>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsWithin(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current shape lies within the interior of the
            targetFeature.
            </summary>
            <returns>
            This method returns if the current shape lies within the interior of the
            targetFeature.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsWithinCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </summary>
            <returns>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Contains(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Contains(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the targetFeature lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetFeature lies within the interior of the current
            shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.ContainsCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Overlaps(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.Overlaps(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature share some but not
            all points in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.OverlapsCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsTopologicallyEqual(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsTopologicallyEqual(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.IsTopologicallyEqualCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetFeature">
            <summary>
            Get a corresponding feature which has the same Id and BaseShape as the current
            shape.
            </summary>
            <returns>
            The feature with the same Id and BaseShape as the current BaseShape, and with empty
            columnValues in it.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetFeature(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Get a corresponding feature which has the same Id and BaseShape as the current
            shape. Additionally, pass the specified columnValues into the returned feature.
            </summary>
            <returns>
            The feature with the same Id and BaseShape as the current BaseShape and with empty
            columnValues in it, substituted with the passed-in columnValues.
            </returns>
            <param name="columnValues">The columnValues will be passed into returning feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetCrossing(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing points with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.ScaleTo(ThinkGeo.MapSuite.Shapes.BaseShape,System.Double)">
            <summary>
            This method increases or decreases the size of the shape by the specified scale
            factor given in the parameter.
            </summary>
            <returns>
            This method is useful when you would like to increase or decrease the size of the shape.
            </returns>
            <returns>The new shape under new scale</returns>
            <remarks>It will call the instanced method ScaleTo internally.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Is you pass in the scale is not bigger than zero, it will throw ArgumentOutOfRangeException.</exception>
            <example>
            	<code lang="CS" title="C# sample" description="This code snippet shows how to use the ScaleTo method.">
            RectangleShape rectangleShape = new RectangleShape(-10, 10, 10, -10);
                        RectangleShape smallerShape = BaseShape.ScaleTo(rectangleShape, 0.5) as RectangleShape;
                        RectangleShape biggerShape = BaseShape.ScaleTo(rectangleShape, 2) as RectangleShape;
            </code>
            	<code lang="VB" title="VB sample" description="This code snippet shows how to use the ScaleTo method.">
            Dim rectangleShape As New RectangleShape(-10, 10, 10, -10)
                        Dim smallerShape As RectangleShape = TryCast(BaseShape.ScaleTo(rectangleShape, 0.5), RectangleShape)
                        Dim biggerShape As RectangleShape = TryCast(BaseShape.ScaleTo(rectangleShape, 2), RectangleShape)
            </code>
            </example>
            <param name="baseShape">Represents a shape which you want to resize</param>
            <param name="scale">Pepresents a value which scaleFactor to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.ScaleTo(System.Double)">
            <summary>
            This method increases or decreases the size of the shape by the specified scale
            factor given in the parameter.
            </summary>
            <returns>
            This method is useful when you would like to increase or decrease the size of the shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <example>
            	<code lang="CS" title="C# sample" description="This code snippet shows how to use the ScaleTo method.">
            RectangleShape rectangleShape = new RectangleShape(-10, 10, 10, -10);
            rectangleShape.ScaleTo(rectangleShape, 0.5);
            rectangleShape.ScaleTo(rectangleShape, 2);
            </code>
            	<code lang="VB" title="VB sample" description="This code snippet shows how to use the ScaleTo method.">
            Dim rectangleShape As New RectangleShape(-10, 10, 10, -10)
            rectangleShape.ScaleTo(rectangleShape, 0.5)
            rectangleShape.ScaleTo(rectangleShape, 2)
            </code>
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Is you pass in the scale is not bigger than zero, it will throw ArgumentOutOfRangeException.</exception>
            <param name="scale">Pepresents a value which scaleFactor to</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseShape.ScaleToCore(System.Double)">
            <summary>
            This method increases or decreases the size of the shape by the specified scale factor given in the
            parameter.
            </summary>
            <returns>
            This method is useful when you would like to increase or decrease the size of the shape.
            </returns>
            <remarks>
                This protected virtual method is called from the concrete public method
                ScaleTo. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method ScaleTo. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.
            </remarks>
            <param name="scale">Pepresents a value which scaleFactor to</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Is you pass in the scale is not bigger than zero, it will throw ArgumentOutOfRangeException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.LineBaseShape">
            <summary>
            This abstract class is the root of all line-based shapes, such as LineShape
            and MultilineShape.
            </summary>
            <remarks>
            	<para>This class is used as the base class for line shapes such as:<br/>
            		<br/>
                LineShape<br/>
                MultilineShape<br/>
            		<br/>
                It can be inherited from to create your own specialized line geometry. If you
                choose to do this, your new class must conform to one of the well-known text standard
                shapes in order for the base implementations to work properly.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.#ctor">
            <summary>This is the default constructor for AreaBaseShape.</summary>
            <remarks>This constructor simply calls the base constructor.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.GetLength(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the length of the line shape.</summary>
            <overloads>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </overloads>
            <returns>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </returns>
            <remarks>
            This is a useful method when you want to know the total length of a line-based
            shape. If the shape is a MultiLineShape, then the length is the sum of all of its
            lines.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the distance unit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.GetLengthCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the length of the line shape.</summary>
            <overloads>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </overloads>
            <returns>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </returns>
            <remarks>
            This is a useful method when you want to know the total length of a line-based
            shape. If the shape is a MultiLineShape, then the length is the sum of all of its
            lines.
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the distance unit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleUp(ThinkGeo.MapSuite.Shapes.LineBaseShape,System.Double)">
            <summary>
            This method returns a new shape that is increased by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceShape">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to increase the shape�s size.</param>
            <returns>a scaled line type shape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleUp(ThinkGeo.MapSuite.Shapes.Feature,System.Double)">
            <summary>
            This method returns a new feature that is increased by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the feature. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceLine">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to increase the shape�s size.</param>
            <returns>a scaled line type feature.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleUp(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleDown(ThinkGeo.MapSuite.Shapes.LineBaseShape,System.Double)">
            <summary>
            This method returns a new shape that is decreases by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceLineBaseShape">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to decrease the shape�s size.</param>
            <returns> a scaled down line type shape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleDown(ThinkGeo.MapSuite.Shapes.Feature,System.Double)">
            <summary>
            This method returns a new feature that is decreases by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the feature. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceLine">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to decrease the shape�s size.</param>
            <returns> a scaled down line type feature.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleDown(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ConvexHull">
            <summary>
            This method returns the convex hull of the shape defined as the smallest convex
            ring that contains all the points in the shape.
            </summary>
            <returns>
            This method returns a RingShape defined as the smallest convex ring that contains
            all the points in the shape.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example if you had a MultiPolygon which represented buildings in a campus you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes where each point may
            represent a certain type of person you are doing statistics on. With convex hull you
            can get an idea of the regions those points are located in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.ConvexHullCore">
            <summary>
            This method returns the convex hull of the shape defined as the smallest convex
            ring that contains all the points in the shape.
            </summary>
            <returns>
            This method returns a RingShape defined as the smallest convex ring that contains
            all the points in the shape.
            </returns>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.Simplify(ThinkGeo.MapSuite.Shapes.LineBaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <param name="targetShape">target shape which will be simplified.</param>
            <param name="targetShapeUnit">the geography unit of the target shape</param>
            <param name="toleranceUnit">the distance unit of tolerance</param>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid shapeUnit will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid toleranceUnit will thrown an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.Simplify(ThinkGeo.MapSuite.Shapes.LineBaseShape,System.Double,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <param name="targetShape">target shape which will be simplified.</param>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.Simplify(ThinkGeo.MapSuite.GeographyUnit,System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <param name="shapeUnit">the geography unit of the target shape</param>
            <param name="toleranceUnit">the distance unit of tolerance</param>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid shapeUnit will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid toleranceUnit will thrown an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.Simplify(System.Double,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.SimplifyCore(System.Double,ThinkGeo.MapSuite.Shapes.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.Union(ThinkGeo.MapSuite.Shapes.LineBaseShape)">
            <summary>
            Calculates a new geometry that contains all the points in this LineBaseShape and input LineBaseShape
            </summary>
            <param name="targetShape">The target LineBasheShape with which to compute the union</param>
            <returns>A set combining the points of this LineBaseShape and the points of input LineBaseShape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.Union(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.LineBaseShape})">
            <summary>
            Calculates a new geometry that contains all the points in this LineBaseShape and input LineBaseShape set.
            </summary>
            <param name="lineBaseShape">The target LineBasheShape set with which to compute the union</param>
            <returns>A set combining the points of this LineBaseShape and the points of input LineBaseShape set.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineBaseShape.UnionCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.LineBaseShape})">
            <summary>
            The protected virtual method used by "Union" that you can overwrite to implement your own logic.
            </summary>
            <param name="lineBaseShapes">The target LineBasheShape set with which to compute the union</param>
            <returns>A set combining the points of this LineBaseShape and the points of input LineBaseShape set.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PointBaseShape">
            <summary>
            This abstract class is the root of all point-based shapes, such as PointShape
            and MultiPointShape.
            </summary>
            <remarks>
            	<para>This class is used as the base class for point shapes such as:<br/>
            		<br/>
                PointShape<br/>
                MultiPointShape<br/>
            		<br/>
                It can be inherited from to create your own specialized point geometry. If you
                choose to do this, your new class must conform to one of the well-known text standard
                shapes in order for the base implementations to work properly.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointBaseShape.#ctor">
            <summary>This is the default constructor for PointBaseShape.</summary>
            <remarks>This constructor simply calls the base constructor.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.AreaUnit">
            <summary>Units describing various ways you can measure areas. </summary>
            <remarks>
            	<para>Area units are most commonly used when calling APIs that measure areas.
                Regardless of the unit of measure your shapes are in, many of our APIs allow you to
                specify what unit of measure you want the result of the method call to be in. For
                example, you may have a PolygonShape whose points are in decimal degrees; however, you
                want to know the area in square miles. This is easy to accomplish. Simply call the GetArea
                method on the PolygonShape, passing in the first parameter of decimal degrees (which
                defines what unit the shape is in), and then square miles as the area unit you would
                like the result to be in.</para>
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.Acres">
            <summary>Acres</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.SquareMeters">
            <summary>Square Meters</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.Hectares">
            <summary>Hectares</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.SquareFeet">
            <summary>Square Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.SquareKilometers">
            <summary>Square Kilometers</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.SquareMiles">
            <summary>Square Miles</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.SquareUsSurveyFeet">
            <summary>Square US Survey Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.AreaUnit.SquareYards">
            <summary>Square Yards</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.BufferCapType">
            <summary>
            This class represents various ways a buffer operation can cap the objects
            buffered.
            </summary>
            <remarks>
            Buffered shapes can be computed with different line-end buffer cap styles. The
            buffer cap style determines how the line-work for the buffer polygon is constructed at
            the ends of lines.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.BufferCapType.Round">
            <summary>End caps are rounded at the line ends. </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.BufferCapType.Square">
            <summary>End caps are truncated flat at the line ends.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.BufferCapType.Butt">
            <summary>End caps are squared off at the buffer distance beyond the line ends.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Conversion">
            <summary>
            This static class provides a conversion method to go to and from different
            units.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Conversion.ConvertMeasureUnits(System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method converts from one unit of measure to another.</summary>
            <returns>The return length size, represented in the unit specified in the toUnit parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <overloads>This overload handles length units.</overloads>
            <remarks>None</remarks>
            <param name="amount">The total length size, represented in the unit specified in the fromUnit parameter.</param>
            <param name="fromUnit">The unit of measure for the length in the Amount parameter.</param>
            <param name="toUnit">The unit of measure for the result.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Conversion.ConvertMeasureUnits(System.Double,ThinkGeo.MapSuite.Shapes.AreaUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>This method converts from one unit of measure to another.</summary>
            <returns>The return area size, represented in the unit specified in the toUnit parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <overloads>This overload handles area units.</overloads>
            <remarks>None</remarks>
            <param name="amount">The total area size, represented in the unit specified in the fromUnit parameter.</param>
            <param name="fromUnit">The unit of measure for the area in the Amount parameter.</param>
            <param name="toUnit">The unit of measure for the result.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Conversion.ConvertGeographyUnitToDistanceUnit(ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a DistanceUnit that has been converted from a GeographyUnit.
            </summary>
            <returns>This method returns a DistanceUnit that has been converted from a GeographyUnit.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a GeographyUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <remarks>None</remarks>
            <param name="unit">The GeographyUnit you want to convert.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper">
            <summary>
            This class contains a static routine for converting between degree-minute-second
            measurement and decimal degree measurement. In essense, it is a routine for converting from
            a non-decimal degree unit to decimal degree unit distance.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.Feature,System.Int32)">
            <summary>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </summary>
            <returns>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </returns>
            <overloads>This overload allows you to pass in a point shape to be converted.</overloads>
            <param name="point">The feature you want to convert.</param>
            <param name="decimals">Number of decimals for the Minutes value</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </summary>
            <returns>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </returns>
            <overloads>This overload allows you to pass in a point shape to be converted.</overloads>
            <param name="point">The point you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </summary>
            <returns>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </returns>
            <overloads>This overload allows you to pass in a point shape to be converted.</overloads>
            <param name="point">The PointShape you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.PointShape,System.Int32)">
            <summary>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </summary>
            <returns>
            This method returns a string representation in degrees and minutes from
            a decimal degree point.
            </returns>
            <overloads>This overload allows you to pass in a point shape to be converted.</overloads>
            <param name="point">The PointShape you want to convert.</param>
            <param name="decimals">Number of decimals for the Minutes value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesStringFromDecimalDegree(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesStringFromDecimalDegree(System.Double,System.Int32)" -->
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsFromDecimalDegree(System.Double)">
            <summary>
            This method returns a degrees, minutes and seconds structure from a decimal degree
            value.
            </summary>
            <remarks>The method allows you pass in a decimal degree number and return the degree, minute, second as variables
            passed in on the method call.</remarks>
            <returns>
            This method returns a degrees, minutes and seconds structure from a decimal degree
            value.
            </returns>
            <param name="decimalDegreesValue">The decimal degree value you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegree(System.Double)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <remarks>
            Example: If you enter 75.358 as the number of decimal degrees, the result would be 75
            degrees, 21 minutes, 28 seconds. Thus, the return string would be 75?21' 28".
            </remarks>
            <returns>
            This method returns a string representation in degrees, minutes and seconds
            from a decimal degree value.
            </returns>
            <overloads>This overload allows you to specify the decimal degree value.</overloads>
            <param name="decimalDegreesValue">The number of decimal degrees to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegree(System.Double,System.Int32)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value and a specified precision.
            </summary>
            <remarks>Example: If you enter 75.358 as the number of decimal degree and 12 as decimals, the result would be
            75 degrees, 21 minutes, 28.80000000015 seconds. Thus, the return string would be 75?21' 28.80000000015".</remarks>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to specify the decimal degree value along with the
            precision of the returned value.
            </overloads>
            <param name="decimalDegreesValue">The number of decimal degree to convert.</param>
            <param name="decimals">The number of float decision for the second.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <remarks>Passing in a point will return the point's location represented in degrees,
            minutes, and seconds. For example, if the point's location in decimal degrees is (75.358, 36.345),
            the actual returned string would be "75?21' 29''E  36?20' 42''N".</remarks>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>This overload allows you to pass in a point shape to be converted.</overloads>
            <param name="pointShape">The point you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.PointShape,System.Int32)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to pass in a point shape to be converted, along with the
            precision of the returned value.
            </overloads>
            <remarks>None</remarks>
            <param name="pointShape">The point of decimal degree to convert.</param>
            <param name="decimals">The number of decimal degree to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.Feature,System.Int32)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to pass in a feature to be converted, along with the
            precision of the returned value.
            </overloads>
            <remarks>None</remarks>
            <param name="point">The feature whose decimal degrees to convert.</param>
            <param name="decimalPlaces">The number of decimal degree to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to pass in a feature to be converted, along with the
            precision of the returned value.
            </overloads>
            <remarks>None</remarks>
            <param name="point">The feature whose decimal degrees to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDecimalDegreeFromDegreesMinutesSeconds(System.String)">
            <summary>
            This method returns a decimal degree value based on a string containing degrees,
            minutes, and seconds.
            </summary>
            <remarks>If you pass in "75?21' 28''" as a string, then the result will be 75.35777777784.</remarks>
            <returns>
            This method returns a decimal degree value based on a string containing degrees,
            minutes, and seconds.
            </returns>
            <param name="degreesMinutesSeconds">This parameter represents the degrees, minutes and seconds in a string.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDecimalDegreeFromDegreesMinutesSeconds(ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds)">
            <summary>
            This method returns a decimal degree value based on a degree, minute and second
            structure.
            </summary>
            <remarks>If you pass in 75, 21 and 28, the result passed back will be 75.2577777778. </remarks>
            <returns>
            This method returns a decimal degree value based on a degree, minute and second
            structure.
            </returns>
            <param name="degreesMinutesSeconds">This structure represents the degrees, minutes and seconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDecimalDegreeFromDegreesMinutesSeconds(System.Int32,System.Int32,System.Double)">
            <summary>
            This method returns a decimal degree value based on a set of degrees, minutes, and
            seconds.
            </summary>
            <returns>
            This method returns a decimal degree value based on a set of degrees, minutes, and
            seconds.
            </returns>
            <remarks>
            If you pass in 75, 21 and 28, the result passed back will be
            75.2577777778.
            </remarks>
            <param name="degrees">
            This parameter represents the degree component of the degrees, minutes and
            seconds.
            </param>
            <param name="minutes">
            This parameter represents the minute component of the degrees, minutes and
            seconds.
            </param>
            <param name="seconds">
            This parameter represents the second component of the degrees, minutes and
            seconds.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDistanceFromDecimalDegrees(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the distance between two decimal degree points.</summary>
            <returns>
            This method returns the distance between two decimal degree points in the unit specified by
            the returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in two point shapes.</overloads>
            <param name="fromPoint">The point shape you will measure from.</param>
            <param name="toPoint">The point shape you will measure to.</param>
            <param name="returningUnit">The unit you would like your results back in, such as miles or kilometers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDistanceFromDecimalDegrees(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the distance between two decimal degree points.</summary>
            <returns>
            This method returns the distance between two decimal degree points in the unit specified by
            the returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in two point shapes.</overloads>
            <param name="fromPointFeature">The feature you will measure from.</param>
            <param name="toPointFeature">The feature you will measure to.</param>
            <param name="returningUnit">The unit you would like your results back in, such as miles or kilometers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetDistanceFromDecimalDegrees(System.Double,System.Double,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the distance between two decimal degree points.</summary>
            <returns>
            This method returns the distance between two decimal degree points in the unit specified by
            the returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to pass in the from and to latitude and longitude
            values.
            </overloads>
            <param name="fromLongitude">This is the from longitude value.</param>
            <param name="fromLatitude">This is the from latitude value.</param>
            <param name="toLongitude">This is the to longitude value.</param>
            <param name="toLatitude">This is the to latitude value.</param>
            <param name="returningUnit">
            This is the distance unit you would like to use in the return value. For example,
            if you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetLongitudeDifferenceFromDistance(System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double)">
            <summary>
            Calculate the amount of longitude change given a certain distance and latitude.
            </summary>
            <returns>Double representing the distance.</returns>
            <remarks>None</remarks>
            <param name="distance">The distance over which you would like to know the change in longitude.</param>
            <param name="distanceUnit">The unit the distance is in, such as miles or kilometers.</param>
            <param name="latitude">The latitude on the globe that the distance is measured at.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.GetLatitudeDifferenceFromDistance(System.Double,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            Calculate the amount of longitude change given a certain distance and longitude.
            </summary>
            <returns>Double representing the distance.</returns>
            <remarks>None</remarks>
            <param name="distance">The distance over which you would like to know the change in longitude.</param>
            <param name="distanceUnit">The unit the distance is in, such as miles or kilometers.</param>
            <param name="longitude">The longitude on the globe that the distance is measured at.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.ConvertToMgrs(System.Double,System.Double)">
            <summary>
            Convert the input latitude and longitude to MGRS string
            </summary>
            <param name="longitude">Longitude coordinate.</param>
            <param name="latitude">Latitude coordinate.</param>
            <returns>The MGRS corresponding to input latitude and longitude.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DecimalDegreesHelper.ConvertFromMgrs(System.String)">
            <summary>
            Convert the MGRS string to latitude and longitude
            </summary>
            <param name="mgrs">MGRS string</param>
            <returns>The converted coordinate.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds">
            <summary>This structure represents a degrees, minutes and seconds value.</summary>
            <remarks>
            This structure is used in many places to represent decimal degree numbers as
            degrees, minutes and seconds.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            This constructor allows you to create an instance of the class by specifying the
            degree, minute and second values.
            </summary>
            <remarks>None</remarks>
            <param name="degrees">This parameter represents the degree portion of the structure.</param>
            <param name="minutes">This parameter represents the minute portion of the structure.</param>
            <param name="seconds">This parameter represents the second portion of the structure.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.Degrees">
            <summary>This property returns the degrees portion of the structure.</summary>
            <decimalDegreesValue>This property returns the degrees portion of the structure.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.Minutes">
            <summary>This property returns the minutes portion of the structure.</summary>
            <decimalDegreesValue>This property returns the minutes portion of the structure.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.Seconds">
            <summary>This property returns the seconds portion of the structure.</summary>
            <decimalDegreesValue>This property returns the seconds portion of the structure.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.GetHashCode">
            <summary>
            Serves as hash function for the particular type.
            </summary>
            <returns>The hash code for this particular type.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.Equals(System.Object)">
            <summary>Compares current DegreesMinutesSeconds with a passing object.</summary>
            <returns>
            	<para>True if the passing object satisfies the following two conditions:</para>
            	<para>1) The object is of DegreesMinutesSeconds type.</para>
            	<para>2) The Degrees, Minutes and Seconds of both DegreesMinutesSeconds should be the
                same.</para>
            	<para>If both conditions are not met, will return false.</para>
            </returns>
            <param name="obj">
            The passing object which will be used to compare with current
            DegreesMinutesSeconds.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.Add(ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds)">
             <summary>
             Add two DegreesMinutsSeconds together and return back a summary of the
             two.
             </summary>
             <returns>The summary of the two DegreesMinutesSeconds.</returns>
             <example>
             	<code lang="CS" title="C# Sample">
             DegreesMinutesSeconds dms1 = new DegreesMinutesSeconds(15, 21, 19.1);
             DegreesMinutesSeconds dms2 = new DegreesMinutesSeconds(12, 43, 12);
            
             DegreesMinutesSeconds dms3 = dms1.Add(dms2);
             // The return value should be:28d 4' 31.1''
             </code>
             	<code lang="VB" title="VB Sample">
             Dim dms1 As New DegreesMinutesSeconds(15, 21, 19.1)
             Dim dms2 As New DegreesMinutesSeconds(12, 43, 12)
            
             Dim dms3 As DegreesMinutesSeconds = dms1.Add(dms2)
             ' The return value should be:28d 4' 31.1''
             </code>
             </example>
             <param name="targetDegreesMinutesSeconds">The target DegreesMinutesSeconds to be added together.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.op_Addition(ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds,ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds)">
             <summary>
             Operation + overloads for DegreesMinutesSeconds.Sum of two
             DegreesMinutesSeconds.
             </summary>
             <returns>The summary of the two DegreesMinutesSeconds.</returns>
             <example>
             	<code lang="CS" title="C# Sample">
             DegreesMinutesSeconds dms1 = new DegreesMinutesSeconds(15, 21, 19.1);
             DegreesMinutesSeconds dms2 = new DegreesMinutesSeconds(12, 43, 12);
            
             DegreesMinutesSeconds dms3 = dms1 + dms2;
             // The return value should be:28d 4' 31.1''
             </code>
             	<code lang="VB" title="VB Sample">
             Dim dms1 As New DegreesMinutesSeconds(15, 21, 19.1)
             Dim dms2 As New DegreesMinutesSeconds(12, 43, 12)
            
             Dim dms3 As DegreesMinutesSeconds = dms1 + dms2
             ' The return value should be:28d 4' 31.1''
             </code>
             </example>
             <param name="degreesMinutesSeconds1">The first target DegreesMinutesSeconds.</param>
             <param name="degreesMinutesSeconds2">The second target DegreesMinutesSeconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.op_Equality(ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds,ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds)">
            <summary>
            Operation == overloads for DegreesMinutesSeconds.Sum of two
            DegreesMinutesSeconds.
            </summary>
            <returns>
            True if the two degreesMinutesSeconds are equal in their responding Degrees,
            Minutes, Seconds. Otherwise returns false.
            </returns>
            <param name="degreesMinutesSeconds1">The first target DegreesMinutesSeconds.</param>
            <param name="degreesMinutesSeconds2">The second target DegreesMinutesSeconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.op_Inequality(ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds,ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds)">
            <summary>
            Operation != overloads for DegreesMinutesSeconds.Sum of two
            DegreesMinutesSeconds.
            </summary>
            <returns>
            True if any of the two degreesMinutesSeconds are not equal in their
            responding Degrees, Minutes, Seconds. Otherwise returns false.
            </returns>
            <param name="degreesMinutesSeconds1">The first target DegreesMinutesSeconds.</param>
            <param name="degreesMinutesSeconds2">The second target DegreesMinutesSeconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.ToString">
            <summary>
            This method returns a formatted representation of the degrees, minutes and seconds
            value.
            </summary>
            <returns>
            This method returns a formatted representation of the degrees, minutes and seconds
            value.
            </returns>
            <remarks>The value will be formatted in the standard string format: 75º 21' 28"</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DegreesMinutesSeconds.GetFormattedString(System.Int32)">
            <summary>This method returns a formatted representation of the degrees, minutes and seconds
            value that has been rounded to the specified decimals.</summary>
            <param name="decimals">
            The target decimals that the degrees, minutes, seconds value will be rounded
            to.
            </param>
            <returns>
            This method returns a formatted representation of the degrees, minutes and seconds
            value.
            </returns>
            <remarks>The value will be formatted in the standard string format. For example, 75º 21' 2.1235" (when the decimals parameter is set to 4).</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.DistanceUnit">
            <remarks>
            Length units are most commonly used when calling APIs that measure lengths.
            Regardless of the unit of measure your shapes are in, many of our APIs allow you to
            specify what unit of measure you want the result of the method call to be in. For
            example, you may have a LineShape whose points are in decimal degrees; however, you want
            to know the length in miles. This is easy to accomplish. Simply call the GetLength method on the
            LineShape, passing in the first parameter of decimal degrees (which defines what unit
            the shape is in), and then miles as the length unit you would like the result to be in.
            </remarks>
            <summary>Units describing various ways you can measure lengths.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Meter">
            <summary>Meter</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Feet">
            <summary>Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Kilometer">
            <summary>Kilometer</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Mile">
            <summary>Mile</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.UsSurveyFeet">
            <summary>US Survey Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Yard">
            <summary>Yard</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.NauticalMile">
            <summary>Nauticalmile</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Inch">
            <summary>Inch</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Link">
            <summary>Link</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Chain">
            <summary>Chain</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Pole">
            <summary>Pole</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Rod">
            <summary>Rod</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Furlong">
            <summary>Furlong</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Vara">
            <summary>Vara</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.DistanceUnit.Arpent">
            <summary>Arpent</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.DrawingRectangle">
            <summary>This structure represents the drawing of a rectangle in screen coordinates.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This method represents the constructor that should be used to create the
            structure.
            </summary>
            <example>
            None
            </example>
            <param name="centerX">This parameter represents the center horizontal value of the rectangle.</param>
            <param name="centerY">This parameter represents the center vertical value of the rectangle.</param>
            <param name="width">This parameter represents the width of the rectangle.</param>
            <param name="height">This parameter represents the height of the rectangle.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangle.CenterX">
            <summary>This parameter represents the center horizontal value of the rectangle.</summary>
            <value>This parameter returns the center horizontal value of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangle.CenterY">
            <summary>This parameter represents the center vertical value of the rectangle.</summary>
            <value>This parameter returns the center vertical value of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangle.Width">
            <summary>This parameter returns the width of the rectangle.</summary>
            <value>This parameter returns the width of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangle.Height">
            <summary>This parameter returns the height of the rectangle.</summary>
            <value>This parameter returns the height of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangle.op_Equality(ThinkGeo.MapSuite.Shapes.DrawingRectangle,ThinkGeo.MapSuite.Shapes.DrawingRectangle)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="rectangleF1">This parameter represents the first DrawingRectangleF to compare.</param>
            <param name="rectangleF2">This parameter represents the second DrawingRectangleF to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangle.op_Inequality(ThinkGeo.MapSuite.Shapes.DrawingRectangle,ThinkGeo.MapSuite.Shapes.DrawingRectangle)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="rectangleF1">This parameter represents the first DrawingRectangleF to compare.</param>
            <param name="rectangleF2">This parameter represents the second DrawingRectangleF to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangle.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangle.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.DrawingRectangleF">
            <summary>This structure represents the drawing of a rectangle in screen coordinates.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            This method represents the constructor that should be used to create the
            structure.
            </summary>
            <example>
            None
            </example>
            <param name="centerX">This parameter represents the center horizontal value of the rectangle.</param>
            <param name="centerY">This parameter represents the center vertical value of the rectangle.</param>
            <param name="width">This parameter represents the width of the rectangle.</param>
            <param name="height">This parameter represents the height of the rectangle.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.CenterX">
            <summary>This parameter represents the center horizontal value of the rectangle.</summary>
            <value>This parameter returns the center horizontal value of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.CenterY">
            <summary>This parameter represents the center vertical value of the rectangle.</summary>
            <value>This parameter returns the center vertical value of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.Width">
            <summary>This parameter returns the width of the rectangle.</summary>
            <value>This parameter returns the width of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.Height">
            <summary>This parameter returns the height of the rectangle.</summary>
            <value>This parameter returns the height of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.op_Equality(ThinkGeo.MapSuite.Shapes.DrawingRectangleF,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="rectangleF1">This parameter represents the first DrawingRectangleF to compare.</param>
            <param name="rectangleF2">This parameter represents the second DrawingRectangleF to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.op_Inequality(ThinkGeo.MapSuite.Shapes.DrawingRectangleF,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="rectangleF1">This parameter represents the first DrawingRectangleF to compare.</param>
            <param name="rectangleF2">This parameter represents the second DrawingRectangleF to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DrawingRectangleF.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.EllipseShape">
            <summary>
            This class represents an ellipse that is defined with a center point,
            a height and a width.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor">
            <overloads>This overload creates the EllipseShape with no area.</overloads>
            <summary>This constructor creates the EllipseShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.PointShape,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the radius in the
            shape's unit. This overload will create a circle.
            </overloads>
            <remarks>Using this overload will create a circle.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="radius">This parameter allows you to set the radius of the EllipseShape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.Feature,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point feature along with the radius in the
            shape's unit. This overload will create a circle.
            </overloads>
            <remarks>Using this overload will create a circle.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="centerPointFeature">This parameter is the center PointFeature for the EllipseShape.</param>
            <param name="radius">This parameter allows you to set the radius of the EllipseShape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.PointShape,System.Double,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the horizontal and
            vertical radius in the unit of the shape.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit of the shape.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit of the shape.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.Feature,System.Double,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point feature along with the horizontal and
            vertical radius in the unit of the shape.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="centerPointFeature">This parameter is the center PointFeature for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit of the shape.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit of the shape.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>This constructor allows you to create the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to create the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>This constructor allows you to create the shape from well-known binary.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.PointShape,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <remarks>This overload will create a circle.</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the radius in the
            unit specified by the unitOfRadius parameter. This overload will create a
            circle.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="radius">
            This parameter allows you to set the radius of the EllipseShape in the unit
            specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.Feature,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <remarks>This overload will create a circle.</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point feature along with the radius in the
            unit specified by the unitOfRadius parameter. This overload will create a
            circle.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="centerPointFeature">This parameter is the center Point Feature for the EllipseShape.</param>
            <param name="radius">
            This parameter allows you to set the radius of the EllipseShape in the unit
            specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.PointShape,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <remarks>None</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the horizontal and
            vertical radius in the unit specified by the unitOfRadius parameter.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.#ctor(ThinkGeo.MapSuite.Shapes.Feature,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <remarks>None</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the horizontal and
            vertical radius in the unit specified by the unitOfRadius parameter.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="centerPointFeature">This parameter is the center Point Feature for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.EllipseShape.Width">
            <summary>
            This property returns the width of the EllipseShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the width of the EllipseShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.SetWidthByUnit(System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method allows you to set the width of the EllipseShape in the unit specified in the
            unitOfWidth parameter.
            </summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid width which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfWidth that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="newWidth">This parameter is the newWidth of the ellipse shape.</param>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="unitOfWidth">
            This is the unit you would like to use as the setting value. For example, if you
            select miles as your unitOfWidth, then the distance will be set in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetWidthByUnit(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the width of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </summary>
            <returns>
            This method returns the width of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="returningUnit">
            This is the unit you would like to use for the return value. For example, if you
            select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.EllipseShape.Height">
            <summary>
            This property returns the height of the EllipseShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the height of the EllipseShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.SetHeightByUnit(System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method allows you to set the height of the EllipseShape in the unit specified in the
            unitOfWidth.
            </summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid height which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfHeight that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="newHeight"> This parameter is the newHeight of the ellipse shape.</param>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="unitOfHeight">
            This is the unit you would like to use for the setting value. For example, if you
            select miles as your unitOfHeight, then the distance will be set in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetHeightByUnit(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the height of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </summary>
            <returns>
            This method returns the height of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="returningUnit">
            This is the unit you would like to use for the return value. For example, if you
            select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.EllipseShape.Center">
            <summary>
            This property allows you to get or set the center PointShape of the
            EllipseShape.
            </summary>
            <value>
            This property allows you to get or set the center PointShape of the
            EllipseShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.ToPolygon">
            <summary>This method returns the current shape as a PolygonShape.</summary>
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert this non GIS standard shape to a GIS
            standard shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.ToPolygon(System.Int32)">
            <summary>This method returns the current shape as a PolygonShape.</summary>
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert a GIS non-standard shape to a GIS
            standard shape.
            </remarks>
            <param name="vertexCountInQuarter">This parameter specifies how many points will make up each quarter of the ellipse.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid vertexCountInQuarter which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetTangents(ThinkGeo.MapSuite.Shapes.EllipseShape)">
            <summary>
            This method returns the tangent points of the current ellipse in relation to the
            target ellipse you specify.
            </summary>
            <returns>
            This method returns the tangent points of the current ellipse in relation to the
            target ellipse you specify.
            </returns>
            <remarks>
            This operation is useful for finding the corridor between two
            ellipses. It would be handy in a buffering type of scenario.
            </remarks>
            <param name="targetEllipse">
            This parameter represents the other ellipse you wish to find the tangent points
            to.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetPerimeterCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, which is defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            	<para>You would use this method to find the distance around the area shape.</para>
            	<para><br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use for the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetAreaCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape, which is defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            	<para>You would use this method to find the area inside of a shape.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use for the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is useful when you would like to increase the size of the shape.
                Note that a larger percentage will scale the shape up faster, as you are applying the
                operation multiple times. There is also a ScaleDown method that will shrink the
                shape.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take a significant amount of time (the larger the objects, the more time the operation will take).</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on an X
                and Y offset distance. It is important to note that with this overload the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of one and a Y
                offset of one, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measurement for the move.
                For example, if you select miles as your distanceUnit, then the xOffsetDistance and yOffsetDistance
                will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            direction in degrees and distance.
            </summary>
            <overloads>
            In this overload, the distance unit is based on a DistanceUnit you specify in the
            distanceUnit parameter, regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on
                angleInDegrees and distance parameter. It is important to note that with this
                overload the distance units are based on the distanceUnit parameter. For
                example, if your shape is in decimal degrees and you call this method with a
                distanceUnit in miles, you're going to move this shape a number of miles based on
                the distance and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape with zero being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographicUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measurement for the move. For
            example, if you select miles as your distanceUnit, then the distance will be calculated
            in miles.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.EllipseShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <value>This property specifies whether the shape can be rotated.</value>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape by a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can acheive in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further away from
                the center will make the circular area larger.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the point of the current shape that is closest to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method returns point of the current shape that is closest to the target
                shape. It is often the case that the point returned is not a point of the object
                itself. An example would be a line with two points that are far apart from each other. If
                you set the targetShape to be a point midway between the points but a short
                distance away, the method would return a point that is on the line, but not one of the two
                points that make up the line.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit specified in the distanceUnit parameter.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            	<para>In this method, we compute the closest distance between two shapes. The
                returned unit will be in the unit of distance specified in the distanceUnit parameter.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the return value. For example,
            if you select miles as your distanceUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetWellKnownTextCore(System.Int32)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a stringthat represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or
                when you simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We also have methods that work with well-known binary.
                Below are some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid vertexCountInQuarter which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="vertexCountInQuarter">
            This parameter specifies how many points will make up each quarter of the
            ellipse.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or
                when you simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We also have methods that work with well-known binary.
                Below are some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.WkbByteOrder,System.Int32)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            	<para>This method returns a byte array that represents the shape in well known
                binary. Well-known binary allows you to describe geometries as a binary array.
                Well-known binary is useful when you want to save a geometry in an efficient format
                using as little space as possible. An alternative to well-known binary is well-known
                text, which is a textual representation of a geometry object. We also have methods
                that work with well-known text.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid vertexCountInQuarter which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
            <param name="vertexCountInQuarter">
            This parameter specifies how many points will make up each quarter of the
            ellipse.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            	<para>This method returns a byte array that represents the shape in well known
                binary. Well-known binary allows you to describe geometries as a binary array.
                Well-known binary is useful when you want to save a geometry in an efficient format
                using as little space as possible. An alternative to well-known binary is well-known
                text, which is a textual representation of a geometry object. We also have methods
                that work with well-known text.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            	<para>We use this method, with the simple enumeration, internally before doing any kind
                of other methods on the shape. In this way, we are able to verify the integrity of the
                shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
                you to call this method with the advanced ShapeValidationMode. One thing to consider is
                that for complex polygon shapes this operation could take some time, which is why we
                only run the basic, faster test. If you are dealing with polygon shapes that are
                suspect, we suggest you run the advanced test.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.ContainsCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns whether the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns whether the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.IntersectsCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns whether the current shape and the targetShape have at least one
            point in common.
            </summary>
            <returns>
            This method returns whether the current shape and the targetShape have at least one
            point in common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.EllipseShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points of the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points of the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Feature">
            <summary>
            	<para>The class Feature is the basic unit of which a FeatureSource is composed. A
                FeatureSource can be taken from a collection of Features stored in a ShapeFile,
                SQL Server 2008, Oracle, etc.</para>
            	<para>A Feature is the basic data unit structure which is comprised of IDs that mark the
                identification of the Feature, a shape and a collection of data.</para>
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This method allows you to pass in a BaseShape to construct your Feature.</overloads>
            <returns>None</returns>
            <remarks>
            When you create the Feature, specify the ID of the BaseShape you want to use as a basis.
            </remarks>
            <param name="baseShape">
            This parameter represents the base shape you wish to use as the basis of the new
            Feature.
            </param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Byte[])">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload allows you to create a feature using well-known binary.</overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to create a feature using well-known binary. The Id for
            this Feature will be a random GUID.
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Byte[],System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create a feature using well-known binary and
            specify the Id.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to create a feature using well-known binary and
            specify the Id.
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used for the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload allows you to create a feature using well-known text.</overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to create a feature using well-known text. The Id for
            the Feature will be a random GUID.
            </remarks>
            <param name="wellKnownText">This parameter is the well-known text used to create the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.String,System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known text and specify
            the Id.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known text and specify
            the Id.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownText">This parameter is the well-known text used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(ThinkGeo.MapSuite.Shapes.BaseShape,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from a baseShape and specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from a baseShape and specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="baseShape">This parameter is the baseShape used to create the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known text and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known text and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownText">This parameter is the well-known text used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Byte[],System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Byte[],System.String,System.Collections.Generic.IEnumerable{System.String},System.Object)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Byte[],System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point Feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature easily.</remarks>
            <param name="vertex">
            This parameter is the x &amp; y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be a random GUID.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(ThinkGeo.MapSuite.Shapes.Vertex,System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point Feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature and specify the Id.</remarks>
            <param name="vertex">
            This parameter is the x &amp; y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be the value you pass in through the id parameter.
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(ThinkGeo.MapSuite.Shapes.Vertex,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point Feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature and specify the Id as well as the column values.</remarks>
            <param name="vertex">
            This parameter is the x &amp; y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be the value you pass in through the id parameter.
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Double,System.Double)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature based on x and y coordinates.</remarks>
            <param name="x">
            This parameter is the x decimalDegreesValue pair used to make the point. The Id for the
            Feature will be a random GUID.
            </param>
            <param name="y">
            This parameter is the y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be a random GUID.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Double,System.Double,System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature based on x and y coordinates and specify the Id.</remarks>
            <param name="x">
            This parameter is the x decimalDegreesValue pair used to make the point.
            </param>
            <param name="y">
            This parameter is the y decimalDegreesValue pair used to make the point.
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.#ctor(System.Double,System.Double,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature based on x and y coordinates and specify both the Id and the column values.</remarks>
            <param name="x">
            This parameter is the x decimalDegreesValue pair used to make the point.
            </param>
            <param name="y">
            This parameter is the y decimalDegreesValue pair used to make the point.
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature. Each string </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetWellKnownBinary">
            <summary>This method returns the well-known binary that represents the Feature.</summary>
            <returns>This method returns the well-known binary that represents the Feature.</returns>
            <remarks>
            This will return a copy of the well-known binary that represents the
            Feature.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the feature in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the feature in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the feature in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies if the byte order is big- or little-endian.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Feature.Id">
            <summary>This property gets the Id for the Feature.</summary>
            <decimalDegreesValue>This property gets the Id for the Feature.</decimalDegreesValue>
            <remarks>
            The Id is a string that represents the unique identifier for this Feature. If the
            feature is returned from a FeatureSource, the Id will be the unique field
            descriptor used by the FeatureSource. For Shape Files this may be an integer, but for
            spatial databases the Id may be a GUID.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Feature.Tag">
            <summary>
            The tag of the Feature.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Feature.ColumnValues">
            <summary>
            This property gets a dictionary of values to represent the column data related to
            this Feature.
            </summary>
            <decimalDegreesValue>
            This property gets a dictionary of values to represent the column data related to
            this Feature.
            </decimalDegreesValue>
            <remarks>
            This property holds the column data related to this Feature. You can find the
            values in the dictionary using the column name as the key. Most methods that query and
            return InternalFeatures allow you to specify which columns of data you want returned with the
            results. You can also freely add and modify the data, as it is simply an in-memory
            dictionary. Any values added, deleted or updated will have no effect unless the Feature
            is part of a transaction.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetWellKnownType">
            <summary>This method returns the well known type that represents the Feature.</summary>
            <returns>This method returns the well known type that represents the Feature.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetShape">
            <summary>This method returns the shape class that represents the Feature.</summary>
            <returns>This method returns the shape class that represents the Feature.</returns>
            <remarks>
            This method allows you to get a shape class from a Feature. Because the Feature stores
            the geometry for itself in well-known binary, it may take some time to generate a shape
            class if the geometry is complex.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetWellKnownText">
            <summary>This method returns the well-known text that represents the Feature.</summary>
            <returns>This method returns the well-known text that represents the Feature.</returns>
            <remarks>
            This method allows you to get the well-known text from a Feature. Because the Feature
            stores the geometry for itself in well-known binary, it may take some time to generate
            the text if the geometry is complex.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetWellKnownText(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this feature.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a stringthat represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetBoundingBox">
            <summary>This method returns the bounding box of the Feature.</summary>
            <returns>This method returns the bounding box of the Feature.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.CloneDeep(System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method clones the entire structure, creating a totally separate copy.</summary>
            <returns>
            This method returns a clone of the entire structure, creating a totally separate
            copy.
            </returns>
            <remarks>
            This method will return a complete copy of the Feature. As this is a deep clone,
            there are no shared references between the source and the copy.
            </remarks>
            <param name="returningColumnNames">
            This parameter represents the columnar data fields that you wish to include in the
            clone.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.CloneDeep(ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>This method clones the entire structure, creating a totally separate copy.</summary>
            <returns>
            This method returns a clone of the entire structure, creating a totally separate
            copy.
            </returns>
            <remarks>
            This method will return a complete copy of the Feature. As this is a deep clone,
            there are no shared references between the source and the copy.
            </remarks>
            <param name="returningColumnNamesType">
            This parameter allows you to select a type from the ReturningColumnsType that you wish
            to return with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.IsValid">
            <summary>This method returns the results of some simple validity tests on the Feature.</summary>
            <returns>This method returns the results of some simple validity tests on the Feature.</returns>
            <remarks>
            This method is used primarily to ensure that a Feature is valid. The reason is,
            since this is a structure, we cannot control the main constructor that allows you
            to create a Feature in an invalid state -- that state being one with no well-known binary at
            its core. If you use the constructure set provided, then the state should always be
            valid. This is a property you may want to check before you work with a Feature.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Union(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            This method returns the union of the specified features.
            </summary>
            <returns>
            The return type is a Feature that contains the set of all points that
            lie within the features you specified.<br/>
            	<br/>
            	<br/>
            	<br/>
            </returns>
            <remarks>
            This is useful for adding area features together to form a larger area
            feature.<br/>
            	<br/>
            	<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetFeatures, we will throw an ArgumentNullException.</exception>
            <param name="targetFeatures">The features you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Union(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the union of the current feature and the target feature, defined
            as the set of all points in the current feature or the target feature.
            </summary>
            <returns>
            The return type is a Feature that contains the set of all points which
            lie in the current feature or the target feature.
            </returns>
            <remarks>
            This is useful for adding area features together to form a larger area
            shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeature">The feature you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Buffer(System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this feature.
            </summary>
            <returns>
            The return type is a Feature that represents all of the points within a
            given distance from the feature.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a featureUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this feature. In this case, you will be using the rounded
            RoundedBufferCapStyle and the default 8 quadrant segments. The distance unit
            is determined by the distanceUnit argument.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <overloads>
            This overload allows you to specify the distance in your choice of unit and
            uses defaults for everything else.
            </overloads>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="featureUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Buffer(System.Double,System.Int32,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this feature.
            </summary>
            <returns>
            The return type is a Feature that represents all of the points within a
            given distance from the feature.
            </returns>
            <overloads>
            This overload allows you to specify the distance in your choice of unit,
            specify the number of quadrant segments and uses defaults for everything else.
            </overloads>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this feature. In this case, you will be using the rounded
            RoundedBufferCapStyle. The distance unit is determined by the distanceUnit
            argument.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number of quadrant segments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a featureUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">
            The quadrant segments are the number of points in each quarter circle. A good
            default is 8, but if you want smoother edges you can increase this number. The valid
            range for this number is from 3 to 100.
            </param>
            <param name="featureUnit">
            This is the geographic unit of the feature you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Buffer(System.Double,System.Int32,ThinkGeo.MapSuite.Shapes.BufferCapType,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this feature.
            </summary>
            <returns>
            The return type is a Feature that represents all of the points within a
            given distance from the feature.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a featureUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a bufferCapType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid quadrantSegments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this feature. In this case, you will be using the rounded
            RoundedBufferCapStyle and the default 8 quadrant segments. The distance unit
            is determined by the distanceUnit argument.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <overloads>
            This overload allows you to specify the distance in your choice of unit and
            uses defaults for everything else.
            </overloads>
            <param name="distance">
            The distance is the number of units to buffer the current feature. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">The number of quadrantSegments used in the buffer logic.</param>
            <param name="bufferCapType">The bufferCapType used in the buffer logic.</param>
            <param name="featureUnit">
            This is the geographic unit of the feature you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Contains(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the targetFeature lies within the interior of the current
            feature.
            </summary>
            <returns>
            This method returns if the targetFeature lies within the interior of the current
            feature.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Crosses(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current feature and the targetFeature share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current feature and the targetFeature share some but not
            all interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.IsWithin(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current feature lies within the interior of the
            targetFeature.
            </summary>
            <returns>
            This method returns if the current feature lies within the interior of the
            targetFeature.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Intersects(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current feature and the targetFeature have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current feature and the targetFeature have at least one
            point in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.IsDisjointed(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current feature and the targetFeature have no points in
            common.
            </summary>
            <returns>
            This method returns if the current feature and the targetFeature have no points in
            common.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The feature you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.IsTopologicallyEqual(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current feature and the targetFeature are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current feature and the targetFeature are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetfeature which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Overlaps(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns if the current feature and the targetFeature share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current feature and the targetFeature share some but not
            all points in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetFeature which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.Touches(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns of the current feature and the targetFeature have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns of the current feature and the targetFeature have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetFeature which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature which contains a shape that you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetIntersection(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the intersection of the current feature and the target feature,
            defined as the set of all points which lie in both the current feature and the target
            feature.
            </summary>
            <returns>
            The return type is a Feature that contains the set of all points which
            lie in both the current feature and the target feature.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feature you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetDifference(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns the difference between current feature and the specified feature, defined as the set of all
            points which lie in the current feature but not in the targetFeature.
            </summary>
            <returns>
            The return type is a Feature that is the set of all points which lie in
            the current feature but not in the target feature.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feture you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetConvexHull">
            <summary>
            This method returns the convex hull of the feature, defined as the smallest convex
            ring that contains all of the points in the feature.
            </summary>
            <returns>
            This method returns the convex hull of the feature, defined as the smallest convex
            ring that contains all of the points in the feature.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.IsGeometryValid">
            <summary>
            Using NTS to retrieve the geometry validation.
            </summary>
            <returns>returns True if valid.  Otherwise, for example in the case of self intersection, returns false.  The reason for being invalid can be found with GetInvalidReason()</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.ConvertToDataTable(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method is a static API to get information about a group of passed-in features with the specified
            returningColumns, in the format of a DataTable.
            </summary>
            <param name="features">This parameter specifies the target features.</param>
            <param name="columnNames">This parameter specifies the returning columnNames for the features.</param>
            <returns>A DateTable of information about those passed-in features and the returning columnNames.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Feature.GetShapeCore">
            <summary>This method returns the shape class that represents the Feature.</summary>
            <returns>This method returns the shape class that represents the Feature.</returns>
            <remarks>
            This method allows you to get a shape class from a Feature. Because the Feature stores
            the geometry for itself in well-known binary, it may take some time to generate a shape
            class if the geometry is complex.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LinkColumnValue.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LinkColumnValue.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LinkColumnValue.op_Equality(ThinkGeo.MapSuite.Shapes.LinkColumnValue,ThinkGeo.MapSuite.Shapes.LinkColumnValue)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to compare.</param>
            <param name="vertex2">This parameter represents the second vertex to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LinkColumnValue.op_Inequality(ThinkGeo.MapSuite.Shapes.LinkColumnValue,ThinkGeo.MapSuite.Shapes.LinkColumnValue)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to compare.</param>
            <param name="vertex2">This parameter represents the second vertex to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GeometryCollectionShape.#ctor">
            <overloads>This overload creates the GeometryCollectionShape without any shapes.</overloads>
            <summary>This constructor creates the GeometryCollectionShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GeometryCollectionShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape})">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in any baseShapes which are invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the baseShapes, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GeometryCollectionShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the GeometryCollectionShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GeometryCollectionShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the GeometryCollectionShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.LineShape">
            <summary>
            This class represents a LineShape, which is defined as a single line with two or
            more points.
            </summary>
            <remarks>
            The LineShape is one of the more commonly used shapes. Typically it is used for
            representing roads in GIS data files.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.#ctor">
            <overloads>This overload creates the LineShape without any points.</overloads>
            <summary>This constructor creates the LineShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Vertex})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the points, we will throw an ArgumentNullException.</exception>
            <overloads>This overload creates the LineShape with a vertex collection.</overloads>
            <summary>This constructor creates the LineShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.LineShape.Vertices">
            <summary>This property is the collection of points that make up the LineShape.</summary>
            <decimalDegreesValue>This property is the collection of points that make up the LineShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.ReversePoints">
            <summary>This method reverses the order of the points in the line.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.ReversePointsCore">
            <summary>This method reverses the order of the points in the line.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.IsClosed">
            <summary>
            This method determines whether the line is closed, meaning that the last point and
            first point are the same.
            </summary>
            <remarks>None</remarks>
            <returns>The return value indicating whether the line is closed.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.IsClosedCore">
            <summary>
            This method determines whether the line is closed, meaning that the last point and
            first point are the same.
            </summary>
            <remarks>None</remarks>
            <returns>The return value indicating whether the line is closed.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLengthCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the length of the LineShape.</summary>
            <overloads>
            This overload returns the length in the unit of your choice, based on
            returningUnit you specify.
            </overloads>
            <returns>
            This overload returns the length in the unit of your choice, based on
            returningUnit you specify.
            </returns>
            <remarks>
            This is a useful method when you want to know the total length of a line-based
            shape. If the shape is a MultiLineShape, then the length is the sum of all of its
            lines.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetPointOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Single)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex defined in the startingPoint
                parameter.</para>
            </summary>
            <returns>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex defined in the startingPoint
                parameter.</para>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>If you pass 100 or 0 as the percentage of the line, it will return either the
                first or last vertex, depending on the value of the startingPoint argument.</para>
            </remarks>
            <overloads>
            This overload allows you to pass a percentage determining how far you want to
            move along the line, as well as the option for starting from either the beginning or the end
            of the line.
            </overloads>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values are between 0
            and 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetPointOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </summary>
            <overloads>
            This overload allows you to pass a distance determining how far you want to move
            along the line using your unit of choice, as well as the option to start from
            the beginning or the end of the line.
            </overloads>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </returns>
            <remarks>
            	<para>Passing in a 0 distance will return either the first or last point on the
                line, depending upon the value of the startingPoint parameter.</para>
            </remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move in the unit
            specified by the distanceUnit parameter. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetPointOnALineCore(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </summary>
            <overloads>
            This overload allows you to pass a distance determining how far you want to move
            along the line using your unit of choice, as well as the option to start from
            the beginning or the end of the line.
            </overloads>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </returns>
            <remarks>
            	<para>Passing in a 0 distance will return either the first or last point on the
                line, depending on the value of the startingPoint parameter.</para>
            </remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move in the unit
            specified by the distanceUnit parameter. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Single,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point, starting percentage of the
            line and percentage of the line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingPercentageOfTheLine">
            This parameter defines the starting percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
            <param name="percentageOfTheLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from which you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from which you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point and another point.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="endPointShape">
            The BaseLineShape returned will be between the startingPoint and the endPointShape
            specified in this parameter.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass in two points to get a BaseLineShape from the original LineShape.
            </overloads>
            <returns>
            This method returns a BaseLineShape based on a start PointShape and an end PointShape.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null startPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startPointShape">
            The startPointShape defines where you will start to get the line. If it does not stand on this
            LineShape, the closest point on the LineShape will be the start PointShape.
            </param>
            <param name="endPointShape">
            The endPointShape defines where you will stop getting the line. If it does not stand on this
            LineShape, the closest point on the LineShape will be the end PointShape.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetSublinePercentage(ThinkGeo.MapSuite.Shapes.PointShape,System.Double)">
            <summary>
            Calculate the percentage of pointShape is along the line.
            </summary>
            <param name="sublineEndpoint"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetPointPosition(ThinkGeo.MapSuite.Shapes.PointShape,System.Double)">
            <summary>
            Calculate the topology relationship between point and line.
            </summary>
            <param name="pointShape"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            	<para>In this method, we compute the closest distance between the two shapes. The
                returned unit will be in the unit of distance specified.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the return value. For example,
            if you select miles as your distanceUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another, based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another, based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance unit is based on a DistanceUnit you specify in the
            distanceUnit parameter, regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the one specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographicUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure for the move. For
            example, if you select miles as your distanceUnit, then the distance will be calculated
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.LineShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, than the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric figures.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.LineShape)">
            <summary>
            This method removes the selected vertex from line shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of line shape, otherwise it will return false and line shape will keep the same.</param>
            <param name="lineShape">The line shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method removes the selected vertex from line shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of line shape, otherwise it will return false and line shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.LineShape.ToPolygonShape">
            <summary>
            This method generates a PolygonShape based the vertexes of the line.
            </summary>
            <returns>A generated polygon based on the vertexes of the line, otherwise return null.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.HelpFunction">
            <summary>
            HelpFun is the help functions collection
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.MGRSProj">
            <summary>
            MGRSProj is the class for convert Data between MGRS and Geodetic��
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.TransverseMercator">
            <summary>
            TransverseMercatorProj is the class for convert Data between TransverseMercator and Geodetic��
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.UniversalPolarStereographicProj">
            <summary>
            UniversalPolarStereographicProj is the class for convert Data between UniversalPolarStereographic and Geodetic��
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.UTMProj">
            <summary>
            UTMProj is the class for convert Data between UTM and Geodetic��
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.MultilineShape">
            <summary>
            This class represents a MultilineShape, which is defined as one or more lines, each with two or
            more points.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.#ctor">
            <overloads>This overload creates the MultilineShape without any points.</overloads>
            <summary>This constructor creates the MultilineShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.LineShape})">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in any lineShapes which are invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapes, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the MultilineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the MultilineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.MultilineShape.Lines">
            <summary>This property is the collection of lines that make up the MultilineShape.</summary>
            <decimalDegreesValue>This property is the collection of lines that make up the MultilineShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.Reorder(ThinkGeo.MapSuite.Shapes.PointShape,System.Double)">
            <summary>This API is used to make the lines within the Multiline ordered.</summary>
            <remarks>
            An ordered Multiline means that we can walk though the MultiLine from the first
            point to the last point without any branches, and that each line's end points should be
            within the given tolerance. If using this overload, the unit of the Multiline and the
            tolerance are both defaulted to meters.  Please use the other overload if you want to
            specify the units yourself.
            </remarks>
            <returns>Returns a re-ordered MultilineShape.</returns>
            <param name="startPoint">
            This parameter specifies the start point of the resulting re-ordered
            MultilineShape.
            </param>
            <param name="tolerance">
            This parameter specifies the tolerance between each line among the lines in the
            Multiline. This parameter is very critial.  If it is too large or too samll, the
            re-order cannot suceed.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.Reorder(ThinkGeo.MapSuite.Shapes.PointShape,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This API is used to make the lines within the Multiline ordered.</summary>
            <remarks>
            An ordered Multiline means that we can walk though the MultiLine from the first
            point to the last point without any branches, and that each line's end points should be
            within the given tolerance. When using this overload, you can specify the unit for the
            Multiline as well as the unit for the tolerance.
            </remarks>
            <returns>Returns a re-ordered MultilineShape.</returns>
            <param name="startPoint">
            This parameter specifies the start point of the resulting re-ordered
            MultilineShape.
            </param>
            <param name="tolerance">
            This parameter specifies the tolerance between each line among the lines in the
            Multiline. This parameter is very critial.  If it is too large or too samll, the
            re-order cannot suceed.
            </param>
            <param name="shapeUnit">This parameter specifies the GeographicUnit for the Multineline.</param>
            <param name="unitOfTolerance">This parameter specifies the distance unit used when considering the tolerance.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.ReorderCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This API is used to make the lines within the Multiline ordered.</summary>
            <remarks>
            An ordered Multiline means that we can walk though the MultiLine from the first
            point to the last point without any branches, and that each line's end points should be
            within the given tolerance. When using this overload, you can specify the unit for the
            Multiline as well as the unit for the tolerance.
            </remarks>
            <returns>Returns a re-ordered MultilineShape.</returns>
            <param name="startPoint">
            This parameter specifies the start point of the resulting re-ordered
            MultilineShape.
            </param>
            <param name="tolerance">
            This parameter specifies the tolerance between each line among the lines in the
            Multiline. This parameter is very critial.  If it is too large or too samll, the
            re-order cannot suceed.
            </param>
            <param name="shapeUnit">This parameter specifies the GeographicUnit for the Multineline.</param>
            <param name="unitOfTolerance">This parameter specifies the distance unit used when considering the tolerance.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLengthCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the length of the LineShape.</summary>
            <overloads>This overload returns the length in the GeographyUnit of the shape.</overloads>
            <returns>The returned length is in the GeographyUnit of the shape.</returns>
            <remarks>
            This method is useful when you want to know the total length of a line-based
            shape. If the shape is a MultilineShape, then the length is the sum of all of its lines.
            There is also an overload which allows you to specify the returning length in the unit
            of your choice.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your returningUnit, then the distance will be
            returned in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetPointOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Single)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from either its first or last vertex (as defined by the startingPoint
                parameter).</para>
            </summary>
            <returns>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from either its first or last vertex (as defined by the startingPoint
                parameter).</para>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>If you pass 100 or 0 as the percentage of the line, it will return either the
                first or last vertex, depending on the value of the startingPoint argument.</para>
            </remarks>
            <overloads>
            This overload allows you to pass a percentage determining how far you want to
            move along the line, as well as whether to start from the beginning or the end
            of the line.
            </overloads>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values are between 0
            and 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetPointOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </summary>
            <overloads>
            This overload allows you to pass in a distance, which determines how far you want to move
            along the line.  You can also choose whether to start from the beginning or the end of
            the line.
            </overloads>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </returns>
            <remarks>
            	<para>Passing in a distance of 0 will return either the first or last point on the
                line, depending on the value of the startingPoint parameter.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move, in the unit
            of the shape itself. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetPointOnALineCore(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </summary>
            <overloads>
            This overload allows you to pass in a distance, which determines how far you want to move
            along the line.  You can also choose whether to start from the beginning or the end of
            the line.
            </overloads>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </returns>
            <remarks>
            	<para>Passing in a distance of 0 will return either the first or last point on the
                line, depending on the value of the startingPoint parameter.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move, in the unit
            of the shape itself. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Single,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point, starting percentage of the
            line and percentage of the line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingPercentageOfTheLine">
            This parameter defines the starting percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
            <param name="percentageOfTheLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from where you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Shapes.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from where you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.StartingPoint,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point and another point.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="endPointShape">
            The BaseLineShape returned will be between the startingPoint and the endPointShape
            specified in this parameter.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass in two points to get a BaseLineShape from the original MultilineShape.
            </overloads>
            <returns>
            This method returns a BaseLineShape based on a start PointShape and an end PointShape.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null startPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startPointShape">
            The startPointShape defines where you will start to get the line. If it does not stand on this
            MultilineShape, the closest point on the MultilineShape will be the start PointShape.
            </param>
            <param name="endPointShape">
            The endPointShape defines where you will stop getting the line. If it does not stand on this
            MultilineShape, the closest point on the MultilineShape will be the end PointShape.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified
            in the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the DistanceUnit specified
            in the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.MultilineShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape by a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.MultilineShape)">
            <summary>
            This method removes the selected vertex from multiline shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multiline shape, otherwise it will return false and multiline shape will keep the same.</param>
            <param name="multilineShape">The multiline shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultilineShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method removes the selected vertex from multiline shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multiline shape, otherwise it will return false and multiline shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.MultipointShape">
            <summary>This class represents one or more point shapes.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.#ctor">
            <summary>This constructor creates a MultipointShape.</summary>
            <overloads>This overload creates the MultipointShape without any points.</overloads>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.PointShape})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the points, we will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a MultipointShape by passing in predefined points.</summary>
            <overloads>This constructor creates a MultipointShape by passing in predefined points.</overloads>
            <param name="points">This parameter specifies the points passed into the MultiPointShape.</param>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>This constructor creates a MultipointShape by passing in predefined point features.</summary>
            <overloads>This constructor creates a MultipointShape by passing in predefined point features.</overloads>
            <param name="pointFeatures">This parameter specifies the points passed into the MultiPointShape.</param>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.#ctor(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This constructor creates a MultipointShape by passing in a Multipoint type Feature.
            </summary>
            <param name="multipointFeature">This parameter specifies the Multipoint feature that will be used to create the Multipoint shape.</param>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a feature that contains a shape which is not a MultipointShape, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the MultipointShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.MultipointShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.MultipointShape.Points">
            <summary>
            This property is the collection of points that make up the
            MultipointShape.
            </summary>
            <decimalDegreesValue>
            This property is the collection of PointShapes that make up the
            MultipointShape.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ScaleUp(System.Double)">
            <summary>
            This method increases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ScaleDown(System.Double)">
            <summary>
            This method decreases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape�s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ConvexHull">
            <summary>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </summary>
            <returns>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon which represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ConvexHullCore">
            <summary>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </summary>
            <returns>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon which represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on an X
                and Y offset distance. It is important to note that with this overload the X and Y
                offset units are based off of the distanceUnit parameter. For example if your shape
                is in decimal degrees and you call this method with an X offset of one and a Y
                offset of one and you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure of the
                translate. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the shape from one location to another based on a
            direction in degrees and distance.
            </summary>
            <overloads>In this overload the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box�s upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.MultipointShape)">
            <summary>
            This method removes the point which the same coordinate as selected vertex from multipoint shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be the same coordinate as a point of multipoint shape, otherwise it will return false and multipoint shape will keep the same.</param>
            <param name="multipointShape">The multipoint shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipointShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method removes the point which the same coordinate as selected vertex from multipoint shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be the same coordinate of a point of multipoint shape, otherwise it will return false and multipoint shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.MultipolygonShape">
            <summary>This class represents one or more polygons.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.#ctor">
            <overloads>This overload creates the MultipolygonShape without any polygons.</overloads>
            <summary>This constructor creates the PolygonShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.PolygonShape})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the polygons, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the MultipolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the MultipolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.MultipolygonShape.Polygons">
            <summary>This property is the collection of PolygonShapes that make up the MultipolygonShape.</summary>
            <decimalDegreesValue>This property is the collection of PolygonShapes that make up the MultipolygonShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.MultipolygonShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetPerimeterCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape (defined as the sum of the lengths
            of all its sides).
            </summary>
            <overloads>
            In this overload, the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around an area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetAreaCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape (defined as the size of the region
            enclosed by the figure).
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.ScaleUpCore(System.Double)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on an X
                and Y offset distance. It is important to note that with this overload the X and Y
                offset units are based off of the distanceUnit parameter. For example if your shape
                is in decimal degrees and you call this method with an X offset of one and a Y
                offset of one and you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the move.
                For example, if you select miles as your distanceUnit, then the xOffsetDistance and yOffsetDistance
                will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            direction in degrees and distance.
            </summary>
            <overloads>In this overload the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure of the
                translate. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whther the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.MultipolygonShape)">
            <summary>
            This method removes the selected vertex from multipolygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multipolygon shape, otherwise it will return false and multipolygon shape will keep the same.</param>
            <param name="multipolygonShape">The multipolygon shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.MultipolygonShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method removes the selected vertex from multipolygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multipolygon shape, otherwise it will return false and multipolygon shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PanDirection">
            <summary>This enumeration defines panning directions.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.Up">
            <summary>This pans up.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.UpperRight">
            <summary>This pans to the upper right.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.Right">
            <summary>This pans to the right.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.LowerRight">
            <summary>This pans to the lower left.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.Down">
            <summary>This pans down.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.LowerLeft">
            <summary>This pans to the lower left.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.Left">
            <summary>This pans to the left.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.PanDirection.UpperLeft">
            <summary>This pans to the upper left.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PointShape">
            <summary>This class represents a single point.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.#ctor">
            <summary>This constructor creates a PointShape.</summary>
            <overloads>This overload creates the PointShape with its default values.</overloads>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.#ctor(System.Double,System.Double)">
            <summary>This constructor create a PointShape.</summary>
            <overloads>This overload creates a PointShape by specifying the X and Y values.</overloads>
            <remarks>None</remarks>
            <param name="x">This parameter represents the X (horizontal) axis.</param>
            <param name="y">This parameter represents the Y (vertical) axis.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.#ctor(System.Double,System.Double,System.Double)">
            <overloads>This overload creates a PointShape by specifying the X,Y, and Z values.</overloads>
            <summary>This constructor create a PointShape.</summary>
            <remarks>None</remarks>
            <param name="x">This parameter represents the X (horizontal) axis.</param>
            <param name="y">This parameter represents the Y (vertical) axis.</param>
            <param name="z">This parameter represents the Z (depth) axis.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.#ctor(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This overload creates a PointShape by specifying the vertex.
            </summary>
            <param name="vertex">This parameter represents the vertex that will be used to construct the PointShape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the PointShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the PointShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PointShape.X">
            <summary>This property represents the X (horizontal) axis.</summary>
            <decimalDegreesValue>This property represents the X (horizontal) axis.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PointShape.Y">
            <summary>This property represents the Y (vertical) axis.</summary>
            <decimalDegreesValue>This property represents the Y (vertical) axis.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PointShape.Z">
            <summary>This property represents the Z (depth) axis.</summary>
            <decimalDegreesValue>This property represents the Z (depth) axis.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.Equal2D(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            Compare the current PointShape with the target PointShape.
            </summary>
            <param name="targetShape">The targetPointShape to be compared with.</param>
            <returns>True if both X and Y coordinates of the current shape are equal to those of the target shape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.Equal2D(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            Compare the current PointShape with the target Point Feature.
            </summary>
            <param name="targetPointFeature">The targetPointFeature to be compared with.</param>
            <returns>True if both X and Y coordinates of the current shape are equal to those of the PointShape contained in the target PointFeature.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape by a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PointShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GreatCircle(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>
            This method returns a MultilineShape that represents the shortest line between
            two points on the globe.
            </summary>
            <returns>
            This method returns a MultilineShape that represents the shortest line between
            two points on the globe.
            </returns>
            <remarks>
            This method is useful when you want to display on the map the shortest line between two
            points in decimal degrees. The line will be curved, and possibly disconnected
            if it is close to travel from the end of the map.
            </remarks>
            <param name="pointShape">This parameter is the target point to be measured to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GreatCircle(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method returns a MultilineShape which represents the shortest line between
            the current point and the specified feature on the globe.
            </summary>
            <returns>
            This method returns a MultilineShape which represents the shortest line between
            the current point and the specified feature on the globe.
            </returns>
            <remarks>
            This method is useful when you want to display on the map the shortest line between two
            points in decimal degrees. The line will be curved, and possibly disconnected
            if it is close to travel from the end of the map.
            </remarks>
            <param name="pointFeature">This parameter is the target feature to be measured to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
             <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
             <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
             <returns>
             This method returns the distance between the current shape and the
             targetShape.
             </returns>
             <summary>
             This method computes the distance between the current shape and the
             targetShape.
             </summary>
             <remarks>None</remarks>
             <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
             <param name="shapeUnit">
             This is the GeographyUnit of the shape you are performing the operation
             on.
             </param>
             <param name="distanceUnit">
             This is the DistanceUnit you would like to use for the distance parameter. For
             example, if you select miles as your distanceUnit, then the distance will be measured
             in miles.
             </param>
            
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PointShape.ToString">
            <summary>
            Override the ToString() API by returning the X, Y , Z
            </summary>
            <returns>The returned string shows the X, Y , Z values.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PolygonShape">
            <summary>
            This class represents a polygon, which is defined as a single outer ring with
            zero-to-many inner rings.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.#ctor">
            <overloads>This overload creates a PolygonShape without any points in the outer ring.</overloads>
            <summary>This constructor creates a PolygonShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.#ctor(ThinkGeo.MapSuite.Shapes.RingShape)">
            <overloads>This overload creates a PolygonShape by specifying an outer ring.</overloads>
            <summary>This constructor creates a PolygonShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.#ctor(ThinkGeo.MapSuite.Shapes.RingShape,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.RingShape})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outerRing, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the innerRings, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a PolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates a PolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PolygonShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <value>This property specifies whether the shape can be rotated.</value>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PolygonShape.OuterRing">
            <summary>This property is the outer RingShape of the polygon.</summary>
            <value>This property is the outer RingShape of the polygon.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PolygonShape.InnerRings">
            <summary>This property is the collection of RingShapes that make up the inner rings.</summary>
            <value>This property is the collection of RingShapes that make up the inner rings.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetPerimeterCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on the LengthUnit you specify in the
            returningLengthUnit, parameter regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetAreaCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>None</remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.LoadFromWellKnownDataCore(System.String)">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry, such as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetBoundingBoxCore">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.PolygonShape)">
            <summary>
            This method removes the selected vertex from polygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of polygon shape, otherwise it will return false and polygon shape will keep the same.</param>
            <param name="polygonShape">The polygon shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PolygonShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method removes the selected vertex from polygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of polygon shape, otherwise it will return false and polygon shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseInfoExtra.#ctor(System.String,System.String)">
            <summary>
            Extract the information that it will be used in the system from Resource file
            </summary>
            <param name="baseInfoFile">one of the units in Resource file</param>
            <param name="xmlPath">Xml Path in baseInfoFile unit</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.BaseInfoExtra.NodeList">
            <summary>
            return XmlNodeListAdapter
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseInfoExtra.FileExists">
            <summary>
            Check base info file is exist or not
            </summary>
            <returns>file exist</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.BaseInfoExtra._InitXmlDoc">
            <summary>
            Initialize XmlDocument,and initialize Xml document node
            </summary>
            <returns>flag for initialize success or not </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ThinkGeo.MapSuite.Shapes.BaseInfoExtra.ExtraXmlNode(System.String,System.String)" -->
        <member name="T:ThinkGeo.MapSuite.Shapes.ComFunc">
            <summary>
            Definition of static Class ComFunc for the math or the adjustment function
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.Adjlon(System.Double,System.Int32@)">
            <summary>
            adjust the deviation for the variable lon
            </summary>
            <param name="lon">lon is the variable that it will be adjusted</param>
            <returns>adjusted variable</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.aasin(System.Double,System.Int32@)">
            <summary>
            the function will be done when the asin's parameter has some deviation
            </summary>
            <param name="v">the parameter of be adjusted</param>
            <returns>has been coculated the result by adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.aatan2(System.Double,System.Double,System.Int32@)">
            <summary>
            it will be called to coculate for atan2 when parameters of the atan2 function have some deviation
            </summary>
            <param name="n">the y parameter of atan2</param>
            <param name="d">the x parameter of atan2</param>
            <returns>the result of coculated that parameters has been adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.aacos(System.Double,System.Int32@)">
            <summary>
            it will be called to coculate for acos when the parameter of the acos function have some deviation
            </summary>
            <param name="v">the parameter of aacos</param>
            <returns>the result of coculated that parameters has been adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.asqrt(System.Double,System.Int32@)">
            <summary>
            it will be called to coculate for sqrt when the parameter of the sqrt function have some deviation
            </summary>
            <param name="v">the parameter that it have some deviation</param>
            <returns>the result of coculated that parameters has been adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.GetParam(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32@)">
            <summary>
            Get the system's parameters through parameters of called line
            </summary>
            <param name="paras">the general collection of handled</param>
            <param name="param">the original parameter</param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.Dmstor(System.String,System.Int32@)">
            <summary>
            get the real result when the parameter is a string
            </summary>
            <param name="p">the string will be converted</param>
            <returns>double value</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.proj_strtod(System.String,System.String@)">
            <summary>
            make the parameter of a string to a double value
            </summary>
            <param name="handleStr">the parameter that it will be done</param>
            <param name="tempStr">the string will be remained after the parameter changed</param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.GetTag(System.String)">
            <summary>
            get symbol char after substring &lt; and &gt;
            </summary>
            <param name="lineStr">command line string</param>
            <returns>result of handled string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.GetDefaultConfigFile(System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>
            get parameters by file path if parameters have 'nodef'
            </summary>
            <param name="filePath">file path string</param>
            <param name="fileAccess">permission of file</param>
            <returns>file stream</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.IsLSB">
            <summary>
            determine the os is LSB or not
            </summary>
            <returns>the OS is LSB then return true else return false</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.SwapWords(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            swap the sequence of binary data
            </summary>
            <param name="data">binary buffer</param>
            <param name="offsetIndex">the offset index</param>
            <param name="wordSize">the word's size</param>
            <param name="wordCount">the number of changing</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.ConvertByteArrayToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            make the binary buffer to string
            </summary>
            <param name="characters">binary buffer</param>
            <param name="index">handling index</param>
            <param name="count">the number of handling</param>
            <returns>transformed string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.ConvertByteArrayToInt32(System.Byte[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            make the binary buffer to int32
            </summary>
            <param name="byteArray">binary buffer</param>
            <param name="index">handling index</param>
            <param name="count">the number of handling</param>
            <returns>the result of int32</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.ConvertByteArrayToDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            make the binary buffer to double value
            </summary>
            <param name="byteArray">binary buffer</param>
            <param name="index">handling index</param>
            <param name="count">the number of handling</param>
            <returns>the value of double</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ComFunc.GetValidStrByAlphaStart(System.String)">
            <summary>
            valid the string of not a number
            </summary>
            <param name="param">the validing string</param>
            <returns>valided string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.DataConst">
            <summary>
            definition of DataConst static class
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DataInstance.#ctor">
            <summary>
            get the instances of specified
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.DataInstance.GetProjType(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            get a ProjType instance
            </summary>
            <param name="projID">ProjID in proj.xml</param>
            <param name="desc">the string of description</param>
            <returns>the ProjType instance</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Factors">
            <summary>
            definition of class Factors
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.FLP">
            <summary>
            definition of struct FLP
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.GeocentricInfo">
            <summary>
            definition of class GeocentricInfo
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.GISDataOperation">
            <summary>
            The static class is used to convert and operate the data of GISSystem
            </summary>
            <summary>
            Private function class of GISDataOper
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.CheckReturn(System.Double[],System.Boolean,System.Int32@)">
            <summary>
            check the height is the temporary or not
            </summary>
            <param name="height">double array</param>
            <param name="z_is_temp">bool</param>
            <returns>bool</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.Pj_Transform(ThinkGeo.MapSuite.Shapes.ProjType,ThinkGeo.MapSuite.Shapes.ProjType,System.Int64,System.Int32,System.Double[],ThinkGeo.MapSuite.Shapes.ProjUV[],System.Int32@)">
            <summary>
            The mutual transformation of different coordinate systems
            </summary>
            <param name="srcdefn">source projection</param>
            <param name="dstdefn">destination projection</param>
            <param name="point_count">point count</param>
            <param name="point_offset">point offset</param>
            <param name="height">height of transformation</param>
            <param name="uvList">data list of transformation</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.ComposePara(System.String[])">
            <summary>
            compose the Mapsuiteprojection system's parameter
            </summary>
            <param name="args">the string array of arguments</param>
            <returns>the collection has been generated by string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.AppendParaToParas(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            append the argument for the paras collection
            </summary>
            <param name="paras">the collection generated by string</param>
            <param name="arg">the string argument</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.Pj_Datum_Transform(ThinkGeo.MapSuite.Shapes.ProjType,ThinkGeo.MapSuite.Shapes.ProjType,System.Int64,System.Int32,ThinkGeo.MapSuite.Shapes.ProjUV[],System.Double[],System.Int32@)">
            <summary>
            Datum of source projection converted for the datum of destination projection
            </summary>
            <param name="srcdefn">Source projection object</param>
            <param name="dstdefn">Destination projection object</param>
            <param name="point_count">Point count</param>
            <param name="point_offset">Point offset</param>
            <param name="uvList">Data of transformation</param>
            <param name="height">Height of transformation</param>
            <returns>If the transformation successful return 0,otherwise return 1</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.Pj_Geocentric_To_Geodetic(System.Double,System.Double,System.Int64,System.Int32,ThinkGeo.MapSuite.Shapes.ProjUV[],System.Double[],System.Int32@)">
            <summary>
            geocentric projection transform to geodetic projection
            </summary>
            <param name="a">Major axis or radius if es==0</param>
            <param name="es">e^2</param>
            <param name="point_count">Point count</param>
            <param name="point_offset">point offset</param>
            <param name="height">Height of geocentic</param>
            <param name="uvList">Data of transformation</param>
            <returns>Changed data</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.Pj_Get_Geocentric_Parameters(ThinkGeo.MapSuite.Shapes.GeocentricInfo,System.Double,System.Double)">
            <summary>
            obtain instance of GeocentricInfo
            </summary>
            <param name="a">variables a</param>
            <param name="b">variables b</param>
            <returns>instance of GeocentricInfo</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.Pj_Convert_Geocentric_To_Geodetic(ThinkGeo.MapSuite.Shapes.GeocentricInfo,System.Double,System.Double,System.Double,ThinkGeo.MapSuite.Shapes.ProjUV[],System.Double[],System.Int64,System.Int32@)">
            <summary>
            convert geocentric projection to geodetic projection
            </summary>
            <param name="gi">GeocentricInfo object</param>
            <param name="x">double value x</param>
            <param name="y">double value y</param>
            <param name="z">double value z</param>
            <param name="uv">conversing point</param>
            <param name="height">double array for height</param>
            <param name="io">long value specified offset value</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISDataOperation.Pj_Inv(ThinkGeo.MapSuite.Shapes.XY,ThinkGeo.MapSuite.Shapes.ProjType,System.Int32@)">
            <summary>
            inverse transform function for frame
            </summary>
            <param name="xy">XY object conversing point</param>
            <param name="p">ProjType object projection</param>
            <returns>LP object</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.GISSystem">
             <summary>
            Core class of ThinkGeo.MapSuite.Core
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem._InitPJUnits">
            <summary>
            Initialize pj_Units_List object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem._InitPJList">
            <summary>
            Initialize projection object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem._InitPJEllps">
            <summary>
            Initialize ellipsoid object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem._InitPJDatums">
            <summary>
            Initialize datum object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem._InitPJMeridians">
            <summary>
            Initialize data of Meridians list
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.InitGISSystem(System.String)">
            <summary>
            Initialize GISSystem system
            </summary>
            <param name="args">Passing parameters</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.Pj_Transform(ThinkGeo.MapSuite.Shapes.ProjType,ThinkGeo.MapSuite.Shapes.ProjType,System.Int64,System.Int32,ThinkGeo.MapSuite.Shapes.ProjUV[],System.Double[])">
            <summary>
            The source projection constants are converted for the destination projection constants
            </summary>
            <param name="srcdefn">Variables of source projection</param>
            <param name="dstdefn">Variables of destination projection</param>
            <param name="point_count">Point count</param>
            <param name="point_offset">Point offset</param>
            <param name="uvList">Data of transformation</param>
            <param name="z">Hight of transformation</param>
            <returns>Return new data</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem._InitPjConst(ThinkGeo.MapSuite.Shapes.PjDatum,ThinkGeo.MapSuite.Shapes.Unit,ThinkGeo.MapSuite.Shapes.Meridian,ThinkGeo.MapSuite.Shapes.ProjType,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Initialize the PJconsts object
            </summary>
            <param name="datum">PjDatum object</param>
            <param name="unitObj">Unit object</param>
            <param name="meridian">Meridian object</param>
            <param name="proj">ProjType object</param>
            <param name="args">general collection string object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.Pj_Datum_Set(ThinkGeo.MapSuite.Shapes.ProjectionDatums,System.Collections.Generic.Dictionary{System.String,System.String},ThinkGeo.MapSuite.Shapes.ProjType)">
            <summary>
            Datum setting
            </summary>
            <param name="pjDatum">PjDatums object</param>
            <param name="args">Parameter list</param>
            <param name="projObj">Projection object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.AddDefaultParaInProj(ThinkGeo.MapSuite.Shapes.ProjType,System.String)">
            <summary>
            set default parameter according to default config file
            </summary>
            <param name="projObj">ProjType object</param>
            <param name="projName">Projection name</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.Set_Para(System.IO.Stream,System.String,ThinkGeo.MapSuite.Shapes.ProjType)">
            <summary>
            set parameters's value according to file stream
            </summary>
            <param name="stream">File stream</param>
            <param name="keyField">Key word string</param>
            <param name="projObj">ProjType object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.SetToMeter(ThinkGeo.MapSuite.Shapes.ProjectionUnit,System.Collections.Generic.Dictionary{System.String,System.String},ThinkGeo.MapSuite.Shapes.ProjType)">
            <summary>
            Check if to_meter parameter present
            </summary>
            <param name="pjUnit">Unit object</param>
            <param name="args">Initialize the array of string parameter </param>
            <param name="projObj">Projection object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.GetMeridianValue(ThinkGeo.MapSuite.Shapes.ProjectionMeridians)">
            <summary>
            Obtain the value of meridian
            </summary>
            <param name="meri">object of meridian</param>
            <returns>return the value of meridian</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.GISSystem.Getvalue(System.String,System.Int32@)">
            <summary>
            According to the parameter of meridian obtain the value of meridian
            </summary>
            <param name="meriDefn">parameter of meridian</param>
            <returns>return value of meridian</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Meridian.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Shapes.ProjectionMeridians},System.Int32@)">
             <summary>
            constructor of Meridian
             </summary>
             <param name="args">user inputed parameter</param>
             <param name="meridiansList">list of meridian</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Meridian.GetMeridianID(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            obtain ID value of meridian
            </summary>
            <param name="args">dictionary of parameter</param>
            <returns>ID value of Meridian</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Meridian._InitMeridian(System.String,System.Int32@)">
            <summary>
            set object of meridian
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Meridian.Meri">
            <summary>
            obtain object of meridian
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PjDatum">
            <summary>
            Datum setting
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PjDatum.GetDatumID(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Obtain ID value of Datum
            </summary>
            <param name="args">Parameter string dictionary</param>
            <returns>ID of Datum</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PjDatum._InitDatum(System.String)">
            <summary>
            According to datums list set value of datums
            </summary>
            <param name="datumID">ID value of datum object</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.PjDatum.Datum">
            <summary>
            Obtain PjDatums object of corresponding ID
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.PjEllp">
            <summary>
            set ellipsoid
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.PjEllp._InitEllps(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32@)">
            <summary>
            According to the ellps list to1986520wyq
            198set the value of ellps
            </summary>
            <param name="ellpsID">ID value of ellps object</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Pj_Aea">
            <summary>
            definition of Class Pj_Aea
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj._InitProj(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            According to Proj list set the value of Proj
            </summary>
            <param name="projID">ID value of proj object</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Proj.ProjObj">
            <summary>
            Obtain Proj object of corresponding ID
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ProjectionDatums">
            <summary>
            definition of class PjDatums
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ProjectionMeridians">
            <summary>
            definition of class Pj_Prime_Meridians for meridians
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ProjType">
            <summary>
            definition of class ProjType
            the class is the base class of the projection,when the projection object has been create
            then it will realize the abstract function
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Unit.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Shapes.ProjectionUnit})">
             <summary>
            Constructor of Unit
             </summary>
             <param name="args">parameter array</param>
             <param name="pj_Units_List">Hashtable of PJUnit</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Unit.GetUnitID(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Obtain UnitID
            </summary>
            <param name="args">parameter string ditionary</param>
            <returns>id value of PJUnit</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Unit._InitUnit(System.String)">
            <summary>
            If unitID is not null which initialize unit
            </summary>
            <param name="unitID">obtain id value of PJUnit</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Unit.CurrentUnit">
            <summary>
            obtain PJUnit object of corresponding ID 
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Proj4Projection">
            <summary>
            This projection class uses the Proj4 engine to project data from one Srid to
            another.
            </summary>
            <remarks>
            This projection class uses the Proj4 engine to project data from one Srid to
            another. Proj4 is a very popular projection library the support thousands for
            projections. It uses a special text format to feed in parameters about the to and from
            projection. Though it uses its own format many organizations have recognized it and
            provide their projection definition in this format. Within this class we support the
            latest EPSG (European Petroleum Survey Group) SRID (Spatial Reference System
            Identifiers) list. You can find more information about these on the web. The SRID list
            is very popular and we include a text version with in our install.<br/>
            	<br/>
            Note that one thing that confuses people is that when they go to or from latitude and
            longitude they do not know what SRID to use. The proper SRID is 4326 for WGS84 pair
            coordinates in degrees with Greenwich as the central meridian.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.#ctor">
            <summary>
            This is the default constructor for this class.
            </summary>
            <remarks>This conctructor pass nothing. After this cconstructor , you should
            set the InternalProjectionParametersString property and ExternalProjectionParametersString
            property before open to use.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in Proj4 text parameters for the to and from
            projection. The parameters typically look like "+proj=longlat +ellps=WGS84 +datum=WGS84
            +no_defs"
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to pass in Proj4 text parameters for the to and from
            projection. The parameters typically look like "+proj=longlat +ellps=WGS84 +datum=WGS84
            +no_defs" You should use this constructor when you know the parameters. If you know the
            SRID directly you can use the other constructor that takes the SRID.
            </remarks>
            <param name="internalProjectionParametersString">This parameter is the projection parameters describing the data.</param>
            <param name="externalProjectionParametersString">
            This parameter is the projection parameters describing the projection you want to
            go to.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Proj4Projection.InternalProjectionParametersString">
            <summary>
            Gets or sets the Proj4 text parameter for the from projection. This parameter
            typically look like "+Proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs".
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Proj4Projection.ExternalProjectionParametersString">
            <summary>
            Gets or sets the Proj4 text parameter for the to projection. This parameter
            typically look like "+proj=utm +zone=33 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs".
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.OpenCore">
            <returns>None</returns>
            <remarks>
            As this is the core version of the Open method it is intended to be overridden in
            inherited version of the class. When overriding you will be responsible for getting the
            projection classes state ready for doing projections.<br/>
            	<br/>
            In this override we call the Proj4 methods get it ready for projection.
            </remarks>
            <summary>This method open the projection and gets it ready to use.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.CloseCore">
            <summary>
            This method closes the projection and gets it ready to serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            As this is the core version of the Close method it is intended to be overridden
            in inherited version of the class. When overriding you will be responsible freeing any
            state you have maintained and getting the class ready to serialization if necessary.
            Note that the object may be opened again so you want to make sure you can open and
            close the object multiple tiles without any ill effects.<br/>
            	<br/>
            In this override we call the Proj4 methods get release the handles and memory.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>This method returns a projected vertex based on the coordinates passed in.</summary>
            <returns>
            This method returns a projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because inside of the FeatureSource you
            will in many cases to to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetEpsgParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from EPSG(European Petroleum Survey Group).
            </summary>
            <remarks>More information about it can reference to EPSG.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetWgs84ParametersString">
            <summary>
            This method is a static API to get a projection text from WGS84.
            </summary>
            <remarks>More information about it can reference to EPSG.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetEsriParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from ERSI.
            </summary>
            <remarks>More information about it can reference to ERSI.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetGoogleMapParametersString">
            <summary>
            This method is a static API to get a projection used by GoogleMap.
            </summary>
            <returns>A text for a projection used by GoogleMap , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetBingMapParametersString">
            <summary>
            This method is a static API to get a projection used by BingMaps.
            </summary>
            <returns>A text for a projection used by BingMaps , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetSphericalMercatorParametersString">
            <summary>
            This method is a static API to get a projection of SphericalMercator.
            </summary>
            <returns>A text for a SphericalMercator projection, it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.GetInternalGeographyUnitCore">
            <summary>
            This property indicates whether this projection should be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Proj4Projection.ConvertEpsgToPrj(System.Int32)">
            <summary>
            This method is a static API to get a Prj string by Epsg number
            </summary>
            <param name="srid">Epsg number that reprents this projection</param>
            <returns></returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Projection">
            <summary>
            This class represents a projection that you wish to apply to a
            FeatureSource.
            </summary>
            <remarks>
            This class is abstract and designed to be inherited to create your own
            projection. The derived projection classes are typically used on a FeatureSource or
            Layer. It is used to project coordinates from one projection to another and back again.
            It is important to note that you need to implement the projection both ways.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.#ctor">
            <summary>This method is the default protected constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Projection.IsOpen">
            <summary>This property gets the state of the projection (whether it is opened or closed).</summary>
            <decimalDegreesValue>This property gets the state of the projection (whether it is opened or closed).</decimalDegreesValue>
            <remarks>
            This method will reflect whether the projection is opened or closed. It is set in the
            concrete methods Open and Close, so if you inherit from this class and override
            OpenCore or CloseCore, you will not need to be concerned with setting this
            property.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.CloneDeep">
            <summary>Create a copy of Projection using the deep clone process.</summary>
            <returns>A cloned Projection.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.CloneDeepCore">
            <summary>Create a copy of GeoCanvas using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoCanvas.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.Open">
            <remarks>
            This method opens the projection and gets it ready to use.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method opens the projection and gets it ready to use.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.OpenCore">
            <returns>None</returns>
            <remarks>
            As this is the core version of the Open method, it is intended to be overridden in an
            inherited version of the class. When overriding, you will be responsible for getting the
            projection classes' state ready for doing projections.
            </remarks>
            <summary>This method opens the projection and gets it ready to use.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.Close">
            <summary>
            This method closes the projection and gets it ready for serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            This method closes the projection and gets it ready for serialization if
            necessary.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.CloseCore">
            <summary>
            This method closes the projection and gets it ready for serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            As this is the core version of the Close method, it is intended to be overridden in
            an inherited version of the class. When overriding, you will be responsible freeing any
            state you have maintained and getting the class ready for serialization if necessary.
            Note that the object may be opened again, so you want to make sure you can open and
            close the object multiple times without any ill effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjection(System.Double,System.Double)">
            <summary>This method returns a projected vertex based on the coordinates passed in.</summary>
            <overloads>
            This overload projects a set of coordinates passed in as an X &amp; Y
            decimalDegreesValue.
            </overloads>
            <returns>This method returns a projected vertex based on the coordinates passed in.</returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="x">This parameter is the X decimalDegreesValue of the point that will be projected.</param>
            <param name="y">This parameter is the Y decimalDegreesValue of the point that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjection(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns a projected BaseShape based on the baseShape passed
            in.
            </summary>
            <returns>This method returns a projected baseShape for the passed-in BaseShape.</returns>
            <remarks>
            This method returns a projected baseShape based on the BaseShape passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="baseShape">This parameter is the baseShape (in decimalDegreesValue) to be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjection(ThinkGeo.MapSuite.Shapes.Feature)">
            <remarks>
            This method returns a projected Feature based on the Feature passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <returns>This method returns a projected Feature for the passed-in Feature.</returns>
            <summary>This method returns a projected Feature based on the Feature passed in.</summary>
            <param name="feature">
            This parameter is the Feature that contains a BaseShape in decimalDegreesValue
            to be projected.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjection(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <overloads>This overload takes in a rectangle to project.</overloads>
            <summary>This method returns a projected rectangle based on the rectangle passed in.</summary>
            <returns>This method returns a projected rectangle based on the rectangle passed in.</returns>
            <remarks>This method returns a projected rectangle based on the rectangle passed in.</remarks>
            <param name="rectangleShape">This parameter represents the rectangle you want to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically, you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Vertex})">
            <summary>
            This method returns projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically, you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="vertices">This parameter is the vertices that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjection(System.Double,System.Double)">
            <summary>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed
            in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <overloads>
            This overload de-projects a set of coordinates passed in as an X &amp; Y
            decimalDegreesValue.
            </overloads>
            <param name="x">This parameter is the X decimalDegreesValue of the point that will be de-projected.</param>
            <param name="y">This parameter is the Y decimalDegreesValue of the point that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjection(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns a de-projected BaseShape based on the BaseShape passed
            in.
            </summary>
            <returns>This method returns a de-projected BaseShape for the passed in BaseShape.</returns>
            <remarks>
            This method returns a de-projected BaseShape based on the BaseShape passed
            in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="baseShape">This parameter is the baseShape (in decimalDegreesValue) to be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjection(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>This method returns a de-projected Feature based on the Feature passed in.</summary>
            <remarks>
            This method returns a de-projected Feature based on the Feature passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <returns>This method returns a de-projected Feature for the passed-in Feature.</returns>
            <param name="feature">
            This parameter is the Feature that contains a BaseShape in decimalDegreesValue
            to be de-projected.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Vertex})">
            <summary>
            This method returns de-projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. The de-projection
            is important because, inside of the FeatureSource, you will in many cases go to and from various projections.
            </remarks>
            <param name="vertices">This parameter is the vertices that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjection(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <overloads>This overload takes in a rectangle to de-project.</overloads>
            <summary>
            This method returns a de-projected rectangle based on the rectangle passed
            in.
            </summary>
            <returns>
            This method returns a de-projected rectangle based on the rectangle passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected rectangle based on the rectangle passed
            in.
            </remarks>
            <param name="rectangleShape">This parameter represents the rectangle you want to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns de-projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically, you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because, inside of the FeatureSource, you
            will in many cases go to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToExternalProjection(System.Byte[])">
            <summary>
            This method returns projected well-known binary based on the well-known binary
            passed in.
            </summary>
            <returns>
            This method returns projected well-known binary based on the well-known binary
            passed in.
            </returns>
            <remarks>
            This method will project an entire shape in well-known binary. It is useful when
            you need to convert a large block of points.
            </remarks>
            <overloads>This overload takes in well-known binary to project.</overloads>
            <param name="wellKnownBinary">This parameter represents the well-known binary shape you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Projection.ConvertToInternalProjection(System.Byte[])">
            <summary>
            This method returns de-projected well-known binary based on the well-known binary
            passed in.
            </summary>
            <returns>
            This method returns de-projected well-known binary based on the well-known binary
            passed in.
            </returns>
            <remarks>
            This method will de-project an entire shape in well-known binary. It is useful
            when you need to convert a large block of points.
            </remarks>
            <overloads>This overload takes in well-known binary to de-project.</overloads>
            <param name="wellKnownBinary">This parameter represents the well-known binary shape you wish to project.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Projection.CanReproject">
            <summary>
            This property indicates whether this projection should be used.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.RectangleShape">
            <summary>
            This class represents a rectangle, which is defined as an upper left point and a
            lower right point.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.RectangleShape.tolerance">
            <summary>
            Gets and sets the tolerance when construct the RectangleShape.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.#ctor">
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>This overload creates a RectangleShape with default values.</overloads>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.#ctor(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>
            This overload creates a RectangleShape by allowing you to specify the upperLeft
            and lowerRight points of the rectangle.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a upperLeftPoint that has a X value that is more than the lowerRightPoint's X value, it will throw a ArgumentException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a upperLeftPoint that has a Y value that is less than the lowerRightPoint's Y value, it will throw a ArgumentException.</exception>
            <param name="upperLeftPoint">This parameter specifies the upper left point of the rectangle.</param>
            <param name="lowerRightPoint">This parameter specifies the lower right point of the rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>
            This overload creates a RectangleShape by allowing you to specify the maximum and
            minimum of the X &amp; Y values.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxX that is less than the minX, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxY that is less than the minY, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="minX">
            This property specifies the minimum X value. This is also the upper left
            X.
            </param>
            <param name="maxY">
            This property specifies the maximum Y value. This is also the upper left
            Y.
            </param>
            <param name="maxX">
            This property specifies the maximum X value. This is also the lower right
            X.
            </param>
            <param name="minY">
            This property specifies the minimum Y value. This is also the lower right
            Y.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetIntersection(ThinkGeo.MapSuite.Shapes.RectangleShape)">
            <summary>
            This method returns the intersection of the current RectangleShape and the target shape,
            defined as the set of all points which lie in both the current shape and the target
            shape.
            </summary>
            <returns>
            The return type is a RectangleShape that contains the set of all points which
            lie in both the current shape and the target shape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RectangleShape.UpperLeftPoint">
            <summary>
            This property returns or sets the PointShape that represents the upper left point
            of the RectangleShape.
            </summary>
            <value>
            This property returns a PointShape at represents the upper left point of the
            RectangleShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RectangleShape.UpperRightPoint">
            <summary>
            This property returns the PointShape that represents the upper right point of the
            RectangleShape.
            </summary>
            <value>
            This property returns the PointShape that represents the upper right point of the
            RectangleShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RectangleShape.LowerRightPoint">
            <remarks>None</remarks>
            <summary>
            This property returns or sets the PointShape that represents the lower right point
            of the RectangleShape.
            </summary>
            <value>
            This property returns the PointShape that represents the lower right point of the
            RectangleShape.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RectangleShape.LowerLeftPoint">
            <summary>
            This property returns the PointShape that represents the lower left point of the
            RectangleShape.
            </summary>
            <value>
            This property returns the PointShape that represents the lower left point of the
            RectangleShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RectangleShape.Height">
            <summary>
            This property returns the height of the RectangleShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the height of the RectangleShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RectangleShape.Width">
            <summary>
            This property returns the width of the RectangleShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the width of the RectangleShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ToPolygon">
            <summary>This method returns the current shape as a PolygonShape.</summary>
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert this GIS non-standard shape to a GIS
            standard shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ExpandToInclude(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method will expand the current RectangleShape to include the targetShape
            parameter.
            </summary>
            <overloads>This overload takes a single shape.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a list of
            multiple shapes.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">This parameter is used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ExpandToInclude(ThinkGeo.MapSuite.Shapes.Feature)">
            <summary>
            This method will expand the current RectangleShape to include the target feature
            parameter.
            </summary>
            <overloads>This overload takes a single feature.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a collection of features.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeature">This parameter is used to expand the current feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ExpandToInclude(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape})">
            <summary>
            This method will expand the current RectangleShape to include the shapes in the targetShapes
            parameter.
            </summary>
            <overloads>This overload takes a list of shapes.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a single
            shape.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in targetShapes that do not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetShapes">This parameter is used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ExpandToInclude(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            This method will expand the current RectangleShape to include the features in the targetFeatures
            parameter.
            </summary>
            <overloads>This overload takes a feature collection.</overloads>
            <remarks>
            There also is an overload that can expand the RectangleShape using a single
            feature.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in targetFeatures that do not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeatures">This parameter is a group of features used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetCenterPointCore">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry such, as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ExpandToIncludeCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method will expand the current RectangleShape to include the shape in the targetShape
            parameter.
            </summary>
            <overloads>This overload takes a single shape.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a list of
            shapes.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">This parameter is used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetPerimeterCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape (defined as the sum of the lengths
            of all its sides).
            </summary>
            <overloads>
            In this overload the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetAreaCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape (defined as the size of the region
            enclosed by the figure).
            </summary>
            <overloads>
            In this overload the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>None</remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a MultipointShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            This method returns a MultipointShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </returns>
            <remarks>
            The register method is useful, for example, when a group of points represented by a
            MultipointShape has been generated in a non-geographic coordinate in meters, and you want to
            plot the points on a map that is in decimal degrees.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the GeographyUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload the X and Y offset are based on a DistanceUnit you specify
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the shape from one location to another, based on a
            direction in degrees and distance.
            </summary>
            <overloads>In this overload the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            In this method, we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The GeographyUnit of the targetShape.</param>
            <param name="distanceUnit">The DistanceUnit of the returned value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.IsDisjointedCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns whether the current shape and the targetShape have no points in
            common.
            </summary>
            <returns>
            This method returns whether the current shape and the targetShape have no points in
            common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.GetCrossingCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ContainsCore(ThinkGeo.MapSuite.Shapes.BaseShape)">
            <summary>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RectangleShape.ToString">
            <summary>
            This method returns a formatted representation of the UpperLeftPoint.X, UpperLeftPoint.Y, LowerRightPoint.X and LowerRightPoint.Y
            value.
            </summary>
            <returns>
            This method returns a formatted representation of the UpperLeftPoint.X, UpperLeftPoint.Y, LowerRightPoint.X and LowerRightPoint.Y
            value.
            </returns>
            <remarks>The value will be formatted in the standard string format: -180,90,180,-90"</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ReturningColumnsType">
            <summary>This enumeration provides some options when querying a feature.</summary>
            <remarks>
                Three options are provided in the query system that can cover all possible
                cases. Option 1 is to use the ReturningColumnsType.NoColumns, which will return no columns at 
                all. Option 2 is to use the ReturningColumnsType.AllColumns, which will return all columns. Option 3
                is used when you want to return parts of the columns in the feature; in this case you should pass in an 
                (IEnumerable[string] returningColumnNames) instead of using this enumeration directly.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.ReturningColumnsType.NoColumns">
            <summary>
            Return no column option.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.ReturningColumnsType.AllColumns">
            <summary>
            Return all columns option.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.RingShape">
            <summary>This class represents a closed ring of points.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.#ctor">
            <overloads>This overload creates a RingShape without any points.</overloads>
            <summary>This constructor creates a RingShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Vertex})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the points, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a RingShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates a RingShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.RingShape.Vertices">
            <summary>This property is the collection of points that make up the RingShape.</summary>
            <decimalDegreesValue>This property is the collection of points that make up the RingShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.ToPolygon">
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert this GIS non-standard shape to a GIS
            standard shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the current shape as a PolygonShape.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetPerimeterCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetAreaCore(ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>None</remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.RegisterCore(ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.DistanceUnit,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.RotateCore(ThinkGeo.MapSuite.Shapes.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetDistanceToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            In this method, we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The GeographUnit of the targetShape.</param>
            <param name="distanceUnit">The DistanceUnit of the returned value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetClosestPointToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetWellKnownTextCore(ThinkGeo.MapSuite.Shapes.RingOrder)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Shapes.RingOrder,ThinkGeo.MapSuite.Shapes.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.RingShape)">
            <summary>
            This method removes the selected vertex from ring shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of ring shape, otherwise it will return false and ring shape will keep the same.</param>
            <param name="ringShape">The line shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.RemoveVertex(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method removes the selected vertex from ring shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of ring shape, otherwise it will return false and ring shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.ValidateCore(ThinkGeo.MapSuite.Shapes.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.IsCounterClockwise">
            <summary>
            Tests whether a ring is oriented counter-clockwise.
            </summary>
            <returns>Returns true if ring is oriented counter-clockwise.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.ReversePoints">
            <summary>This method reverses the order of the points in the ring.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.RingShape.ReversePointsCore">
            <summary>This method reverses the order of the points in the ring.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ScreenPoint">
            <summary>This structure represents a single point in screen coordinates.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPoint.#ctor(System.Int32,System.Int32)">
            <summary>
            This constructor allows you to create a screen point by passing in an X &amp;
            Y.
            </summary>
            <remarks>None</remarks>
            <param name="x">This parameter represents the horizontal value of a screen point.</param>
            <param name="y">This parameter represents the vertical value of a screen point.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.ScreenPoint.X">
            <summary>This property returns the X, or horizontal, value of the screen point.</summary>
            <value>This property returns the X, or horizontal, value of the screen point.</value>
            <example>
            None
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.ScreenPoint.Y">
            <summary>This property returns the Y, or vertical, value of the screen point.</summary>
            <value>This property returns the Y, or vertical, value of the screen point.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPoint.op_Equality(ThinkGeo.MapSuite.Shapes.ScreenPoint,ThinkGeo.MapSuite.Shapes.ScreenPoint)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceScreenPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetScreenPoint, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <param name="screenPoint1">This parameter is the first screenPoint to compare with.</param>
            <param name="screenPoint2">This parameter is the second screenPoint to compare width.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPoint.op_Inequality(ThinkGeo.MapSuite.Shapes.ScreenPoint,ThinkGeo.MapSuite.Shapes.ScreenPoint)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="screenPoint1">This parameter represents the first GeoColor to compare.</param>
            <param name="screenPoint2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceScreenPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetScreenPoint, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPoint.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <returns>This method returns the Equals functionality.</returns>
            <remarks>None</remarks>
            <param name="obj">
            This parameter is the object you want to check to see if it is equal to the current
            instance.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the obj, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPoint.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <returns>This method returns the hash code.</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ScreenPointF">
            <summary>This structure represents a single point in screen coordinates.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPointF.#ctor(System.Single,System.Single)">
            <summary>
            This constructor allows you to create a screen point by passing in an X &amp;
            Y.
            </summary>
            <remarks>None</remarks>
            <param name="x">This parameter represents the horizontal value of a screen point.</param>
            <param name="y">This parameter represents the vertical value of a screen point.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.ScreenPointF.X">
            <summary>This property returns the X, or horizontal, value of the screen point.</summary>
            <value>This property returns the X, or horizontal, value of the screen point.</value>
            <example>
            None
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.ScreenPointF.Y">
            <summary>This property returns the Y, or vertical, value of the screen point.</summary>
            <value>This property returns the Y, or vertical, value of the screen point.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPointF.op_Equality(ThinkGeo.MapSuite.Shapes.ScreenPointF,ThinkGeo.MapSuite.Shapes.ScreenPointF)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceScreenPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetScreenPoint, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <param name="screenPointF1">This parameter is the first screenPoint to compare with.</param>
            <param name="screenPointF2">This parameter is the second screenPoint to compare width.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPointF.op_Inequality(ThinkGeo.MapSuite.Shapes.ScreenPointF,ThinkGeo.MapSuite.Shapes.ScreenPointF)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="screenPointF1">This parameter represents the first GeoColor to compare.</param>
            <param name="screenPointF2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceScreenPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetScreenPoint, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPointF.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <returns>This method returns the Equals functionality.</returns>
            <remarks>None</remarks>
            <param name="obj">
            This parameter is the object you want to check to see if it is equal to the current
            instance.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the obj, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ScreenPointF.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <returns>This method returns the hash code.</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ShapeValidationMode">
            <summary>This enumeration describes the type of validation test to run on shapes.</summary>
            <remarks>
            The simple tests are used internally before any method call is made to a shape.
            In this way, we have a certain level of confidence that the operation will succeed. The
            advanced tests are meant to be performed by users if they get a shape from an
            external source and consider it suspect.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.ShapeValidationMode.Simple">
            <summary>The simple tests are designed to be very fast.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.ShapeValidationMode.Advanced">
            <summary>
            The advanced tests are designed to be comprehensive with no regard to
            speed.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ShapeValidationResult">
            <summary>This structure represents the result of the validation method performed on a shape.</summary>
            <remarks>
            This is used to determine if an validation rule was broken for a shape. This
            structure also returns the description of the violation.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.#ctor(System.Boolean,System.String)">
            <summary>
            This constructor allows you to set the IsValid and ValidationErrors
            properties.
            </summary>
            <remarks>None</remarks>
            <param name="isValid">This parameter describes whether the object has passed its validation method.</param>
            <param name="validationErrors">
            This parameter describes the list of errors if the object did not pass its
            validation method. The errors are separated by semicolons.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.IsValid">
            <summary>This property describes whether the object has passed its validation method.</summary>
            <value>
            This property returns either true or false, depending on whether the object has passed its
            validation method.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.ValidationErrors">
            <summary>
            This property describes the list of errors if the object did not pass its
            validation method.
            </summary>
            <remarks>
            If there are multiple errors, they will be separated by semicolons. If the object
            passed its validations, then this string will be empty.
            </remarks>
            <value>
            This property returns the list of errors if the object did not pass its
            validation method.
            </value>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.op_Equality(ThinkGeo.MapSuite.Shapes.ShapeValidationResult,ThinkGeo.MapSuite.Shapes.ShapeValidationResult)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.op_Inequality(ThinkGeo.MapSuite.Shapes.ShapeValidationResult,ThinkGeo.MapSuite.Shapes.ShapeValidationResult)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ShapeValidationResult.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.ExtentHelper">
            <summary>
            This static class exposes a number of helpful methods when dealing with
            extents.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.CenterAt(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.PointShape,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a world point to center on, and a height
             and width in screen units.  The function will center the rectangle based on the point, then adjust the rectangle's
             ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a world point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="worldPoint">This parameter is the world point you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.CenterAt(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a world point to center on, and a height
             and width in screen units.  The function will center the rectangle based on the point, then adjust the rectangle's
             ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a world point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="centerFeature">This parameter is the world point you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.CenterAt(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an adjusted extent centered on a point.</summary>
            <overloads>This overload allows you to pass in a screen point as the center.</overloads>
            <returns>This method returns an adjusted extent centered on a point.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the current extent you want to center.</param>
            <param name="screenX">This parameter is the X coordinate on the screen to center on.</param>
            <param name="screenY">This parameter is the Y coordinate on the screen to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetBoundingBoxOfItems(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape})">
            <summary>
            This API gets the BoundingBox of a group of BaseShapes.
            </summary>
            <param name="shapes">The target group of BaseShapes to get the BoundingBox for.</param>
            <returns>The BoundingBox that contains all of the shapes you passed in.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetBoundingBoxOfItems(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature})">
            <summary>
            This API gets the BoundingBox of a group of Features.
            </summary>
            <param name="features">The target group of Features to get the BoundingBox for.</param>
            <returns>The BoundingBox that contains all the features you passed in.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetDrawingExtent(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single)">
            <summary>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </summary>
            <returns>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </returns>
            <remarks>
            This function is used because the extent to draw must be the rame ratio as the screen
            width and height. If they are not, then the image drawn will be stretched or compressed.
            We always adjust the extent upwards to ensure that no matter how we adjust it,
            the original extent will fit within the new extent. This ensures that everything
            you wanted to see in the first extent is visible and maybe a bit more.
            </remarks>
            <param name="worldExtent">This parameter is the world extent you want to adjust for drawing.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.PointShape,ThinkGeo.MapSuite.Shapes.PointShape,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two world points.</summary>
            <returns>This method returns the number of pixels between two world points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPoint1">This parameter is the first point -- the one you want to measure from.</param>
            <param name="worldPoint2">This parameter is the second point -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two features.</summary>
            <returns>This method returns the number of pixels between two features.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPointFeature1">This parameter is the first feature -- the one you want to measure from.</param>
            <param name="worldPointFeature2">This parameter is the second feature -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.ScreenPointF,ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the distance in world units between two screen points.</summary>
            <overloads>This overload allows you to pass in ScreenPointF as the points.</overloads>
            <returns>This method returns the distance in world units between two screen points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint1">This is the screen point you want to measure from.</param>
            <param name="screenPoint2">This is the screen point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="worldExtentUnit">This is the geographic unit of the world extent rectangle.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit)">
            <summary>This method returns the distance in world units between two screen points.</summary>
            <overloads>This overload allows you to pass in the X &amp; Y for each point.</overloads>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint1X">This parameter is the X of the point you want to measure from.</param>
            <param name="screenPoint1Y">This parameter is the Y of the point you want to measure from.</param>
            <param name="screenPoint2X">This parameter is the X of the point you want to measure to.</param>
            <param name="screenPoint2Y">This parameter is the Y of the point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="worldExtentUnit">This is the geographic unit of the world extent you passed in.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.Pan(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.PanDirection,System.Int32)">
            <summary>This method returns a panned extent.</summary>
            <overloads>
            This overload allows you to pass in a direction and a percentage by which you want to
            pan.
            </overloads>
            <returns>This method returns a panned extent.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to pan.</param>
            <param name="direction">This parameter is the direction in which you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.Pan(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Int32)">
            <summary>This method returns a panned extent.</summary>
            <overloads>
            This overload allows you to pass in an angle and a percentage by which you want to
            pan.
            </overloads>
            <returns>This method returns a panned extent.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to pan.</param>
            <param name="degree">This parameter is the degree you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ResizeExtent(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.MapResizeMode)">
            <summary>
            This method returns a RectangleShape by resize parameters.
            </summary>
            <param name="sourceExtent">The rectangle shape before rezise</param>
            <param name="sourceScreenWidth">The width of the source rectangle shape in screen coordinate</param>
            <param name="targetScreenWidth">The width of the target rectangle shape in screen coordinate</param>
            <param name="targetScreenHeight">The height of the target rectangle shape in screen coordinate</param>
            <param name="mapUnit">map unit which this rectangle shape used</param>
            <param name="resizeType">Represents resize type which can decide to use which way to resize.</param>
            <returns>This method returns a RectangleShape by resize parameters.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single)">
            <summary>This method returns Rectangle in screen coordinates from RectangleShape in world coordinates.</summary>
            <returns>This method returns Rectangle in screen coordinates from RectangleShape in world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="targetWorldExtent">This parameter is the rectangle shape in world coordinate you want converted to a rectangle in screen coordinate.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in world X &amp; Y coordinates.</overloads>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldX">This parameter is the world X you want converted to screen points.</param>
            <param name="worldY">This parameter is the world Y you want converted to screen points.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.PointShape,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPoint">This parameter is the world point you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPointFeature">This parameter is the feature you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ToWorldCoordinate(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates.</summary>
            <returns>This method returns world coordinates from screen coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenX">
            This parameter is the X of the point you want converted to world
            coordinates.
            </param>
            <param name="screenY">
            This parameter is the Y of the point you want converted to world
            coordinates.
            </param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ToWorldCoordinate(ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates.</summary>
            <returns>This method returns world coordinates from screen coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint">This parameter is the screen point you want converted to a world point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomIn(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32)">
            <summary>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomIntoCenter(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,ThinkGeo.MapSuite.Shapes.PointShape,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomIntoCenter(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinatesm
            as well as a feature.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="centerFeature">This parameter is the feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomIntoCenter(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screen X &amp; Y.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomIntoOffsetPoint(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single,ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Int32)">
            <summary>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</summary>
            <returns>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to afterward call GetDrawingExtent.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed.</param>
            <param name="percentage">This parameter is the percentage you want to zoom.</param>
            <param name="offsetScreenPoint">This parameter is the screen point you want to keep it constant.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomOut(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32)">
            <summary>
            This method returns a new extent that is zoomed out by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed out by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomOutToCenter(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,ThinkGeo.MapSuite.Shapes.PointShape,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomOutToCenter(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,ThinkGeo.MapSuite.Shapes.Feature,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a feature.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="centerFeature">This parameter is the feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomOutToCenter(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterward.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screen X &amp; Y.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomOutToOffsetPoint(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Single,System.Single,ThinkGeo.MapSuite.Shapes.ScreenPointF,System.Int32)">
            <summary>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</summary>
            <returns>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to afterward call GetDrawingExtent.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed.</param>
            <param name="percentage">This parameter is the percentage you want to zoom.</param>
            <param name="offsetScreenPoint">This parameter is the screen point you want to keep it constant.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomToScale(System.Double,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.GeographyUnit,System.Single,System.Single)">
            <summary>This method returns a extent that has been zoomed into a certain scale.</summary>
            <returns>This method returns a extent that has been zoomed into a certain scale.</returns>
            <remarks>None</remarks>
            <param name="targetScale">This parameter is the scale you want to zoom into.</param>
            <param name="worldExtent">This parameter is the world extent you want zoomed into the scale.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.ExtentHelper.ZoomToScale(System.Double,ThinkGeo.MapSuite.Shapes.RectangleShape,ThinkGeo.MapSuite.GeographyUnit,System.Single,System.Single,ThinkGeo.MapSuite.Shapes.ScreenPointF)">
            <summary>This method returns a extent that has been zoomed into a certain scale.</summary>
            <returns>This method returns a extent that has been zoomed into a certain scale.</returns>
            <remarks>None</remarks>
            <param name="targetScale">This parameter is the scale you want to zoom into.</param>
            <param name="worldExtent">This parameter is the world extent you want zoomed into the scale.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
            <param name="offsetScreenPoint">This parameter is the offsetScreenPoint.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.MapResizeMode">
            <summary>
            The enumeration represents which mode will use for map resize.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.MapResizeMode.PreserveScale">
            <summary>
            This item represents that preserve the scale the same when map resize.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.MapResizeMode.PreserveScaleAndCenter">
            <summary>
            This item represents that preserve the scale the same and fix the center point of extent when map resize.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.MapResizeMode.PreserveExtent">
            <summary>
            This item represents that preserve the extent the same as before when map resize.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.SimplificationType">
            <summary>
            Specifies which algorthm will be use to simplify.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.SimplificationType.TopologyPreserving">
            <summary>
            Simplifies a point, ensuring that the result is a valid point having the same dimension and number of components as the input. The simplification uses a maximum distance difference algorithm similar to the one used in the Douglas-Peucker algorithm. In particular, if the input is an areal point ( Polygon or MultiPolygon ) The result has the same number of shells and holes (rings) as the input, in the same order The result rings touch at no more than the number of touching point in the input (although they may touch at fewer points).
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.SimplificationType.DouglasPeucker">
            <summary>
            Simplifies a Geometry using the standard Douglas-Peucker algorithm. Ensures that any polygonal geometries returned are valid. Simple lines are not guaranteed to remain simple after simplification. Note that in general D-P does not preserve topology - e.g. polygons can be split, collapse to lines or disappear holes can be created or disappear, and lines can cross. To simplify point while preserving topology use TopologySafeSimplifier. (However, using D-P is significantly faster).
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.StartingPoint">
            <summary>
            An enumeration describing the place to start on a line when doing certain
            operations.
            </summary>
            <remarks>
            Certain kinds of mathematical line operations need to know if the operation
            will start at the beginning or the end of the line. Whenever this is the case, you'll
            need to use this enumeration.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.StartingPoint.FirstPoint">
            <summary>The first point of the line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.StartingPoint.LastPoint">
            <summary>The last point of the line.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.Vertex">
            <summary>
            This structure represents the point at which the sides of an angle
            intersect.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.#ctor(System.Double,System.Double)">
            <summary>This is the constructor used to create a vertex.</summary>
            <remarks>None</remarks>
            <overloads>This constructor takes X and Y coordinates.</overloads>
            <param name="x">This parameter represents the horizontal value.</param>
            <param name="y">This parameter represents the vertical value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.#ctor(ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>This is the constructor used to create a vertex.</summary>
            <overloads>This constructor takes a PointShape.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="point">This parameter is the PointShape you want to convert to a Vertex.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Vertex.X">
            <summary>This property returns the horizontal value of the vertex.</summary>
            <value>This property returns the horizontal value of the vertex.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Shapes.Vertex.Y">
            <summary>This property returns the vertical value of the vertex.</summary>
            <value>This property returns the vertical value of the vertex.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.ToString">
            <summary>This method is an override of the ToString functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.Add(ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>This method adds the target vertex to the current vertex.</summary>
            <remarks>None</remarks>
            <param name="targetVertex">
            This parameter represents the vertex you wish to add to the current
            vertex.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.op_Addition(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>This method is an override of the + functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to add.</param>
            <param name="vertex2">This parameter represents the second vertex to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.op_Equality(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to compare.</param>
            <param name="vertex2">This parameter represents the second vertex to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.op_Inequality(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to compare.</param>
            <param name="vertex2">This parameter represents the second vertex to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Shapes.Vertex.FindMiddleVertexBetweenTwoVertices(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.Vertex)">
            <summary>
            This method returns the middle Vertex of a straight line which two vertices are passing in.
            </summary>
            <param name="vertex1">start vertex of a straight line</param>
            <param name="vertex2">en vertex of a straight line</param>
            <returns>This method returns the middle Vertex between the vertices which passing in.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.WellKnownType">
            <summary>
            This describes a set of enumerations that list the valid types of
            geometries.
            </summary>
            <remarks>
            Each of the geometries listed is either a subset or compatible with the OpenGIS
            specifications or the simple feature specifications. Each different kind of geometry
            can also be converted to well-known text and well-known binary. We have added some
            additional geometry types (such as the ellipse and rectangle) which normally are not
            included as separate GIS geometries but are very useful and can easily be converted to
            standard types.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Invalid">
            <summary>
            An invalid shape type.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Point">
            <summary>
            A Point is a geometry that represents a single location in coordinate
            space.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Line">
            <summary>A Line is a curve with linear interpolation between points.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Polygon">
            <summary>
            A Polygon is a planar surface representing a multisided geometry. It is defined
            by a single exterior boundary and zero or more interior boundaries, where each interior
            boundary defines a hole in the Polygon.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Multipoint">
            <summary>
            A MultiPoint is a geometry collection composed of Point elements. The points are
            not connected or ordered in any way.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Multiline">
            <summary>A MultiLine is a geometry collection composed of Line elements.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.Multipolygon">
            <summary>A MultiPolygon is a object composed of one or more Polygon elements.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WellKnownType.GeometryCollection">
            <summary>A GeometryCollection is a object composed of one or more Shape elements.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Shapes.WkbByteOrder">
            <summary>
            This enumeration represents the byte order that well-known binary will be written
            in.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WkbByteOrder.LittleEndian">
            <summary>The least significant byte value is at the lowest address.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Shapes.WkbByteOrder.BigEndian">
            <summary>The most significant byte value is at the lowest address.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.AreaStyleAdvanced">
            <summary>This class represents the advanced drawing options for area styles.</summary>
            <remarks>
            This class allows you to set the FillCustomBrush. This enables you to use custom
            brushes to achieve effects such as linear gradients and bitmap fills.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyleAdvanced.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyleAdvanced.FillCustomBrush">
            <summary>This property allows you to get and set a custom fill brush.</summary>
            <value>This property returns a custom fill brush.</value>
            <remarks>
            This allows you to use custom brushes to achieve effects such as linear gradients and
            bitmap fills. If you use any brush besides the SolidBrush, you would set it in this
            property.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyleAdvanced.CloneDeep">
            <summary>Create a copy of AreaStyleAdvanced class using the deep clone process.</summary>
            <returns>A cloned AreaStyleAdvanced.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.SymbolSolidBrush">
            <summary>
            This property gets and sets the SolidBrush used to color the interior of the
            Symbol.
            </summary>
            <remarks>
            This brush is used to draw the interior of the symbol. It is only used if the
            PointType is Symbol. If you need a brush other than the SolidBrush, you should look in
            the advanced property of the class.
            </remarks>
            <value>
            This property gets the SolidBrush used to color the interior of the
            Symbol.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.SymbolPen">
            <summary>
            This property gets and sets the SolidBrush used to draw the oultine of the
            Symbol.
            </summary>
            <value>This property gets the SolidBrush used to draw the outline of the Symbol.</value>
            <remarks>
            This pen is used to draw the outline of the Symbol. By default the pen draws a
            transparent (invisible) color, which just leaves you with a fill.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.SymbolSize">
            <summary>
            This property gets and sets the size of the symbol if the PointType is
            Symbol.
            </summary>
            <value>This property gets the size of the symbol if the PointType is Symbol.</value>
            <remarks>The allows you to make the symbol larger and smaller.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.RotationAngle">
            <summary>
            This property gets and sets the angle of rotation for the drawing of the
            point.
            </summary>
            <value>This property gets the angle of rotation for the drawing of the point.</value>
            <remarks>
            This property controls the rotation of the bitmap, character or symbol, depending
            on the PointType.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointBaseStyle.CustomPointStyles">
            <summary>
            This property returns a collection of area styles allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection, you can stack multiple styles on top of each other.
            When we draw the feature, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointBaseStyle.DrawSampleCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PointStyleAdvanced">
            <summary>This class represents the advanced drawing options for point styles.</summary>
            <remarks>
            This class allows you to set the CustomBrush. This enables you to use custom
            brushes to achieve effects such as linear gradients and bitmap fills.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyleAdvanced.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyleAdvanced.CustomBrush">
            <summary>This property allows you to get and set a custom brush.</summary>
            <value>This property returns a custom brush.</value>
            <remarks>
            This allows you to use custom brushes to achieve effects such as linear gradients and
            bitmap fills. If you use any brush besides the SolidBrush, you would set it in this
            property.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.Style">
            <summary>This abstract class is the root for all styles used for drawing features.</summary>
            <remarks>
            If you need to create your own style in the future, we suggest that you first
            consider extending an existing style. If you are doing something new, then you can
            inherit from this class.<br/>
            	<br/>
            The key method to override is DrawCore. If you want to provide a sample for the
            legend, you will also want to extend the DrawSampleCore.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.#ctor">
            <summary>
            This is the default constructor for the style and should be called by inherited
            classes.
            </summary>
            <returns>None</returns>
            <remarks>
            This is the default constructor for the style and should be called by inherited
            classes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.Style.Name">
            <summary>This property gets and set the name of the style.</summary>
            <value>This property gets the name of the style.</value>
            <remarks>
            This name is not used by the system; it is only for the developer. However, it can be used if
            you generate your own legend.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.Style.IsActive">
            <summary>This property gets and sets the active status of the style.</summary>
            <value>This property gets the active status of the style.</value>
            <remarks>If the style is not active then it will not draw.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.Style.RequiredColumnNames">
            <summary>
            This property gets the collection of fields that are required for the
            style.
            </summary>
            <value>
            This property gets the collection of fields that are required for the
            style.
            </value>
            <remarks>
            This property gets the collection of fields that are required for the style.
            These are in addition to any other columns you specify in styles that inherit from this
            one. For example, if you have use a ValueStyle and it requires a column name for the
            value comparison, then that column does not need to be in this collection. You only use
            the RequiredColumnNames for columns you need beyond those required by specific
            inherited styles.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.CloneDeep">
            <summary>Create a copy of style using the deep clone process.</summary>
            <returns>A cloned style.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.CloneDeepCore">
            <summary>Create a copy of style using the deep clone process. The default implementation method uses serialization.</summary>
            <returns>A cloned style.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. In this
                method, we take the features you passed in and draw them on the canvas you provided.
                Each style (based on its properties) may draw each feature differently.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.BaseShape},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the shapes on the canvas you provided.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. In this
                method, we take the shapes you passed in and draw them on the canvas you provided.
                Each style (based on its properties) may draw each shape differently.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="shapes">This parameter represents the shapes you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the shapes on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.GetRequiredColumnNames">
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that the style needs.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                GetRequiredColumnNamesCore. In this method, we return the column names that are
                required for the style to draw the feature properly. For example, if you have a
                style that colors areas blue when a certain column value is over 100, then you need
                to be sure you include that column name. This will ensure that the column data is
                returned to you in the feature when it is ready to draw.<br/>
            		<br/>
                In many of the styles, we add properties to allow the user to specify which field
                they need; then, in the GetRequiredColumnNamesCore we read that property and add it
                to the collection.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that the style needs.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.DrawSample(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawSampleCore.
                In this method we draw a sample style on the canvas you provided. This is typically
                used to display a legend or other sample area.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.Style.DrawSampleCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            	<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.TextStyleAdvanced">
            <summary>This class represents the advanced drawing options for text styles.</summary>
            <remarks>
            This class allows you to set the TextCustomBrush. This enables you to use custom
            brushes to achieve effects such as linear gradients and bitmap fills.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyleAdvanced.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyleAdvanced.TextCustomBrush">
            <summary>This property allows you to get and set a custom  brush.</summary>
            <value>This property returns a custom brush.</value>
            <remarks>
            This allows you to use custom brushes to achieve effects such as linear gradients and
            bitmap fills. If you use any brush besides the SolidBrush, you would set it in this
            property.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.AreaStyle">
            <summary>This class is used to draw area features.</summary>
            <remarks>
            You should use this class to draw area features. You can specify a fill brush to
            draw the interior and an outline pen to draw the border. You can optionally choose to
            use only the outline pen or the fill brush, which enables you to generate different effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor does not specify an outline pen or fill brush.</overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you will need to set the properties of the fill brush
            and outline pen manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoSolidBrush)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor allows you to specify a fill brush without an outline.</overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to specify just a fill brush. In this way, the area
            you draw will not have an outline.
            </remarks>
            <param name="fillSolidBrush">This parameter is the solid brush you want to fill the area with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen)">
            <summary>This is the constructor for the class.</summary>
            <remarks>
            This constructor allows you to specify just an outline pen. In this way, the area
            you draw will have an outline, but a transparent interior (no fill).
            </remarks>
            <overloads>
            This constructor allows you to specify an outline pen without a filled-in
            area.
            </overloads>
            <returns>None</returns>
            <param name="outlinePen">This parameter is the outline pen you want to use to outline the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoSolidBrush)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify an outline pen with a filled-in
            area.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor allows you to specify a fill brush and an outline pen.</remarks>
            <param name="outlinePen">This parameter is the outline pen you want to use to outline the area.</param>
            <param name="fillSolidBrush">This parameter is the solid brush you wish to fill the area with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoSolidBrush,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify an outline pen with a filled-in area. It
            also lets you select whether the pen or brush is used first.
            </overloads>
            <remarks>
            This constructor allows you to specify a fill brush and an outline pen. It also
            allows you to specify which is drawn first. If the pen is drawn first, the outline
            will be thinner than if the pen is drawn last. The effect is subtle but
            noticeable.
            </remarks>
            <returns>None</returns>
            <param name="outlinePen">This parameter is the outline pen you want to use to outline the area.</param>
            <param name="fillSolidBrush">This parameter is the solid brush you wish to fill the area with.</param>
            <param name="penBrushDrawingOrder">
            This parameter allows you to choose whether the outline pen or the fill brush is drawn
            first.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it
            enables you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.YOffsetInPixel">
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it
            enables you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to align it with raster
            satellite data.
            </remarks>
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.FillSolidBrush">
            <summary>
            This property gets and sets the solid brush you want to use to fill in the area
            features.
            </summary>
            <value>
            This property represents the solid brush you want to use to fill in the area
            features.
            </value>
            <remarks>
            This solid brush is used to fill in the area features that will draw. You can also
            optionally specify an outline pen to give the area an outline. The default solid
            brush has a fill color of transparent, which means it will not draw anything.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.CustomAreaStyles">
            <summary>
            This property returns a collection of area styles, allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection, you can stack multiple area styles on top of each other.
            When we draw the features, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.OutlinePen">
            <summary>
            This property gets and sets the outline pen you want to use to outline the
            features.
            </summary>
            <value>
            This property gets the outline pen you want to use to outline the
            features.
            </value>
            <remarks>
            This outline pen is used to outline the features that will draw. You can also
            optionally specify a fill brush to give the area a solid fill. The default outline
            pen color is transparent, which means it will not draw anything.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.PenBrushDrawingOrder">
            <summary>This property gets and sets the pen and brush drawing order.</summary>
            <value>This property gets the pen and brush drawing order.</value>
            <remarks>
            This property controls whether the outline pen or the fill brush is drawn first. The
            default is for the fill brush to be drawn first. If you have the outline pen draw first
            then the thickness of the pen will be smaller, creating a subtle but noticeable
            effect.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyle.Advanced">
            <summary>This property lets you access the advanced properties of the style.</summary>
            <value>This property lets you access the advanced properties of the style.</value>
            <remarks>This property lets you access the advanced properties of the style.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyle.DrawSampleCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.AreaStyles">
            <summary>
            This class is a collection of predefined styles and helper methods for creating
            styles.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.NoData1">
            <summary>This property gets a style that represents NoData1.</summary>
            <value>This property gets a style that represents NoData1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Water1">
            <summary>This property gets a style that represents Water1.</summary>
            <value>This property gets a style that represents Water1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Water2">
            <summary>This property gets a style that represents Water2.</summary>
            <value>This property gets a style that represents Water2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Military1">
            <summary>This property gets a style that represents Military1.</summary>
            <value>This property gets a style that represents Military1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Wildlife1">
            <summary>This property gets a style that represents Wildlife1.</summary>
            <value>This property gets a style that represents Wildlife1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.State1">
            <summary>This property gets a style that represents State1.</summary>
            <value>This property gets a style that represents State1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.State2">
            <summary>This property gets a style that represents State2.</summary>
            <value>This property gets a style that represents State2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.County1">
            <summary>This property gets a style that represents County1.</summary>
            <value>This property gets a style that represents County1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.County2">
            <summary>This property gets a style that represents County2.</summary>
            <value>This property gets a style that represents County2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Country1">
            <summary>This property gets a style that represents Country1.</summary>
            <value>This property gets a style that represents Country1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Country2">
            <summary>This property gets a style that represents Country2.</summary>
            <value>This property gets a style that represents Country2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Swamp1">
            <summary>This property gets a style that represents Swamp1.</summary>
            <value>This property gets a style that represents Swamp1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Swamp2">
            <summary>This property gets a style that represents Swamp2.</summary>
            <value>This property gets a style that represents Swamp2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Urban1">
            <summary>This property gets a style that represents Urban1.</summary>
            <value>This property gets a style that represents Urban1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Urban2">
            <summary>This property gets a style that represents Urban2.</summary>
            <value>This property gets a style that represents Urban2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Antarctica1">
            <summary>This property gets a style that represents Antarctica1.</summary>
            <value>This property gets a style that represents Antarctica1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Evergreen1">
            <summary>This property gets a style that represents Evergreen1.</summary>
            <value>This property gets a style that represents Evergreen1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Evergreen2">
            <summary>This property gets a style that represents Evergreen2.</summary>
            <value>This property gets a style that represents Evergreen2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Grass1">
            <summary>This property gets a style that represents Grass1.</summary>
            <value>This property gets a style that represents Grass1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.WaterIntermittent1">
            <summary>This property gets a style that represents WaterIntermittent1.</summary>
            <value>This property gets a style that represents WaterIntermittent1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Sand1">
            <summary>This property gets a style that represents Sand1.</summary>
            <value>This property gets a style that represents Sand1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.SeaIce1">
            <summary>This property gets a style that represents SeaIce1.</summary>
            <value>This property gets a style that represents SeaIce1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.SnowIce1">
            <summary>This property gets a style that represents SnowIce1.</summary>
            <value>This property gets a style that represents SnowIce1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Tundra1">
            <summary>This property gets a style that represents Tundra1.</summary>
            <value>This property gets a style that represents Tundra1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Crop1">
            <summary>This property gets a style that represents Crop1.</summary>
            <value>This property gets a style that represents Crop1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Forest1">
            <summary>This property gets a style that represents Forest1.</summary>
            <value>This property gets a style that represents Forest1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.AreaStyles.Park1">
            <summary>This property gets a style that represents Park1.</summary>
            <value>This property gets a style that represents Park1.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to specify just a fill color.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color of the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to provide a fill and an outline.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to pass the fill color, pen color and pen width.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
            <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.LineDashStyle)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to pass the fill color, pen color and pen width.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
            <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
            <param name="borderStyle"> This parameter is the BorderStyle for the area style.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single)">
            <summary>This method builds a simple area style.</summary>
            <returns>This method builds a simple area style.</returns>
            <overloads>
            This overload allows you to pass in the fill color and a pixel offset in X &amp;
            Y.
            </overloads>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
            <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single)">
            <summary>This method builds a simple area style.</summary>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to provide a fill, outline color and offset in X &amp;
            Y.
            </overloads>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline color for the area.</param>
            <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
            <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,System.Single,System.Single)">
            <summary>This method builds a simple area style.</summary>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to pass the fill color, pen color, pen width and X &amp;
            Y offset.
            </overloads>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
            <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
            <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
            <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.LineDashStyle,System.Single,System.Single)">
             <summary>This method builds a simple area style.</summary>
             <returns>This method builds a simple area style.</returns>
             <remarks>None</remarks>
             <overloads>
             This overload allows you to pass the fill color, pen color, pen width and X &amp;
             Y offset.
             </overloads>
             <param name="fillBrushColor">This parameter is the fill color for the area.</param>
             <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
             <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
            <param name="borderStyle"> This parameter is the BorderStyle for the area.</param>
             <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
             <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateHatchStyle(ThinkGeo.MapSuite.Drawing.GeoHatchStyle,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method returns an AreaStyle with a hatch pattern.</summary>
            <overloads>This overload allows you to specify the background and foreground color.</overloads>
            <returns>This property is the color of the foreground of the hatch pattern.</returns>
            <remarks>None</remarks>
            <param name="hatchStyle">This parameter is the hatch pattern to be used.</param>
            <param name="foregroundBrushColor">This property is the color of the foreground of the hatch pattern.</param>
            <param name="backgroundBrushColor">This property is the color of the background of the hatch pattern.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateHatchStyle(ThinkGeo.MapSuite.Drawing.GeoHatchStyle,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method returns an AreaStyle with a hatch pattern.</summary>
            <returns>This method returns an AreaStyle with a hatch pattern.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to specify the background color, foreground color, and a
            border color.
            </overloads>
            <param name="hatchStyle">This parameter is the hatch pattern to be used.</param>
            <param name="foregroundBrushColor">This property is the color of the foreground of the hatch pattern.</param>
            <param name="backgroundBrushColor">This property is the color of the background of the hatch pattern.</param>
            <param name="outlinePenColor">This parameter is the border color for the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateHatchStyle(ThinkGeo.MapSuite.Drawing.GeoHatchStyle,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.LineDashStyle,System.Single,System.Single)">
            <summary>This method returns a GeoHatchStyle.</summary>
            <requirements>None</requirements>
            <returns>This method returns an AreaStyle with a hatch pattern.</returns>
            <overloads>
            This overload allows you to specify the background color, foreground color,
            border color and many other parameters.
            </overloads>
            <param name="hatchStyle">This parameter is the hatch pattern to be used.</param>
            <param name="foregroundBrushColor">This property is the color of the foreground of the hatch pattern.</param>
            <param name="backgroundColor">This property is the color of the background of the hatch pattern.</param>
            <param name="outlinePenColor">This parameter is the border color for the area.</param>
            <param name="outlinePenWidth">This parameter is the border width for the area.</param>
            <param name="outlineDashStyle">This parameter is the dahs style to be used for the border.</param>
            <param name="xOffsetInPixel">This parameter is the pixel offset for X.</param>
            <param name="yOffsetInPixel">This parameter is the pixel offset for Y.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateLinearGradientStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>This method returns a linear gradient style.</summary>
            <returns>This method returns an AreaStyle.</returns>
            <remarks>None</remarks>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">
            This parameter represents the angle of the color changing from start to
            end.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateLinearGradientStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>This method returns a linear gradient style.</summary>
            <returns>This method returns an AreaStyle.</returns>
            <remarks>None</remarks>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">
            This parameter represents the angle of the color changing from start to
            end.
            </param>
            <param name="outlinePenColor">This parameter represents the outline pen color of the area style.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateHueFamilyAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>This method returns an AreaStyle.</summary>
            <returns>This method returns an AreaStyle.</returns>
            <remarks>None.</remarks>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the area
            style.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> of the hue family colors.</param>
            <param name="numberOfColors">The number of GeoColors in hue family to construct the
            areastyle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateHueFamilyLinearGradientAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>This method returns an AreaStyle in a family of hue-related colors drawn with a linear gradient.</summary>
            <returns>This method returns an AreaStyle in a family of hue-related colors drawn with a linear gradient.</returns>
            <remarks>None.</remarks>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the AreaStyle.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> for the hue family of colors.</param>
            <param name="numberOfColors">The number of GeoColors in the hue family to construct the
            AreaStyle.</param>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">This parameter represents the angle for the gradient.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateQualityFamilyAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>This method returns an AreaStyle in a family of quality-realted colors.</summary>
            <returns>This method returns an AreaStyle in a family of quality-realted colors.</returns>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the
            AreaStyle.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> for the quality family of colors.</param>
            <param name="numberOfColors">The number of GeoColors in the quality-based family to construct the AreaStyle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.AreaStyles.CreateQualityFamilyLinearGradientAreaStyle(ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>This method returns an AreaStyle in a family of quality-related colors drawn with a linear gradient.</summary>
            <returns>This method returns an AreaStyle in a family of quality-related colors drawn with a linear gradient.</returns>
            <remarks>None.</remarks>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the
            AreaStyle.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> for the quality family of colors.</param>
            <param name="numberOfColors">The number of GeoColors in quality-based family to construct the AreaStyle.</param>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">This parameter represents the angle for the gradient.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle">
            <summary>This class is used to draw area features.</summary>
            <remarks>
            You should use this class to draw area features. You can specify a base color and the number of
            colors you want based on that color to draw the interior, and you can specify an outline pen
            with which to draw the border. You can optionally choose to
            use only the outline pen or the fill brush to generate different effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.#ctor">
            <summary>This is the constructor for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
            <param name="penBrushDrawingOrder">This parameter describes the PenBrushDrawingOrder that will be used when drawing the area type feature.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.NumberOfColors">
            <summary>This gets or sets the number of colors in the style.</summary>
            <value>This gets or sets the number of colors in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.Cache">
            <summary>This gets the cached style in the class.</summary>
            <value>This gets the cached style in the class.</value>
            <remarks>
            This gets the cached style in the class. The key of the style in the cache is
            feature.Id &amp; feature.GetHashCode().
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.BaseColor">
            <summary>This gets or sets the base color of the style.</summary>
            <value>This gets or sets the base color of the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.ClearCache">
            <summary>This method clears the cached style in the cache.</summary>
            <returns>None.</returns>
            <remarks>This method clears the cached style in the cache.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.HueFamilyAreaStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.LabelDuplicateRule">
            <summary>This enumeration defines the different labeling duplicate rules.</summary>
            <remarks>
            Duplicate refers to the condition where a label's text is exactly the same as another label.
            An example case where this is common is a road where each intersection is its own segment.
            In such a case, you do not want to label each segment as it would be highly redundant.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.LabelDuplicateRule.OneDuplicateLabelPerQuadrant">
            <summary>There may be only one label in each of the four quadrants.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.LabelDuplicateRule.NoDuplicateLabels">
            <summary>There may be no duplicate labels.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.LabelDuplicateRule.UnlimitedDuplicateLabels">
            <summary>There may be an unlimited number of duplicate labels.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.LabelInformation">
            <summary>
            This class represents the location of a piece of a label that may be
            drawn.
            </summary>
            <remarks>
            This class is used within the labeling logic, specifically in the labeling
            candidate. The object may represent an entire label or, in the case of a label spline,
            a single character in the label.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LabelInformation.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <remarks>
            If you use this constructor, you should set the various properties
            manually.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LabelInformation.#ctor(ThinkGeo.MapSuite.Shapes.PointShape,System.String,System.Double)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor allows you to set all of the class properties.</overloads>
            <remarks>None</remarks>
            <returns>None</returns>
            <param name="positionInScreenCoordinates">This parameter is the position of the label that may draw.</param>
            <param name="text">This parameter is the text for the label.</param>
            <param name="rotationAngle">This parameter is the angle of rotation for the label.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelInformation.PositionInScreenCoordinates">
            <summary>
            This property gets and sets the position of a piece of a label, in screen
            coordinates.
            </summary>
            <value>
            This property gets the position of a piece of a label, in screen
            coordinates.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelInformation.Text">
            <summary>This property gets and sets the text of the label.</summary>
            <value>This property gets the text of the label.</value>
            <remarks>This may be the entire label text or a single character.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelInformation.RotationAngle">
            <summary>This property gets and sets the angle of rotation for the label.</summary>
            <value>This property gets the angle of rotation for the label.</value>
            <remarks>
            This could be the rotation of the entire label text, a single character, or a set of
            characters.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.LabelingCandidate">
            <summary>This class represents a candidate for labeling.</summary>
            <remarks>
            This class is used in the internals of the labeling system. We keep track of
            every potential label in this class as it goes through the labeling rules.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LabelingCandidate.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you should set the applicable properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LabelingCandidate.#ctor(System.String,ThinkGeo.MapSuite.Shapes.PolygonShape,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the area of the label as well as the center
            point.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
            <param name="simplePolygonInScreenCoordinates">This parameter is a polygon (in screen coordinates) representing the area to be labeled.</param>
            <param name="centerPointInScreenCoordinates">
            This parameter is the center of the polygon (in screen coordinates) representing the area to
            be labeled.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LabelingCandidate.#ctor(System.String,ThinkGeo.MapSuite.Shapes.PolygonShape,ThinkGeo.MapSuite.Shapes.PointShape,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.LabelInformation})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the area of the label and the center
            point.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
            <param name="simplePolygonInScreenCoordinates">This parameter is a polygon (in screen coordinates) representing the area to be labeled.</param>
            <param name="centerPointInScreenCoordinates">
            This parameter is the center of the polygon (in screen coordinates) representing the area to
            be labeled.
            </param>
            <param name="labelInformation">This parameter is the labeling information for this labeling candidate.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelingCandidate.OriginalText">
            <summary>This property gets and sets the original text for the label.</summary>
            <value>This property gets the original text for the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelingCandidate.ScreenArea">
            <summary>This property gets and sets the screen area that encompasses the label.</summary>
            <value>This property gets the screen area that encompasses the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelingCandidate.CenterPoint">
            <summary>This property gets and sets the center point for the center of the label.</summary>
            <value>This property gets the center point for the center of the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LabelingCandidate.LabelInformation">
            <summary>This property gets and sets the label information for this label.</summary>
            <value>This property gets the label information for this label.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.LabelOverlappingRule">
            <summary>This enumeration defines the rules for overlapping.</summary>
            <remarks>
            This defines the rules for label overlapping. Currently, either we allow overlapping or we
            do not. In the future, we may extend this to allow some percentage of partial
            overlapping.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.LabelOverlappingRule.NoOverlapping">
            <summary>No overlapping is allowed.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.LabelOverlappingRule.AllowOverlapping">
            <summary>Overlapping is allowed.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.LineStyle">
            <summary>This class is the style used to draw lines.</summary>
            <remarks>
            This class is commonly used to draw lines on the GeoCanvas. It is specialized for
            drawing roads, as this is the main kind of line feature that is most often drawn. You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in a single outer pen. Use this when you do
            not need any additional pens to draw the feature.
            </overloads>
            <remarks>Use this when you do not need any additional pens to draw the feature.</remarks>
            <param name="outerPen">This parameter is the outer pen used to draw the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoPen)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in an outer and inner pen. This is common for
            drawing roads.
            </overloads>
            <remarks>This is a common constructor for drawing roads.</remarks>
            <param name="outerPen">This parameter is the outer pen used to draw the feature.</param>
            <param name="innerPen">This parameter is the inner pen used to draw the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoPen)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in an outer, inner and center pen. This is
            common for drawing low level highways with center lines.
            </overloads>
            <remarks>This is common for drawing low level highways with center lines.</remarks>
            <param name="outerPen">This parameter is the outer pen used to draw the feature.</param>
            <param name="innerPen">This parameter is the inner pen used to draw the feature.</param>
            <param name="centerPen">This parameter is the center pen used to draw the feature.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyle.CustomLineStyles">
            <summary>
            This property returns a collection of line styles, allowing you to stack multiple
            line styles on top of each other.
            </summary>
            <value>This property returns a collection of line styles.</value>
            <remarks>
            Using this collection, you can stack multiple styles on top of each other.
            When we draw the feature, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyle.OuterPen">
            <summary>This property gets and sets the outer pen for the line.</summary>
            <value>This property gets the outer pen for the line.</value>
            <remarks>
            You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyle.InnerPen">
            <remarks>
            You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
            <summary>This property gets and sets the inner pen for the line.</summary>
            <value>This property gets the inner pen for the line.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyle.CenterPen">
            <remarks>
            You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
            <summary>This property gets and sets the center pen for the line.</summary>
            <value>This property gets the center pen for the line.</value>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OuterPen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If InnerPen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If CenterPen is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyle.DrawSampleCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.LineStyles">
            <summary>
            This class is a collection of predefined styles and helper methods to create
            styles.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.LocalRoad1">
            <summary>This property gets a style that represents LocalRoad1.</summary>
            <value>This property gets a style that represents LocalRoad1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.LocalRoad2">
            <summary>This property gets a style that represents LocalRoad2.</summary>
            <value>This property gets a style that represents LocalRoad2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.LocalRoad3">
            <summary>This property gets a style that represents LocalRoad3.</summary>
            <value>This property gets a style that represents LocalRoad3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.LocalRoad4">
            <summary>This property gets a style that represents LocalRoad4.</summary>
            <value>This property gets a style that represents LocalRoad4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.SecondaryRoad1">
            <summary>This property gets a style that represents SecondaryRoad1.</summary>
            <value>This property gets a style that represents SecondaryRoad1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.SecondaryRoad2">
            <summary>This property gets a style that represents SecondaryRoad2.</summary>
            <value>This property gets a style that represents SecondaryRoad2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorRoad1">
            <summary>This property gets a style that represents MajorRoad1.</summary>
            <value>This property gets a style that represents MajorRoad1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorRoad2">
            <summary>This property gets a style that represents MajorRoad2.</summary>
            <value>This property gets a style that represents MajorRoad2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorRoad3">
            <summary>This property gets a style that represents MajorRoad3.</summary>
            <value>This property gets a style that represents MajorRoad3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorRoad4">
            <summary>This property gets a style that represents MajorRoad4.</summary>
            <value>This property gets a style that represents MajorRoad4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorStreet1">
            <summary>This property gets a style that represents MajorStreet1.</summary>
            <value>This property gets a style that represents MajorStreet1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorStreet2">
            <summary>This property gets a style that represents MajorStreet2.</summary>
            <value>This property gets a style that represents MajorStreet2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.MajorStreet3">
            <summary>This property gets a style that represents MajorStreet3.</summary>
            <value>This property gets a style that represents MajorStreet3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Highway1">
            <summary>This property gets a style that represents Highway1.</summary>
            <value>This property gets a style that represents Highway1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Highway2">
            <summary>This property gets a style that represents Highway2.</summary>
            <value>This property gets a style that represents Highway2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Highway3">
            <summary>This property gets a style that represents Highway3.</summary>
            <value>This property gets a style that represents Highway3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Highway4">
            <summary>This property gets a style that represents Highway4.</summary>
            <value>This property gets a style that represents Highway4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Highway5">
            <summary>This property gets a style that represents Highway5.</summary>
            <value>This property gets a style that represents Highway5.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Interstate1">
            <summary>This property gets a style that represents Interstate1.</summary>
            <value>This property gets a style that represents Interstate1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Interstate2">
            <summary>This property gets a style that represents Interstate2.</summary>
            <value>This property gets a style that represents Interstate2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Interstate3">
            <summary>This property gets a style that represents Interstate3.</summary>
            <value>This property gets a style that represents Interstate3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Interstate4">
            <summary>This property gets a style that represents Interstate4.</summary>
            <value>This property gets a style that represents Interstate4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.InternationalBorder1">
            <summary>This property gets a style that represents InternationalBorder1.</summary>
            <value>This property gets a style that represents InternationalBorder1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.InternationalBorder2">
            <summary>This property gets a style that represents InternationalBorder2.</summary>
            <value>This property gets a style that represents InternationalBorder2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Railway1">
            <summary>This property gets a style that represents Railway1.</summary>
            <value>This property gets a style that represents Railway1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Railway2">
            <summary>This property gets a style that represents Railway2.</summary>
            <value>This property gets a style that represents Railway2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Railway3">
            <summary>This property gets a style that represents Railway3.</summary>
            <value>This property gets a style that represents Railway3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Railway4">
            <summary>This property gets a style that represents Railway4.</summary>
            <value>This property gets a style that represents Railway4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.StateBorder1">
            <summary>This property gets a style that represents StateBorder1.</summary>
            <value>This property gets a style that represents StateBorder1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.River1">
            <summary>This property gets a style that represents River1.</summary>
            <value>This property gets a style that represents River1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.River2">
            <summary>This property gets a style that represents River2.</summary>
            <value>This property gets a style that represents River2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Canal1">
            <summary>This property gets a style that represents Canal1.</summary>
            <value>This property gets a style that represents Canal1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.ContestedBorder1">
            <summary>This property gets a style that represents ContestedBorder1.</summary>
            <value>This property gets a style that represents ContestedBorder1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.ContestedBorder2">
            <summary>This property gets a style that represents ContestedBorder2.</summary>
            <value>This property gets a style that represents ContestedBorder2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.DegreeLine1">
            <summary>This property gets a style that represents DegreeLine1.</summary>
            <value>This property gets a style that represents DegreeLine1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Equator1">
            <summary>This property gets a style that represents Equator1.</summary>
            <value>This property gets a style that represents Equator1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.RiverIntermittent1">
            <summary>This property gets a style that represents RiverIntermittent1.</summary>
            <value>This property gets a style that represents RiverIntermittent1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Pipeline1">
            <summary>This property gets a style that represents Pipeline1.</summary>
            <value>This property gets a style that represents Pipeline1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Pipeline2">
            <summary>This property gets a style that represents Pipeline2.</summary>
            <value>This property gets a style that represents Pipeline2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Pipeline3">
            <summary>This property gets a style that represents Pipeline3.</summary>
            <value>This property gets a style that represents Pipeline3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Utility1">
            <summary>This property gets a style that represents Utility1.</summary>
            <value>This property gets a style that represents Utility1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Utility2">
            <summary>This property gets a style that represents Utility2.</summary>
            <value>This property gets a style that represents Utility2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.LineStyles.Utility3">
            <summary>This property gets a style that represents Utility3.</summary>
            <value>This property gets a style that represents Utility3.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload draws a simple line with an optional round cap.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.LineDashStyle,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload draws a dashed line with an optional round cap.</overloads>
            <param name="centerlineColor">This parameter is the center line color.</param>
            <param name="centerlineWidth">This paramter is the the center line width.</param>
            <param name="centerlineDashStyle">This parameter is the dash style for the center line.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload draws a line with an inner and outer area and optional round cap.
            You would use this for roads.
            </overloads>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.LineDashStyle,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.LineDashStyle,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="innerLineDashStyle">This parameter is the inner line dash style.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="outerLineDashStyle">This parameter is the outer line dash style.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload is used to draw things like roads wth a solid centerline.</overloads>
            <param name="centerlineColor">This parameter is the center line color.</param>
            <param name="centerlineWidth">This parameter is the center line width.</param>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.LineDashStyle,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.LineDashStyle,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.LineDashStyle,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload is used to draw things like roads wth a dashed centerline.</overloads>
            <param name="centerlineColor">This parameter is the center line color.</param>
            <param name="centerlineWidth">This parameter is the center line width.</param>
            <param name="centerlineDashStyle">This parameter is the center line dash style.</param>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="innerLineDashStyle">This parameter is the inner line dash style.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="outerLineDashStyle">This parameter is the outer line dash style.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PointPlacement">
            <summary>
            This enumeration determines the label placement when labeling point
            features.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.UpperLeft">
            <summary>The label will be placed in the upper left, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.UpperCenter">
            <summary>The label will be placed in the upper center, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.UpperRight">
            <summary>The label will be placed in the upper right, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.CenterRight">
            <summary>The label will be placed in the center right, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.Center">
            <summary>The label will be placed in the center, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.CenterLeft">
            <summary>The label will be placed in the center left, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.LowerLeft">
            <summary>The label will be placed in the lower left, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.LowerCenter">
            <summary>The label will be placed in the lower center, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointPlacement.LowerRight">
            <summary>The label will be placed in the lower right, in relation to the point.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PointStyle">
            <summary>This class allows you to define how points are drawn on the canvas.</summary>
            <remarks>
            This class allows you to define how points are drawn on the canvas. There are
            three main drawing types: bitmap, character, and symbol. The bitmap allows you to
            represent each point with a bitmap. The character allows you to choose a font and an
            index in the font so you can use that character for the point. This is especially helpful
            with fonts like Wingdings that have many feature-style graphics. The symbol type is a
            collection of simple geometric symbols that we have assembled to represent abstract
            items on the map.<br/>
            	<br/>
            When you select a PointType, you need to be sure to set the various properties
            associated with that type. The property names are prefixed to help you. For example, all
            of the character-related properties are prefixed with "Character" and the symbol properties
            follow a similar pattern.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, you should set the
            various properties manually.
            </overloads>
            <remarks>
            If you use this constructor, you should set the various properties manually.
            Specifically, you will want to set the PointType, which allows you to choose between
            bitmap, character and symbol as an option for displaying your points.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoImage)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor is used for bitmap based points.</overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Bitmap.</remarks>
            <param name="image">
            This parameter is the GeoImage of the image you want to use to display the
            point.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoFont,System.Int32,ThinkGeo.MapSuite.Drawing.GeoSolidBrush)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor is used for character based points.</overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Character.</remarks>
            <param name="characterFont">This parameter is the font from which the character will be selected.</param>
            <param name="characterIndex">This parameter is the index of the character in the chosen font.</param>
            <param name="characterSolidBrush">This parameter is the SolidBrush used to draw the character.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.#ctor(ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoSolidBrush,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor is used for symbol-based points (such as squares and circles) with
            only a fill.
            </overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Symbol.</remarks>
            <param name="symbolType">
            This parameter is the type of symbol you want to use, such as a square or a
            circle.
            </param>
            <param name="symbolSolidBrush">
            This parameter is the SolidBrush you want to use to fill the inside of the
            symbol.
            </param>
            <param name="symbolSize">This parameter is the size you want the symbol to be.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.#ctor(ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoSolidBrush,ThinkGeo.MapSuite.Drawing.GeoPen,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor is used for symbol-based points (such as squares and circles) with
            a fill and outline.
            </overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Symbol.</remarks>
            <param name="symbolType">
            This parameter is the type of symbol you want to use, such as a square or a
            circle.
            </param>
            <param name="symbolSolidBrush">
            This parameter is the SolidBrush you want to use to fill the inside of the
            symbol.
            </param>
            <param name="symbolPen">This parameter is the Pen used to draw the outline of the symbol.</param>
            <param name="symbolSize">This parameter is the size you want the symbol to be.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.PointType">
            <summary>This property gets and sets the type of point you want to draw.</summary>
            <value>This property gets the type of point you want to draw.</value>
            <remarks>
            When using the PointStyle you choose between a bitmap, a font or a predefined symbol
            to represent the point. Each of these options has corresponding properties on the point
            symbol. If you set the type to character, then you need to set the properties that start
            with "Character," such as "CharacterFont." The same is true for the symbol.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.Image">
            <summary>
            This property gets and sets the image used if the PointType property is
            Bitmap.
            </summary>
            <value>This property gets the image used if the PointType property is Bitmap.</value>
            <remarks>
            This property is where you can set the image for the points if the PointType is
            Bitmap. It uses a GeoImage, so you can either reference a file or supply a
            stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.ImageScale">
            <summary>This property gets and sets the scale of the image you want to draw.</summary>
            <value>This property gets the scale of the image you want to draw.</value>
            <remarks>
            This property allows you to scale the image up and down depending on how large or
            small you want it. It can be changed dynamically, so you could change it at every scale
            level to resize the bitmap based on the current scale. A scale of 1 would be the original size,
            while a scale of 2 would double the size. A scale of .5 would reduce the size of the image by half,
            and so on.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.CharacterFont">
            <summary>
            This property gets and sets the font that is used for the character if the
            PointType is Character.
            </summary>
            <value>
            This property gets the font that is used for the character if the PointType is
            Character.
            </value>
            <remarks>
            This property allows you to set the font from which to select a character index if you choose the
            Character PointType.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.CharacterIndex">
            <summary>
            This property gets and sets the index position of the character you want to use
            from the font you selected in the CharacterFont property.
            </summary>
            <value>
            This property gets the index position of the character you want to use from the
            font you selected in the CharacterFont property.
            </value>
            <remarks>
            You need to specify the index position of the character you want to use from the
            font you selected. For example, if you choose 1, then we will use the first character in
            the font you set in the CharacterFont property.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.CharacterSolidBrush">
            <summary>
            This property gets and sets the SolidBrush used to color the font character for
            the point.
            </summary>
            <value>
            This property gets the SolidBrush used to color the font character for the
            point.
            </value>
            <remarks>
            This brush is used to draw the character. It is only used if the PointType is
            Character. If you need a brush other than the SolidBrush, you should look in the
            advanced property of the class.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyle.SymbolType">
            <summary>
            This property gets and sets the type of symbol you want to use if the PointType
            is Symbol.
            </summary>
            <value>
            This property gets the type of symbol you want to use if the PointType is
            Symbol.
            </value>
            <remarks>
            You can choose between a number of predefined symbols. The symbols are simple
            geometric objects that are typically used for abstract representations on a map. If there is
            a specific symbol you need that is not part of our symbol collection, you can submit it to us
            and we will consider adding it.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If symbolPen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If symbolSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If characterSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If characterFont is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a pointSymbolType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a pointType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a imageScale that is less or equal to 0, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyle.DrawSampleCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PointStyles">
            <summary>
            This class provides commonly-used <strong>GeoPointStyles</strong> and some methods to
            create various kinds of GeoPointstyles. A <strong>GeoStyle</strong> is a kind of
            sheet used to render the map.
            </summary>
            <remarks>
            The <strong>GeoStyle</strong> is a very important concept. MapSuite provides three
            kinds of styles: <strong>GeoAreaStyle</strong>,
            <strong>GeoLineStyle</strong>, and <strong>GeoPointStyle</strong>.
            <strong>GeoAreaStyle</strong> is used to render area-type data on the map,
            <strong>GeoLineStyle</strong> is used to render line-type data on the map,
            <strong>GeoPointStyle</strong> is used to render point-type data on the map.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City1">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City2">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City3">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City4">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City5">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City6">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.City7">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.Capital1">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a capital.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.Capital2">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a capital.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PointStyles.Capital3">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a capital.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimplePointStyle(ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a point style.
            </summary>
            <param name="pointStyle">This parameter determines the PointStyle symbol type.</param>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimplePointStyle(ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single)">
            <summary>
            Static API to create a point style.
            </summary>
            <param name="pointStyle">This parameter determines the PointStyle symbol type.</param>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimplePointStyle(ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a point style.
            </summary>
            <param name="pointStyle">This parameter determines the PointStyle symbol type.</param>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleCircleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a circle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleCircleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a circle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleCircleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>
            Static API to create a circle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleSquareStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a square point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleSquareStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>
            Static API to create a square point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleSquareStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a square point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleStarStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a star point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleStarStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>
            Static API to create a star point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleStarStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a star point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleTriangleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a triangle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleTriangleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>
            Static API to create a triangle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateSimpleTriangleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a triangle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateCompoundCircleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a compound circle point style.
            </summary>
            <param name="fillColor1">This parameter determines the outer circle's PointStyle fill color.</param>
            <param name="size1">This parameter determines the outer circle's PointStyle size.</param>
            <param name="outlineColor1">This parameter determines the outer circle's PointStyle outline color.</param>
            <param name="outlineWidth1">This parameter determines the outer circle's PointStyle outline width.</param>
            <param name="fillColor2">This parameter determines the inner circle's PointStyle fill color.</param>
            <param name="size2">This parameter determines the inner circle's PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateCompoundCircleStyle(ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>
            Static API to create a compound circle point style.
            </summary>
            <param name="fillColor1">This parameter determines the outer circle's PointStyle fill color.</param>
            <param name="size1">This parameter determines the outer circle's PointStyle size.</param>
            <param name="outlineColor1">This parameter determines the outer circle's PointStyle outline color.</param>
            <param name="outlineWidth1">This parameter determines the outer circle's PointStyle outline width.</param>
            <param name="fillColor2">This parameter determines the inner circle's PointStyle fill color.</param>
            <param name="outlineColor2">This parameter determines the inner circle's PointStyle outline color.</param>
            <param name="outlineWidth2">This parameter determines the inner circle's PointStyle outline width.</param>
            <param name="size2">This parameter determines the inner circle's PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PointStyles.CreateCompoundPointStyle(ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single,ThinkGeo.MapSuite.Styles.PointSymbolType,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single)">
            <summary>
            Static API to create a compound circle point style.
            </summary>
            <param name="pointStyle1">This parameter determines the outer circle's pointstyle symbol type.</param>
            <param name="fillColor1">This parameter determines the outer circle's PointStyle fill color.</param>
            <param name="size1">This parameter determines the outer circle's PointStyle size.</param>
            <param name="outlineColor1">This parameter determines the outer circle's PointStyle outline color.</param>
            <param name="outlineWidth1">This parameter determines the outer circle's PointStyle outline width.</param>
            <param name="pointStyle2">This parameter determines the inner circle's pointstyle symbol type.</param>
            <param name="fillColor2">This parameter determines the inner circle's PointStyle fill color.</param>
            <param name="size2">This parameter determines the inner circle PointStyle size.</param>
            <param name="outlineColor2">This parameter determines the inner circle's PointStyle outline color.</param>
            <param name="outlineWidth2">This parameter determines the inner circle's PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PointSymbolType">
            <summary>This enumeration defines the different types of PointSymbols that can be drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Circle">
            <summary>
            Draws a circle.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Square">
            <summary>
            Draws a square.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Triangle">
            <summary>
            Draws a triangle.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Cross">
            <summary>
            Draws an equal-legged cross.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Diamond">
            <summary>Draws a diamond.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Diamond2">
            <summary>Draws a variation of a diamond.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Star">
            <summary>Draws a star.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointSymbolType.Star2">
            <summary>Draws a variation of a star.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PointType">
            <summary>This enumeration defines how a PointSymbol will be drawn.</summary>
            <remarks>
            Depending on which of the members you choose, there are different properties that
            need to be set on the PointStyle.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointType.Symbol">
            <summary>The point will be drawn using a symbol.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointType.Bitmap">
            <summary>The point will be drawn using a bitmap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PointType.Character">
            <summary>The point will be drawn using a font character.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PolygonLabelingLocationMode">
            <summary>
            Labeling Location Mode for polygon
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PolygonLabelingLocationMode.Default">
            <summary>
            Use the centroid as polygon's labeling location
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PolygonLabelingLocationMode.Centroid">
            <summary>
            Use the centroid as polygon's labeling location
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.PolygonLabelingLocationMode.BoundingBoxCenter">
            <summary>
            Use the boundingbox center as polygon's labeling location
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.PositionStyle">
            <summary>
            This abstract class encapsulates the labeling position logic. It is inherited
            by other styles, such as the TextSytle.
            </summary>
            <remarks>
            This abstract class is meant to be inherited by other classes and specialized to
            meet the needs of various labelers.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.LabelPositions">
            <summary>
            Gets a value represents a keyValuepair which is a feature id and label position of the feature
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.PolygonLabelingLocationMode">
            <summary>
            This property gets and sets the mode that determines how to locate polygon's labeling
            </summary>
            <value>
            This property gets the mode that determines how to locate polygon's labeling
            </value>
            <remarks>
            There are two ways to handle polygon's labeling location. The first is to use polygon's
            centroid as the labeling location, the second way is to use polygon's boungdingbox
            center as the labeling location.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset used for drawing each feature.</summary>
            <value>This property gets the X pixel offset used for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset used for drawing each feature.</summary>
            <value>This property gets the Y pixel offset used for drawing each feature.</value>
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.GridSize">
            <summary>
            This property gets and sets the grid size used for deterministic
            labeling.
            </summary>
            <value>This property gets the grid sized used for deterministic labeling.</value>
            <remarks>
            The grid size determines how many labels will be considered as candidates for drawing. The
            smaller the grid size, the higher the density of candidates. Making the grid size too small
            may have a performance impact.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.CustomTextStyles">
            <summary>
            This property returns a collection of area styles, allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection you can stack multiple area styles on top of each other.
            When we draw the feature we will draw them in order in the collection. You can use
            these stacks to create drop shadow effects along with multiple colored outlines
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.RotationAngle">
            <summary>
            This property gets and sets the rotation angle of the item being
            positioned.
            </summary>
            <value>This property gets the rotation angle of the item being positioned.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.FittingLineInScreen">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as it
            can on the visible part of a line on the screen.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as it can on
            the visible part of a line on the screen.
            </value>
            <remarks>
            A label will normally be displayed in the center of a line. If only a small piece
            of the line is visible on the screen, we cannot see it's label by default. If we set this
            property to ture though, the label will be displayed in the center of that piece in screen.
             </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.FittingPolygonInScreen">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as it
            can on the visible part of a polygon on the screen.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as it can on
            the visible part of a polygon on the screen.
            </value>
            <remarks>
            A label will normally be displayed in the center of a polygon. If only a small piece
            of the polygon is visible on the screen, we cannot see it's label by default. If we set this
            property to ture though, the label will be displayed in the center of that piece in screen.
             </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.TextFormat">
            <summary>This property gets and sets the format that will be applied to the text.</summary>
            <value>This property gets the format that will be applied to the text.</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.NumericFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to double type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to double type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.DateFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to DateTime type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to DateTime type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.TextSolidBrush">
            <summary>
            This property gets and sets the SolidBrush that will be used to draw the
            text.
            </summary>
            <value>This property gets the SolidBrush that will be used to draw the text.</value>
            <remarks>
            You can use this property to draw a solid color; however, if you need to use other
            brushes, you can access them through the Advanced property of this class.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.Font">
            <summary>This property gets and sets the font that will be used to draw the text.</summary>
            <value>This property gets the font that will be used to draw the text.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.HaloPen">
            <summary>
            This property gets and sets the halo pen you may use to draw a halo around the
            text.
            </summary>
            <value>
            This property gets the halo pen you may use to draw a halo around the
            text.
            </value>
            <remarks>
            The halo pen allows you to draw a halo effect around the text, making it stand out
            more on a busy background.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.TextColumnName">
            <summary>
            This property gets and sets the column name in the data that you want to get the text from.
            </summary>
            <value>
            This property gets the column name in the data that you want to get the text from.
            </value>
            <remarks>
            This property is used when retrieving text from a feature. You will want to
            specify the name of the column that contains the text you want to draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.Mask">
            <summary>
            This property gets and sets the AreaStyle used to draw a mask behind the
            text.
            </summary>
            <value>This property gets the AreaStyle used to draw a mask behind the text.</value>
            <remarks>
            A mask is a plate behind the text that is rectangular and slightly larger than
            the width and height of the text. It allows the label to stand out well on a busy
            background. You can also try the HaloPen property instead of the mask, if the mask effect is
            too pronounced.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.MaskMargin">
            <summary>This property gets and sets the margin around the text that will be used for the mask.</summary>
            <value>This property gets the margin around the text that will be used for the mask.</value>
            <remarks>This determines how much larger the mask is than the text, in pixels.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.Advanced">
            <summary>This property gets the advanced properties of the class.</summary>
            <value>This property gets the advanced properties of the class.</value>
            <remarks>
            The advanced properties have been consolidated in the Advanced property. This way,
            the standard options are more easily visible and the advanced options are hidden
            away.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.DuplicateRule">
            <summary>
            This property gets and sets the rule that determines how duplicate labels are
            handled.
            </summary>
            <value>
            This property gets the rule that determines how duplicate labels are
            handled.
            </value>
            <remarks>
            There are three ways to handle duplicate label names. The first is to suppress
            all duplicates, which means if there are two street segments with the same name then
            only one will be drawn. The second way is to suppress duplicate labels only if they are
            in one quarter of the screen. In this way, the screen will be divided into four
            quadrants, and if the two duplicate labels are in different quadrants, then they will both
            draw. The last way is to draw all duplicates.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.OverlappingRule">
            <summary>
            This property gets and sets the rule that determines how overlapping labels are
            handled.
            </summary>
            <value>This property gets the rule that determines overlapping labels are handled.</value>
            <remarks>
            This defines the rules for label overlapping. Currently, either we allow overlapping or we
            do not. In the future, we may extend this to allow some percentage of partial
            overlapping.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.AllowSpline">
            <summary>
            This property gets and sets whether line labels are allowed to spline around curved
            lines.
            </summary>
            <value>
            This property gets whether line labels are allowed to spline around curved
            lines.
            </value>
            <remarks>
            This property will allow the labeler to spline the label around curved lines.
            This is useful for curved streets that need to be labeled. This can have a considerable
            performance impact, so we suggest you experiment with it to ensure it can meet your
            needs.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.AllowLineCarriage">
            <summary>
            This property gets and sets whether the labeler will allow carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will allow carriage returns to be
            inserted.
            </value>
            <remarks>
            This property enables the labeler to split long labels into multiple lines if need be.
            For instance, if you have a lake whose name is "Southern Homestead Lake," then the labeler
            may try and break the name onto multiple lines in order to better label the feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.SuppressPartialLabels">
            <summary>
            This property gets and sets whether a partial label in the current extent will be drawn or not.
            </summary>
            <remarks>This property provides a solution to the "cut off" label issue in Map Suite Web Edition and Desktop Edition, which occurs when multiple
            tiles exist. When you set this property to true, any labels outside of the current extent will not be drawn.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.ForceLineCarriage">
            <remarks>
            This property forces the labeler to split long labels into multiple lines. For instance,
            if you have a lake whose name is "Southern Homestead Lake," then the labeler will break
            the name onto multiple lines in order to better label the feature.
            </remarks>
            <summary>
            This property gets and sets whether the labeler will force carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will force carriage returns to be
            inserted.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.FittingPolygon">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.LabelAllPolygonParts">
            <summary>
            This property gets and sets whether the labeler will label every part of a multi-part
            polygon.
            </summary>
            <value>
            This property gets whether the labeler will label every part of a multi-part
            polygon.
            </value>
            <remarks>
            In some cases, you may want to label all of the parts of a multi-part polygon, while in
            other cases you may not. For example, you may have a series of lakes where you do want to
            label each polygon. In another case, you may have a country with many small islands and
            in this case you only want to label the largest polygon.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.LabelAllLineParts">
            <summary>
            This property gets and sets whether the labeler will label every part of a multi-part
            line.
            </summary>
            <value>
            This property gets whether the labeler will label every part of a multi-part
            line.
            </value>
            <remarks>
            In some cases, you may want to label all of the parts of a multi-part line, while in
            other cases you may not.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.ForceHorizontalLabelForLine">
            <summary>This property gets and sets whether we should force horizontal labeling for lines.</summary>
            <value>This property gets whether we should force horizontal labeling for lines.</value>
            <remarks>
            Normally, lines are labeled in the direction of the line. There may be some cases,
            however, when you want to have the line labeled horizontally regardless of the line's direction.
            In such a case, you can set this property to force the lines to be labeled horizontally.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.FittingPolygonFactor">
            <summary>
            This property gets and sets the factor to which it will keep the label inside of
            the polygon.
            </summary>
            <value>
            This property gets the factor to which it will keep the label inside of the
            polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.TextLineSegmentRatio">
            <summary>
            This property gets and sets the ratio required for the label length to match the
            line length.
            </summary>
            <value>
            This property gets the ratio required for the label length to match the line
            length.
            </value>
            <remarks>
            This allows you to suppress labels where the label length would greatly exceed
            the line length. For example, if you set the ratio to 1, then the label will be
            suppressed if it is longer than the line. If the ratio is lower, then the label would
            need to be shorter than the line. If higher, then the label is allowed to run past the
            length of the line. This allows you to control the look of things like road labeling.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.BestPlacement">
            <summary>
            This property gets and sets whether the labeler will attempt to change the label
            position to avoid overlapping for point-based features.
            </summary>
            <value>
            This property gets whether the labeler will attempt to change the label position to
            avoid overlapping for point-based features.
            </value>
            <remarks>
            The positioning of point labels is mainly determined by the PointPlacement
            property. This allows you place the text to the right, top, bottom, etc. of the point. In
            some cases, placing the text in a certain place will cause many labels to be suppressed
            when the points are dense. This property allows you to override the PointPlacement
            property and allow the labeler to try other locations, if the default location would
            cause the label to be suppressed.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.PointPlacement">
            <summary>
            This property gets and sets the location of the label for point features relative
            to the point.
            </summary>
            <value>
            This property gets the location of the label for point features relative to the
            point.
            </value>
            <remarks>
            This property allows you to choose where the labels are created relative to the
            point. For example, you can set the property to RightCenter, which would ensure that all
            labels are placed to the right of and vertically centered with the point. Different kinds of point layers
            can be positioned differently. If the point layer is dense and position is not a main
            concern, then you can try the BestPlacement property. That property overrides this
            property and tries to fit the label in the best location so that the minimum number of
            labels are suppressed due to overlapping issues.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.SplineType">
            <summary>
            Gets or sets the SplineType for labeling.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.PositionStyle.DrawingLevel">
            <summary>
            Gets or sets the DrawingLavel for this style.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.GetRequiredColumnNamesCore">
            <remarks>
             This abstract method is called from the concrete public method
             GetRequiredFieldNames. In this method, we return the column names that are required for
             the style to draw the feature properly. For example, if you have a style that colors
             areas blue when a certain column value is over 100, then you need to be sure you include
             that column name. This will ensure that the column data is returned to you in the
             feature when it is ready to draw.<br/>
             	<br/>
             In many of the styles, we add properties to allow the user to specify which field they
             need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
             collection.
             </remarks>
             <summary>
             This method returns the column data for each feature that is required for the
             style to properly draw.
             </summary>
             <returns>This method returns a collection of the column names that it needs.</returns>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.FilterFeatures(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas)">
            <summary>
            This method filters the features based on the grid size to facilitate
            deterministic labeling.
            </summary>
            <returns>This method returns the features that will be considered for labeling.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                FilterFeaturesCore. In this method, we filter the features based on the grid size to
                facilitate deterministic labeling.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="features">This parameter represents the features that will be filtered.</param>
            <param name="canvas">This parameter is the canvas that will be used for calculating font sizes.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.FilterFeaturesCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas)">
            <summary>
            This method filters the features based on the grid size to facilitate
            deterministic labeling.
            </summary>
            <returns>This method returns the features that will be considered for labeling.</returns>
            <remarks>
            This overridden method is called from the concrete public method FilterFeatures.
            In this method, we filter the features based on the grid size to facilitate
            deterministic labeling.
            </remarks>
            <param name="features">This parameter represents the features that will be filtered.</param>
            <param name="canvas">This parameter is the canvas that will be used for calculating font sizes.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.GetLabelingCandidates(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoCanvas)">
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                GetLabelingCanidatesCore. This method determines if the feature passed in is a good
                candidate to be labeled based on the labeling properties set.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <returns>A collection of labeling candidates.</returns>
            <summary>
            This method determines whether the specified feature is a good candidate to be labeled,
            based on the labeling properties set.
            </summary>
            <param name="feature">
            This parameter is the feature that will be considered as a labeling
            candidate.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to draw the feature. This method will not
            draw on this canvas, but rather will use it to determine font size, etc.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.GetLabelingCandidateCore(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoCanvas)">
            <remarks>
            This overridden method is called from the concrete public method
            GetLabelingCanidate. In this method, we take the feature you passed in and determine if
            it is a candidate for labeling. If it is, then we will add it to the return collection.
            The algorithm to determine whether the label will draw is complex and determined by a number
            of properties and factors.
            </remarks>
            <summary>
            This method determines whether the specified feature is a good candidate to be labeled,
            based on the labeling properties set.
            </summary>
            <returns>A collection of labeling candidates.</returns>
            <param name="feature">
            This parameter is the feature that will be considered as a labeling
            candidate.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to draw the feature. This method will not
            draw on this canvas, but rather will use it to determine font size, etc.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.CheckDuplicate(ThinkGeo.MapSuite.Styles.LabelingCandidate,ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>
            This method will determine whether the label will be suppressed because it is a
            duplicate.
            </summary>
            <returns>This method returns whether the label will be suppressed as a duplicate.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                CheckDuplicateCore. This method will determine if the label will be suppressed
                because it is a duplicate. It also takes into consideration the duplicate rules
                for the class. So, for example, if we set to allow duplicates, then the method will
                always return false. If the class is set to not allow duplicates and this label is
                a duplicate, then it will return true and be suppressed.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="labelingCandidate">
            This parameter is the labeling candidate that will be checked to determine if it is a
            duplicate.
            </param>
            <param name="canvas">This parameter is the canvas used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.CheckDuplicateCore(ThinkGeo.MapSuite.Styles.LabelingCandidate,ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <remarks>
            This overridden method is called from the concrete public method CheckDuplicate.
            This method will determine if the label will be suppressed
            because it is a duplicate. It also takes into consideration the duplicate rules
            for the class. So, for example, if we set to allow duplicates, then the method will
            always return false. If the class is set to not allow duplicates and this label is
            a duplicate, then it will return true and be suppressed.
            </remarks>
            <returns>This method returns whether the label will be suppressed as a duplicate.</returns>
            <summary>
            This method will determine if the label will be suppressed because it is a
            duplicate.
            </summary>
            <param name="labelingCandidate">
            This parameter is the labeling candidate that will be checked to determine if it is a
            duplicate.
            </param>
            <param name="canvas">This parameter is the canvas that will be used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.CheckOverlapping(ThinkGeo.MapSuite.Styles.LabelingCandidate,ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>
            This method will determine if the label will be suppressed because of
            overlapping.
            </summary>
            <returns>This method returns whether the label will be suppressed because of overlapping.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                CheckOverlappingCore. This method will determine if the label will be suppressed
                because it is overlapping another label. It also takes into consideration the
                overlapping rules for the class. So, for example, if we set to allow overlap, then the
                method will always return false. If the class is set to not allow overlap and
                this label is overlapping, then it will return true and be suppressed.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="labelingCandidate">
            This parameter is the labeling candidate that will be checked to determine if it is
            overlapping.
            </param>
            <param name="canvas">This parameter is the canvas that will be used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.CheckOverlappingCore(ThinkGeo.MapSuite.Styles.LabelingCandidate,ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>
            This method will determine whether the label will be suppressed because of
            overlapping.
            </summary>
            <returns>This method returns whether the label will be suppressed because of overlapping.</returns>
            <remarks>
            This overridden method is called from the concrete public method
            CheckOverlapping. This method will determine if the label will be suppressed
            because it is overlapping another label. It also takes into consideration the
            overlapping rules for the class. So, for example, if we set to allow overlap, then the
            method will always return false. If the class is set to not allow overlap and
            this label is overlapping, then it will return true and be suppressed.
            </remarks>
            <param name="labelingCandidate">This parameter is the labeling candidate that will be checked to determine if it is overlapping.</param>
            <param name="canvas">This parameter is the canvas that will be used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.PositionStyle.ConvertToScreenShape(ThinkGeo.MapSuite.Shapes.Feature,ThinkGeo.MapSuite.Drawing.GeoCanvas)">
            <remarks>
            This overridden method can be called by this class and its sub concrete classes.
            In this method, we take the canvas and the feature in world coordinates and convert it to
            screen coordinates.
            </remarks>
            <summary>
            This method converts a feature in world coordinates to screen coordinates.
            </summary>
            <returns>A screen coordinate shape.</returns>
            <param name="feature">
            This parameter is the feature to be converted from world coordinates.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to convert the world coordinate feature to a screen coorindate feature.
            </param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle">
            <summary>This class is used to draw area features.</summary>
            <remarks>
            You should use this class to draw area features. You can specify a base color and the number of
            colors you want based on that color to draw the interior, and you can specify an outline pen
            with which to draw the border. You can optionally choose to
            use only the outline pen or the fill brush to generate different effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Drawing.GeoPen,ThinkGeo.MapSuite.Drawing.GeoColor,System.Int32,ThinkGeo.MapSuite.Drawing.PenBrushDrawingOrder)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
            <param name="penBrushDrawingOrder">This parameter describes the PenBrushDrawingOrder that will be used when drawing the area type feature.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.NumberOfColors">
            <summary>This gets or sets the number of colors in the style.</summary>
            <value>This gets or sets the number of colors in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.Cache">
            <summary>This gets the cached style in the class.</summary>
            <value>This gets the cached style in the class.</value>
            <remarks>
            This gets the cached style in the class. The key of the style in the cache is
            feature.Id &amp; feature.GetHashCode().
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.BaseColor">
            <summary>This gets or sets the base color of the style.</summary>
            <value>This gets or sets the base color of the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.ClearCache">
            <summary>This method clears the cached style in the cache.</summary>
            <returns>None.</returns>
            <remarks>This method clears the cached style in the cache.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.QualityFamilyAreaStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},ThinkGeo.MapSuite.Drawing.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Styles.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.SimpleCandidate">
            <summary>This class stores simple label information used in the PositionStyle.</summary>
            <remarks>
            This class is used in the PositionStyle for storing simple label infromation. It
            has a limited scope.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.SimpleCandidate.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to
            manually set the properties necessary for this class.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to manually set the properties
            necessary for this class.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.SimpleCandidate.#ctor(System.String,ThinkGeo.MapSuite.Shapes.PolygonShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the original text and the simple polygon
            in screen coordinates.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">This parameter is the text for the label.</param>
            <param name="simplePolygonInScreenCoordinate">
            This parameter is a polygon in screen coordinates that represents the area of the
            label.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.SimpleCandidate.OriginalText">
            <summary>This property gets and sets the text for the label.</summary>
            <value>This property gets the text for the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.SimpleCandidate.SimplePolygonInScreenCoordinate">
            <summary>
            This property gets and sets the polygon in screen coordinates that represents the
            area of the label.
            </summary>
            <value>
            This property gets the polygon in screen coordinates that represents the area of
            the label.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.SplineType">
            <summary>This enumeration represents the spline type for labeling.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.SplineType.Default">
            <summary>Default SplineType provided in PositionStyle.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.SplineType.None">
            <summary>This SplineType will label the text in a line type without any spling effects, this kinds of type will gain
            better performance compare to StandardSplining.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.SplineType.StandardSplining">
            <summary>This SplineType will label the text in a standard Spline way, it will have much better outlook in some situations
            while it will lose slightly some performance.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Styles.SplineType.ForceSplining">
            <summary>
            This SplineType will force the labe text using Spline way, otherwise the label won't display.Usually it is just used for Asian languages
            like Chinese or Japanese.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.TextStyle">
            <summary>This class is used to label features on the map.</summary>
            <remarks>
            The text style is used for labeling things on the map. There are a great number
            of properties that give you a lot of control over how things are labeled. At the core,
            you need to set the font you want to use to label, the TextSolidBrush to define the
            color and look of the text, and the TextColumnName you want to use for the text to
            draw. Each of the additional properties can be reviewed in the help or samples.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor for the class. If you use this constructor, you
            should set the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you should set the required properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyle.#ctor(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoSolidBrush)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in the minimum required fields for labeling.
            You may want to explore the other properties to control how your labels look.
            </overloads>
            <remarks>
            This constructor allows you to pass in the minimum required fields for labeling.
            You may want to explore the other properties to control how your labels look.
            </remarks>
            <param name="textColumnName">This parameter is the name of the column that contains the text you want to draw.</param>
            <param name="textFont">This parameter is the font used to draw the text.</param>
            <param name="textSolidBrush">This parameter is the TextSolidBrush used to draw the text.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.FittingLineInScreen">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as it
            can on the visible part of a line on the screen.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as it can on
            the visible part of a line on the screen.
            </value>
            <remarks>
            A label will normally be displayed in the center of a line. If only a small piece
            of the line is visible on the screen, we cannot see it's label by default. If we set this
            property to ture though, the label will be displayed in the center of that piece in screen.
             </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.FittingPolygonInScreen">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as it
            can on the visible part of a polygon on the screen.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as it can on
            the visible part of a polygon on the screen.
            </value>
            <remarks>
            A label will normally be displayed in the center of a polygon. If only a small piece
            of the polygon is visible on the screen, we cannot see it's label by default. If we set this
            property to ture though, the label will be displayed in the center of that piece in screen.
             </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.CustomTextStyles">
            <summary>
            This property returns a collection of area styles allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection, you can stack multiple area styles on top of each other.
            When we draw the features, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.RotationAngle">
            <summary>
            This property gets and sets the rotation angle of the item being
            positioned.
            </summary>
            <value>This property gets the rotation angle of the item being positioned.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.TextFormat">
            <summary>This property gets and sets the format that will be applied to the text.</summary>
            <value>This property gets the format that will be applied to the text.</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.NumericFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to double type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to double type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.DateFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to DateTime type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to DateTime type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.TextSolidBrush">
            <summary>
            This property gets and sets the SolidBrush that will be used to draw the
            text.
            </summary>
            <value>This property gets the SolidBrush that will be used to draw the text.</value>
            <remarks>
            You can use this property to draw a solid color; however, if you need to use other
            brushes, you can access them through the Advanced property of this class.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.Font">
            <summary>This property gets and sets the font that will be used to draw the text.</summary>
            <value>This property gets the font that will be used to draw the text.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.HaloPen">
            <summary>
            This property gets and sets the halo pen you may use to draw a halo around the
            text.
            </summary>
            <value>
            This property gets the halo pen you may use to draw a halo around the
            text.
            </value>
            <remarks>
            The halo pen allows you to draw a halo effect around the text, making it stand out
            more on a busy background.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.TextColumnName">
            <summary>
            This property gets and sets the column name in the data that you want to get the text from.
            </summary>
            <value>
            This property gets the column name in the data that you want to get the text from.
            </value>
            <remarks>
            This property is used when retrieving text from a feature. You will want to
            specify the name of the column that contains the text you want to draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.Mask">
            <summary>
            This property gets and sets the AreaStyle used to draw a mask behind the
            text.
            </summary>
            <value>This property gets the AreaStyle used to draw a mask behind the text.</value>
            <remarks>
            A mask is a plate behind the text that is rectangular and slightly larger than
            the width and height of the text. It allows the label to stand out well on a busy
            background. You can also try the HaloPen property instead of the mask, if the mask effect is
            too pronounced.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.MaskMargin">
            <summary>This property gets and sets the margin around the text that will be used for the mask.</summary>
            <value>This property gets the margin around the text that will be used for the mask.</value>
            <remarks>This determines how much larger the mask is than the text, in pixels.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.Advanced">
            <summary>This property gets the advanced properties of the class.</summary>
            <value>This property gets the advanced properties of the class.</value>
            <remarks>
            The advanced properties have been consolidated in the Advanced property. This way,
            the standard options are more easily visible and the advanced options are hidden
            away.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.ForceHorizontalLabelForLine">
            <summary>This property gets and sets whether we should force horizontal labeling for lines.</summary>
            <value>This property gets whether we should force horizontal labeling for lines.</value>
            <remarks>
            Normally, lines are labeled in the direction of the line. There may be some cases,
            however, when you want to have the line labeled horizontally regardless of the line's direction.
            In such a case, you can set this property to force the lines to be labeled horizontally.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.SplineType">
            <summary>
            Gets or sets the SplineType for labeling.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.DrawingLevel">
            <summary>
            Gets or sets the DrawingLavel for this style.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.TextStyle.LabelPositions">
            <summary>
            Gets a value represents a keyValuepair which is a feature id and label position of the feature
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyle.DrawSampleCore(ThinkGeo.MapSuite.Drawing.GeoCanvas,ThinkGeo.MapSuite.Shapes.DrawingRectangleF)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            	<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.TextStyles">
            <summary>
            The class provides commonly-used <strong>TextStyles</strong> and some methods to
            create various kinds of <strong>TextStyles</strong>. A <strong>TextStyle</strong> is a kind of
            sheet used to render a font on the map.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City1(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City2(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City3(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City4(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City5(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City6(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.City7(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Capital1(System.String)">
            <summary>
            Get the commonly-used capital <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Capital2(System.String)">
            <summary>
            Get the commonly-used capital <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Capital3(System.String)">
            <summary>
            Get the commonly-used capital <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.NoData1(System.String)">
            <summary>
            Get the commonly-used nodata <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Water1(System.String)">
            <summary>
            Get the commonly-used water <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Water2(System.String)">
            <summary>
            Get the commonly-used water <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Military1(System.String)">
            <summary>
            Get the commonly-used military <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Wildlife1(System.String)">
            <summary>
            Get the commonly-used wildlife <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.State1(System.String)">
            <summary>
            Get the commonly-used state <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.State2(System.String)">
            <summary>
            Get the commonly-used state <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Swamp1(System.String)">
            <summary>
            Get the commonly-used swamp <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Swamp2(System.String)">
            <summary>
            Get the commonly-used swamp <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Urban1(System.String)">
            <summary>
            Get the commonly-used urban <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Urban2(System.String)">
            <summary>
            Get the commonly-used urban <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Country1(System.String)">
            <summary>
            Get the commonly-used country <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Country2(System.String)">
            <summary>
            Get the commonly-used country <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.County1(System.String)">
            <summary>
            Get the commonly-used county <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.County2(System.String)">
            <summary>
            Get the commonly-used county <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Antarctical(System.String)">
            <summary>
            Get the commonly-used antarctical <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Evergreen1(System.String)">
            <summary>
            Get the commonly-used evergreen <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Evergreen2(System.String)">
            <summary>
            Get the commonly-used evergreen <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Grass1(System.String)">
            <summary>
            Get the commonly-used grass <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.WaterIntermittent1(System.String)">
            <summary>
            Get the commonly-used waterIntermittent <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Sand1(System.String)">
            <summary>
            Get the commonly-used sand <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.SeaIce1(System.String)">
            <summary>
            Get the commonly-used seaice <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.SnowIce1(System.String)">
            <summary>
            Get the commonly-used snowice <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Tundra1(System.String)">
            <summary>
            Get the commonly-used tundra <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Crop1(System.String)">
            <summary>
            Get the commonly-used crop <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Forest1(System.String)">
            <summary>
            Get the commonly-used forest <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Park1(System.String)">
            <summary>
            Get the commonly-used park <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.LocalRoad1(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.LocalRoad2(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.LocalRoad3(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.LocalRoad4(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.SecondaryRoad1(System.String)">
            <summary>
            Get the commonly-used secondary road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.SecondaryRoad2(System.String)">
            <summary>
            Get the commonly-used secondary road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorStreet1(System.String)">
            <summary>
            Get the commonly-used major street <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorStreet2(System.String)">
            <summary>
            Get the commonly-used major street <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorStreet3(System.String)">
            <summary>
            Get the commonly-used major street <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorRoad1(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorRoad2(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorRoad3(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.MajorRoad4(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Highway1(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Highway2(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Highway3(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Highway4(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Highway5(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Interstate1(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Interstate2(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Interstate3(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Interstate4(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.InternationalBorder1(System.String)">
            <summary>
            Get the commonly-used internationalBorder <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.InternationalBorder2(System.String)">
            <summary>
            Get the commonly-used internationalBorder <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Railway1(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Railway2(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Railway3(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Railway4(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.StateBorder1(System.String)">
            <summary>
            Get the commonly-used state border <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.River1(System.String)">
            <summary>
            Get the commonly-used state river <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.River2(System.String)">
            <summary>
            Get the commonly-used state river <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Canal1(System.String)">
            <summary>
            Get the commonly-used state canal <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.ContestedBorder1(System.String)">
            <summary>
            Get the commonly-used state contested border <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.ContestedBorder2(System.String)">
            <summary>
            Get the commonly-used state contested border <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.DegreeLine1(System.String)">
            <summary>
            Get the commonly-used state degree line <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Equator1(System.String)">
            <summary>
            Get the commonly-used state equator <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.RiverIntermittent1(System.String)">
            <summary>
            Get the commonly-used river intermittent <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Pipeline1(System.String)">
            <summary>
            Get the commonly-used pipeline <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Pipeline2(System.String)">
            <summary>
            Get the commonly-used pipeline <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Pipeline3(System.String)">
            <summary>
            Get the commonly-used pipeline <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Utility1(System.String)">
            <summary>
            Get the commonly-used utility <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Utility2(System.String)">
            <summary>
            Get the commonly-used utility <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.Utility3(System.String)">
            <summary>
            Get the commonly-used utility <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="haloPenColor">The <strong>GeoColor</strong> used to set the halopen color.</param>
             <param name="haloPenWidth">The float value to set the halopen width value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="haloPenColor">The <strong>GeoColor</strong> used to set the halopen color.</param>
             <param name="haloPenWidth">The float value to set the halopen width value.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskFillColor">The <strong>GeoColor</strong> used to set the mask fill color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskFillColor">The <strong>GeoColor</strong> used to set the mask fill color.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateMaskTextStyle(System.String,ThinkGeo.MapSuite.Drawing.GeoFont,ThinkGeo.MapSuite.Drawing.GeoSolidBrush,ThinkGeo.MapSuite.Styles.AreaStyle,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="textFont">The <strong>GeoFont</strong> used to set the font of the text.</param>
             <param name="textBrush">The <strong>GeoSolidBrush</strong> used to set the brush of the text.</param>
             <param name="areaStyle">The areaStyle used as mask of of the TextStyle.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskPenColor">The <strong>GeoColor</strong> used to set the mask pen color.</param>
             <param name="maskPenSize">The float value used to set the mask pen size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Drawing.DrawingFontStyles,ThinkGeo.MapSuite.Drawing.GeoColor,ThinkGeo.MapSuite.Drawing.GeoColor,System.Single,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskPenColor">The <strong>GeoColor</strong> used to set the mask pen color.</param>
             <param name="maskPenSize">The float value used to set the mask pen size.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Styles.WorldLabelingCandidate">
            <summary>This class represents a candidate with world center point information for labeling.</summary>
            <remarks>
            This class is used in the labeling system. We keep track of
            every potential label in this class as it goes through the labeling rules.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Styles.WorldLabelingCandidate.CenterPointInWorldCoordinates">
            <summary>
            This property gets or sets the Center Point position in world Coordinate system.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.WorldLabelingCandidate.#ctor">
            <summary>This is a default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you should set the applicable properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.WorldLabelingCandidate.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the text of the label.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Styles.WorldLabelingCandidate.#ctor(System.String,ThinkGeo.MapSuite.Shapes.PointShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the text of the label as well as the world center
            point.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
            <param name="centerPointInWorldCoordinates">
            This parameter is the center of the polygon (in world coordinates) representing the area to
            be labeled.
            </param>
        </member>
        <member name="T:ThinkGeo.MapSuite.ExceptionDescription">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.AddTransactionError">
            <summary>
              Looks up a localized string similar to The add transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.BothIconFilePathAndIconImageAreInvalid">
            <summary>
              Looks up a localized string similar to You can provide a path and file name to an icon or an image but not both..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CadDllNotExists">
            <summary>
              Looks up a localized string similar to The CAD unmanaged assemblies cannot be found..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CellHeightLessThanZero">
            <summary>
              Looks up a localized string similar to The cellHeight needs to be greater than zero..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CellWidthLessThanZero">
            <summary>
              Looks up a localized string similar to The cellWidth needs to be greater than zero..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CheckLayerIsNotOpenedNorDrawing">
            <summary>
              Looks up a localized string similar to You can not CloneDeep because the object is open or drawing, please close or end drawing first..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CheckLayerIsOpened">
            <summary>
              Looks up a localized string similar to The Layer must be opened before you can perform this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CheckMapEngineCurrentExtentIsNotValid">
            <summary>
              Looks up a localized string similar to The current extent provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ClassBreakNumberShouldBeGreaterThanOne">
            <summary>
              Looks up a localized string similar to The ClassBreak Number should be greater than one..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ClassBreaksIsValid">
            <summary>
              Looks up a localized string similar to The class breaks you have provided are invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ColorDoesNotExist">
            <summary>
              Looks up a localized string similar to The color you have provided does not exist..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ColumnNumberExceedTotalRowCount">
            <summary>
              Looks up a localized string similar to The parameter column exceeds the total column count..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CommonImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ConnectionStringCannotBeNull">
            <summary>
              Looks up a localized string similar to The connection string can not be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ConvertFormatException">
            <summary>
              Looks up a localized string similar to The specified value can not be converted this type..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CreateShapeFileFailed">
            <summary>
              Looks up a localized string similar to The creation of the shape file has failed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CurrentExtentNotAssigned">
            <summary>
              Looks up a localized string similar to The CurrentExtent property must be set before calling this method. If you want to use a custom extent, please use the static method.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.CustomImageSizeIsNull">
            <summary>
              Looks up a localized string similar to You already choose resize the image by custom size, please set the custom width and height..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DateTimeBeyondFileSupportLife">
            <summary>
              Looks up a localized string similar to The supported datetime should be between 1900 and 2015.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DbfColumnsIsEmpty">
            <summary>
              Looks up a localized string similar to The DbfColumns collection is empty, you should add at least one DbfColumn when you create a new shape file..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DecimalDegreeLatitudeOutOfRange">
            <summary>
              Looks up a localized string similar to The decimal degree latitude value you provided was out of range..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DecimalDegreeLongitudeOutOfRange">
            <summary>
              Looks up a localized string similar to The decimal degree longitude value you provided was out of range..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DecimalDegreeSecondsStringNull">
            <summary>
              Looks up a localized string similar to The degreesMinutesSeconds string may not be null or empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DecimalLengthInValidForStringColumnType">
            <summary>
              Looks up a localized string similar to DecimalLength is Invalid(it should be 0) for StringColumnType, it only make sense for DoubleColumnType..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DefaultAndCustomStyleDuplicate">
            <summary>
              Looks up a localized string similar to You are trying to use both a default style and the custom styles collection.  You may only use one or the other..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DefaultAndCustomStyleDuplicateForRestrictedLayer">
            <summary>
              Looks up a localized string similar to You are trying to use both a default style and the custom styles collection. If you want to add custom styles, please set RestrictionStyle as RestrictionStyle.UseCustomStyles..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DegreesMinutesSecondsInputError">
            <summary>
              Looks up a localized string similar to The DegreesMinutesSeconds value is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DeleteTransactionError">
            <summary>
              Looks up a localized string similar to The delete transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DoubleIsValid">
            <summary>
              Looks up a localized string similar to The value of double cannot be NaN or Infinity..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.DoubleOutOfRange">
            <summary>
              Looks up a localized string similar to The input double value is out of range..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.EditingNotSupported">
            <summary>
              Looks up a localized string similar to You have set IsEditable to true but have not overridden the CommitTransactionCore method.  Please override this the CommitTransactionCore method to prevent this exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.EllipseIsNotValid">
            <summary>
              Looks up a localized string similar to The ellipse is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.EntryPointInvalid">
            <summary>
              Looks up a localized string similar to The calling assembly is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.EnumerationOutOfRange">
            <summary>
              Looks up a localized string similar to The value for the enumeration is not one of the valid values..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ExtentNotIntersectsWithBoundingBox">
            <summary>
              Looks up a localized string similar to The passed extent needs to intersect with the bounding box of the gid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ExternalProjectionParametersStringIsNotEPSG4326">
            <summary>
              Looks up a localized string similar to The ExternalProjectionParametersString of the projection must be the projection string of Wgs84 or &quot;EPSG:4326&quot;..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to The collection of Features may not be empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureColumnValueDoesNotContainColon">
            <summary>
              Looks up a localized string similar to The feature column values should be entered as string[] {&quot;Key1:Value1&quot;, &quot;Key2:Value2&quot;}.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureIsInvalidInThisStyle">
            <summary>
              Looks up a localized string similar to The feature is invalid in in this style..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureIsNotValid">
            <summary>
              Looks up a localized string similar to The Feature you provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceCanNotExecuteSqlQuery">
            <summary>
              Looks up a localized string similar to Executing sql queries is not supported and the user should always check the CanExecuteSqlQueries to ensure the FeatureSource support it before calling..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceCanNotModifyColumn">
            <summary>
              Looks up a localized string similar to The FeatureSource column structure can not be modified. Please check the &apos;CanModifyColumnStructure&apos; property at first..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to There are no FeatureSources..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceColumnCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to The collection of FeatureSourceColumns may not be empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceIsAlreadyInTransaction">
            <summary>
              Looks up a localized string similar to The FeatureSource is already in a transaction..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The FeatureSource is already opened..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceIsInTransaction">
            <summary>
              Looks up a localized string similar to The operation is invalid when it&apos;s in a transaction..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceIsNotEditable">
            <summary>
              Looks up a localized string similar to The FeatureSource is not editable..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceIsNotInTransaction">
            <summary>
              Looks up a localized string similar to The FeatureSource is not in a transaction..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FeatureSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The FeatureSource is not open.   Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FieldNameIsNotInFeature">
            <summary>
              Looks up a localized string similar to The requested column name is not in the Feature..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileAccessError">
            <summary>
              Looks up a localized string similar to File access error, you should open the shape file with ReadWrite mode..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileAlreadyExists">
            <summary>
              Looks up a localized string similar to The file already exists..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileFormatIsWrong">
            <summary>
              Looks up a localized string similar to The file&apos;s format is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileGeoDatabaseDllNotExists">
            <summary>
              Looks up a localized string similar to The File GeoDatabase unmanaged assemblies cannot be found..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileIsNotExist">
            <summary>
              Looks up a localized string similar to The file specified does not exist..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileIsSupportedByCommonImageSource">
            <summary>
              Looks up a localized string similar to This file type is not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FileNotSupportedForSql">
            <summary>
              Looks up a localized string similar to One of the fields in the database is not supported by SQL. The first character of this field name must be an alphabetic letter..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.FirstClassBreakValueError">
            <summary>
              Looks up a localized string similar to The first ClassBreak value should be double.MinValue..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GdipLoadImageFromFileError">
            <summary>
              Looks up a localized string similar to GDI+ threw a status error code..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeoCacheIsNotOpen">
            <summary>
              Looks up a localized string similar to The GeoCache is not open.  Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeocanvasIsNotInDrawing">
            <summary>
              Looks up a localized string similar to The GeoCanvas is currently not drawing.  Please call the BeginDraw method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeographicUnitNotValidWithGoogle">
            <summary>
              Looks up a localized string similar to The map unit you are using is not compatable with the GoogleLayer .  Make sure you are using Meters and that your projection is 90013 to ensure compatability..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeographicUnitNotValidWithOpenStreetMap">
            <summary>
              Looks up a localized string similar to The map unit you are using is not compatable with the OpenStreetMap .  Make sure you are using Meters to ensure compatability with OpenStreetMap service..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeoImageIsNotValid">
            <summary>
              Looks up a localized string similar to The input GeoImage object is not a valid GeoImage type..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeometriesInvalidExist">
            <summary>
              Looks up a localized string similar to We have found geometries that are invalid according to the SQL Server STIsValid() Function. To automaticly fix these you can call the MakeAllGeometriesValid method. The SQL To Determine which records are invalid:.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GeometrytypeIsWrong">
            <summary>
              Looks up a localized string similar to Geometry type not recognized. .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GettingSridNotSupported">
            <summary>
              Looks up a localized string similar to The current GeoImage implementation does not support the GetSrid operation..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GoogleApiKeyNotSupport">
            <summary>
              Looks up a localized string similar to Google has asked us to remove these API as they were not the correct ways to call their service.  The implementation of these API will now throw an exception if called.  We are sorry for the inconvenience however the immediate changes were necessary..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GraphicsCanvasWidthHeightNotSet">
            <summary>
              Looks up a localized string similar to GraphicsGeoCanvas&apos; Width and Height must be properly set before calling BeginDrawing()..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GridInterpolationModelDoesNotWork">
            <summary>
              Looks up a localized string similar to The input GridInterpolationModel is not able to replace all the NoData value..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.GroupLayerIsEmpty">
            <summary>
              Looks up a localized string similar to You must have at least one layer..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.HtmlColorIsInvalid">
            <summary>
              Looks up a localized string similar to The input string HtmlColor is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.IdColumnCannotBeNullOrEmpty">
            <summary>
              Looks up a localized string similar to Id column can&apos;t be null or empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.IEnumerableIsEmptyOrNull">
            <summary>
              Looks up a localized string similar to The collection may not be empty or null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ImageInPointStyleCanNotBeNull">
            <summary>
              Looks up a localized string similar to The image property can&apos;t be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ImageScaleShouldBiggerThanZero">
            <summary>
              Looks up a localized string similar to The ImageScaled property must be larger than 0..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ImageSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is not open.  Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.IndexFileAlreadyExists">
            <summary>
              Looks up a localized string similar to Index File already exist, please change the BuildIndexMode if you want to rebuild this index..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.IndexFileIsInvalid">
            <summary>
              Looks up a localized string similar to The format of your index file is not valid, please check. Or you can use BuildIndexFile function to build a new one..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.IndexFileNotExisted">
            <summary>
              Looks up a localized string similar to You don&apos;t have the corresponding idx file for your shape file. You can use the static method ShapeFileFeatureSource.BuildIndexFile() or ShapeFileFeatureLayer.BuildIndexFile()  to build an idx file for the shape file, or you can set the RequireIndex property to false..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.InputGeometryTypeIsNotValid">
            <summary>
              Looks up a localized string similar to Input Geometry Type Is Not Valid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.InvalidGeometryInMsSqlForSpatialQuery">
            <summary>
              Looks up a localized string similar to There&apos;re some invalid geometry instance in table not valid. About invalid geometry please have a look at http://msdn.microsoft.com/en-us/library/bb933890.aspx website. To solve this problem, we provide MakeAllGeometryValid function to make the invalid geometry to be valid, because of the function updating your data, you need to backup your data before using this function..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.InvalidOperationExceptionError">
            <summary>
              Looks up a localized string similar to Invalid Operation Exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.InvalidOperationOnALockedVariable">
            <summary>
              Looks up a localized string similar to It cannot be changed  until the layer/featureSource is closed.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.IsNotSupportedNowForProjection">
            <summary>
              Looks up a localized string similar to  is not supported now for projection..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ItemNotFoundInGeoCollectionByItem">
            <summary>
              Looks up a localized string similar to The GeoCollection does not contain the item you specified..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ItemNotFoundInGeoCollectionByKey">
            <summary>
              Looks up a localized string similar to The GeoCollection does not contain the item you specified..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.JpegImageCompressionShouldBeBetweenZeroAndOneHundred">
            <summary>
              Looks up a localized string similar to The value should be between zero and one hundred..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.KeyColorIsNotSupported">
            <summary>
              Looks up a localized string similar to Do not support KeyColor in the specify GeoCanvas..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.LayerDoesNotHaveBoundingBox">
            <summary>
              Looks up a localized string similar to This Layer doesn&apos;t have a boundingBox..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.LayersTypeIsOutOfRange">
            <summary>
              Looks up a localized string similar to The layer type you have provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.LongIsGreaterThanUInt32MaxValue">
            <summary>
              Looks up a localized string similar to The provided long input is greater than the maximum value of uint32..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MapEngineCurrentExtentIsNotValid">
            <summary>
              Looks up a localized string similar to The current extent you have provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MapEngineCurrentExtentIsNull">
            <summary>
              Looks up a localized string similar to The current extent you have provided may not be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MaxNestingDepthOverflow">
            <summary>
              Looks up a localized string similar to Maximum nesting depth has been reached..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MGRSInvalid">
            <summary>
              Looks up a localized string similar to The input MGRS string is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MrSidGeoImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The MrSidGeoImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MrSidGeoImageSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The MrSidGeoImageSource is not open.  Please open it before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MultiFieldNamesNotSupportedError">
            <summary>
              Looks up a localized string similar to The format of Multi-FieldNames isn&apos;t correct..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MultiLineCannotReorderForInputParams">
            <summary>
              Looks up a localized string similar to Can&apos;t Reorder for the multi-line because it does not satisfy the reorder condition based on the given startPoint and given tolerance..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.MultiLineInvalidForReorder">
            <summary>
              Looks up a localized string similar to Can&apos;t Reorder for the multi-line because it does not satisfy the reorder condition based on the given tolerance..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.NotAllValidLayersAreOpen">
            <summary>
              Looks up a localized string similar to Not all valid layers are open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.NotSupported">
            <summary>
              Looks up a localized string similar to This feature is currently not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.NotSupportedFileType">
            <summary>
              Looks up a localized string similar to The file type you provided is currently not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.NotSupportedSqlQueryMode">
            <summary>
              Looks up a localized string similar to The SQL Query mode is not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.NumberShouldBeByte">
            <summary>
              Looks up a localized string similar to The number should be between 0 and 255.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ParameterCanNotConvert">
            <summary>
              Looks up a localized string similar to We cannot get the AreaUnit from input unit..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ParameterIdsIsNotIntegers">
            <summary>
              Looks up a localized string similar to Parameter Ids should be from 1 to the record number in ShapeFileFeatureSource.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ParameterIsEmpty">
            <summary>
              Looks up a localized string similar to The parameter you supplied may not be empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ParameterIsInvalid">
            <summary>
              Looks up a localized string similar to The shape you provided does not pass our simple validation..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ParameterIsNull">
            <summary>
              Looks up a localized string similar to The parameter you supplied may not be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ParameterIsTransparent">
            <summary>
              Looks up a localized string similar to The parameter is transparent..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.PrinterLayerGeographyUnitDoesNotSupported">
            <summary>
              Looks up a localized string similar to Printer layer supports Feet or Meter only.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ProductNotInstalled">
            <summary>
              Looks up a localized string similar to The product has not been installed on the machine, please go to Map Suite Product Center to start evaluation or activate it..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ProjectedTileCacheWithTileCacheIssue">
            <summary>
              Looks up a localized string similar to The parameter {0} is required if the ProjectedTileCache and TileCache are used at the same time..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ProjectionInitializationError">
            <summary>
              Looks up a localized string similar to Projection initialization failed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ProjectionInternalGeographyIsUnknown">
            <summary>
              Looks up a localized string similar to Cannot get the projection’s InternalGeographyUnit, please provide it by overriding the Projection’s GetInternalGeographyUnitCore() method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ProjectionIsNotOpen">
            <summary>
              Looks up a localized string similar to The projection is not open.  Please open it before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RasterLayerDoesNotHaveProjectionInformation">
            <summary>
              Looks up a localized string similar to This RasterLayer does not have projection information embedded in it.  If you wish to avoid this exception you can first check the HasProjectionTextProperty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RasterProjectionNotImplemented">
            <summary>
              Looks up a localized string similar to Convert Raster to External Projection by default is not implemented, please override this method if needed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RasterSourceNotContainsProjectionInformation">
            <summary>
              Looks up a localized string similar to This RasterSource does not have projection information embedded in it.  If you wish to avoid this exception you can first check the HasProjectionTextProperty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RebuildDbfFailed">
            <summary>
              Looks up a localized string similar to The rebuild of the DBF failed for an unknown reason.  Please see the inner exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RebuildIdxFailed">
            <summary>
              Looks up a localized string similar to The spatial index generation failed for an unknown reason.    Please see the inner exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RebuildShapeFileFailed">
            <summary>
              Looks up a localized string similar to the rebuilding of the shape file failed for an unknown reason.    Please see the inner exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RecordIsInvalid">
            <summary>
              Looks up a localized string similar to The record is invalid, please call Validate method to check the failed reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ReturnTypeNotCorrect">
            <summary>
              Looks up a localized string similar to This operation&apos;s return type is not correct..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ReturnValueIsNull">
            <summary>
              Looks up a localized string similar to Return value is null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RingShapeIsInvalidForOperationVertexCountLessThan4">
            <summary>
              Looks up a localized string similar to This ring is not closed.  To close a ring the last point must be the same as the first point.  All rings must have at least four points..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RotateNotSupported">
            <summary>
              Looks up a localized string similar to Rotation is not supported on this class..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RowNumberExceedTotalRowCount">
            <summary>
              Looks up a localized string similar to The parameter row exceeds the total row count..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.RtreeSpatialIndexIsNotOpen">
            <summary>
              Looks up a localized string similar to The RtreeSpatialIndex is not open.   Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapeFileBoundingBoxIsValid">
            <summary>
              Looks up a localized string similar to The shape file bounding box is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapefileFeatureSourceIdNotFromZero">
            <summary>
              Looks up a localized string similar to The Shapefile Id is one based, zero is an invalid Id..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapeFileInnerRingNotContainedInOuterRing">
            <summary>
              Looks up a localized string similar to An InnerRing doesn&apos;t contained in any OuterRing. .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapeFileNameIsInvalid">
            <summary>
              Looks up a localized string similar to The shape file name is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapeIsInvalidForOperation">
            <summary>
              Looks up a localized string similar to The shape you provided does not pass our simple validation..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapeIsInvalidForValidation">
            <summary>
              Looks up a localized string similar to There are no points in the shape..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapeTypeNotImplement">
            <summary>
              Looks up a localized string similar to This shape has not been implemented yet..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShapesNotIntersectWithTolerance">
            <summary>
              Looks up a localized string similar to The {0} doesn&apos;t intersect the {1}..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.ShxFileIsNotOpen">
            <summary>
              Looks up a localized string similar to The shape file index is not open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.SpatialIndexIsNotRemovable">
            <summary>
              Looks up a localized string similar to The features in SpatialIndex are not removable..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.SqlTypesRequired">
            <summary>
              Looks up a localized string similar to To use this method, you have to reference Microsoft.SqlServer.Types.dll, and copy folder[Install-Path]\\Developer Reference\\[Product]\\SqlServerTypes_X64(SqlServerTypes_X86) to System32\\Map Suite *.* folder for x86/x64 platform..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.SridIsInvalid">
            <summary>
              Looks up a localized string similar to Input srid is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.StreamIsNotWritable">
            <summary>
              Looks up a localized string similar to Stream is not writable..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.StringIsNotBlank">
            <summary>
              Looks up a localized string similar to The input string value is not blank..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.TabIndexFileNotExisted">
            <summary>
              Looks up a localized string similar to The corresponding idx/ids file cannot be found. Please use the static method TabFeatureSource.BuildIndexFile() or TabFeatureLayer.BuildIndexFile() to build the idx/ids file, which can greatly improve the querying performance. If the RequireIndex Property is set to false, the idx/ids files will not be checked and an internal spatial index will be created instead..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.TabSymbolNumberNotExists">
            <summary>
              Looks up a localized string similar to The Tab Symbol style number is not exists..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.TargetShapeIsNotValidType">
            <summary>
              Looks up a localized string similar to Target Shape Is Not Valid Type..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.TheFieldTtypeShouldBeNumeric">
            <summary>
              Looks up a localized string similar to The field type should be numeric..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.TheFormatOfImageIsNotSupported">
            <summary>
              Looks up a localized string similar to The format of the image is not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.TheValueShouldBeGreaterThanZero">
            <summary>
              Looks up a localized string similar to The value should be greater than zero..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.Unlicensed">
            <summary>
              Looks up a localized string similar to Unlicensed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.UnsupportedEditingShapeType">
            <summary>
              Looks up a localized string similar to Currently we do not support editing this kind of shape type. Shape type:.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.UpdateTansactionError">
            <summary>
              Looks up a localized string similar to The update transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.UriNotValid">
            <summary>
              Looks up a localized string similar to The input Uri is not valid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.UseGeoTiffRasterInstead">
            <summary>
              Looks up a localized string similar to The TIFF files(.tif or .tiff) are not supported in GdiPlusRasterSource any longer, please use the GeoTiffRasterSource instead..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WkbIsInvalid">
            <summary>
              Looks up a localized string similar to The format of the well known binary is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WkbIsNotValidForDrawing">
            <summary>
              Looks up a localized string similar to The well known binary is not valid for drawing..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WkbTypeError">
            <summary>
              Looks up a localized string similar to The well known binary type is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WktFormatIsWrong">
            <summary>
              Looks up a localized string similar to The format of the well known text is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WmsGetMapTimeOut">
            <summary>
              Looks up a localized string similar to The Wms server has timed out..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WorldExtentIsNotValid">
            <summary>
              Looks up a localized string similar to The world extent is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WorldFileShould6Lines">
            <summary>
              Looks up a localized string similar to World file should has 6 lines..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WpfCommonGeoImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.ExceptionDescription.WpfCommonGeoImageSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is not opened.  Please open it before calling this method..
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ClusterTolerenceStatusChanged">
            <summary>
              Looks up a localized string similar to ClusterTolerenceStatusChanged(new object(), e).
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.Datums">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.Ellps">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ESPG">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ESRI">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ESRIExtra">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.Meridians">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.Proj">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.Unit">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.LDID">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.DrawExceptionRedCross">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.LoadingTile">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.NoImageTile">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.BMPImageFormatGUID">
            <summary>
              Looks up a localized string similar to b96b3cab-0728-11d3-9d7b-0000f81ef32e.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.GIFImageFormatGUID">
            <summary>
              Looks up a localized string similar to b96b3cb0-0728-11d3-9d7b-0000f81ef32e.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ICOImageFormatGUID">
            <summary>
              Looks up a localized string similar to b96b3cb5-0728-11d3-9d7b-0000f81ef32e.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.JPEGImageFormatGUID">
            <summary>
              Looks up a localized string similar to b96b3cae-0728-11d3-9d7b-0000f81ef32e.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.ParameterIsNull">
            <summary>
              Looks up a localized string similar to The parameter you supplied may be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.VectorMapIcon">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Resources.VectorMapIconName">
            <summary>
              Looks up a localized string similar to ThinkgeoFont.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.CSharpGeoCodeFormatter">
            <summary>
            This class formats a GeoObjectModel into C# code.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CSharpGeoCodeFormatter.#ctor">
            <summary>
            Creates an instance of CSharpGeoCodeFormatter.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CSharpGeoCodeFormatter.SaveCore(ThinkGeo.MapSuite.Serialize.GeoObjectModel,System.IO.Stream)">
            <summary>
            Creates C# code for a GeoObjectModel and save the code into a Stream.
            </summary>
            <param name="model">The GeoObjectModel to generate C# code for.</param>
            <param name="stream">The Stream to save C# code into.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoCodeFormatter">
            <summary>
            This class formats a GeoObjectModel into program code.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeFormatter.#ctor">
            <summary>
            Creates an instance of GeoCodeFormatter.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeFormatter.Save(ThinkGeo.MapSuite.Serialize.GeoObjectModel,System.IO.Stream)">
            <summary>
            Creates code for a GeoObjectModel and save the code into a Stream.
            </summary>
            <param name="model">The GeoObjectModel to generate code for.</param>
            <param name="stream">The Stream to save code into.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeFormatter.SaveCore(ThinkGeo.MapSuite.Serialize.GeoObjectModel,System.IO.Stream)">
            <summary>
            Creates code for a GeoObjectModel and save the code into a Stream.
            </summary>
            <param name="model">The GeoObjectModel to generate code for.</param>
            <param name="stream">The Stream to save code into.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoCodeGenerator">
            <summary>
            This class generates code that recreates any given object.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoCodeGenerator.Formatter">
            <summary>
            Gets or sets the Formatter.
            The Formatter determines what kind of program code will be generated.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeGenerator.#ctor">
            <summary>
            Creates an instance of GeoCodeGenerator.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeGenerator.GenerateCode(System.Object)">
            <summary>
            Generates code that recreates an object.
            </summary>
            <param name="sourceObject">The object to generate code for.</param>
            <returns>The generated code.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeGenerator.GenerateCode(System.Object,System.String)">
            <summary>
            Generates code that recreates an object.
            </summary>
            <param name="sourceObject">The object to generate code for.</param>
            <param name="pathFilename">The path to save the generated code.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoCodeGenerator.GenerateCode(System.Object,System.IO.Stream)">
            <summary>
            Generates code that recreates an object.
            </summary>
            <param name="sourceObject">The object to generate code for.</param>
            <param name="stream">The stream to save the generated code into.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs">
            <summary>
            This class represents the parameters passed in through the CreatedMemberNode
            event.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.#ctor">
            <summary>
            Creates an instance of MemberNodeCreatedGeoObjectModelerEventArgs.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.#ctor(System.String,System.Object,System.Type,System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates an instance of MemberNodeCreatedGeoObjectModelerEventArgs with name, value, type, owner and node.
            </summary>
            <param name="name">The name of the member.</param>
            <param name="value">The value of the member.</param>
            <param name="type">The type of the member.</param>
            <param name="owner">The owner of the member.</param>
            <param name="node">The node of the member.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.Name">
            <summary>
            Gets or sets the name of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.Value">
            <summary>
            Gets or sets the value of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.Type">
            <summary>
            Gets or sets the type of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.Owner">
            <summary>
            Gets or sets the owner of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberNodeGeoObjectModelerEventArgs.Node">
            <summary>
            Gets or sets the node of the member.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs">
            <summary>
            This class represents the parameters passed in through the CreatedMemberObject
            event.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs.#ctor">
            <summary>
            Creates an instance of MemberObjectCreatedGeoObjectModelerEventArgs.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs.#ctor(System.String,System.Object,System.Type,System.Object)">
            <summary>
            Creates an instance of MemberObjectCreatedGeoObjectModelerEventArgs with name, value, type and owner.
            </summary>
            <param name="name">The name of the member.</param>
            <param name="value">The value of the member.</param>
            <param name="type">The type of the member.</param>
            <param name="owner">The owner of the member.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs.Name">
            <summary>
            Gets or sets the name of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs.Value">
            <summary>
            Gets or sets the value of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs.Type">
            <summary>
            Gets or sets the type of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatedMemberObjectGeoObjectModelerEventArgs.Owner">
            <summary>
            Gets or sets the owner of the member.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs">
            <summary>
            This class represents the parameters passed in through the CreatingMemberNode
            event.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs.#ctor">
            <summary>
            Creates an instance of CreatingMemberNodeGeoObjectModelerEventArgs.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs.#ctor(System.String,System.Object,System.Type,System.Object)">
            <summary>
            Creates an instance of CreatingMemberNodeGeoObjectModelerEventArgs with name, value, type and owner.
            </summary>
            <param name="name">The name of the member.</param>
            <param name="value">The value of the member.</param>
            <param name="type">The type of the member.</param>
            <param name="owner">The owner of the member.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs.Name">
            <summary>
            Gets or sets the name of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs.Value">
            <summary>
            Gets or sets the value of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs.Type">
            <summary>
            Gets or sets the type of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberNodeGeoObjectModelerEventArgs.Owner">
            <summary>
            Gets or sets the owner of the member.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs">
            <summary>
            This class represents the parameters passed in through the CreatingMemberObject
            event.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs.#ctor">
            <summary>
            Creates an instance of CreatingMemberObjectGeoObjectModelerEventArgs.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs.#ctor(System.String,System.Type,System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates an instance of CreatingMemberObjectGeoObjectModelerEventArgs with name, type, owner and node.
            </summary>
            <param name="name">The name of the member.</param>
            <param name="value">The value of the member.</param>
            <param name="owner">The owner of the member.</param>
            <param name="node">The node of the member.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs.Name">
            <summary>
            Gets or sets the name of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs.Type">
            <summary>
            Gets or sets the type of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs.Owner">
            <summary>
            Gets or sets the owner of the member.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.CreatingMemberObjectGeoObjectModelerEventArgs.Node">
            <summary>
            Gets or sets the node of the member.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoObjectModel">
            <summary>
            This class represent the model of a top level object.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectModel.Name">
            <summary>
            Gets or sets the Name of the model.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectModel.RootNode">
            <summary>
            Gets or sets the RootNode of the model.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModel.#ctor">
            <summary>
            Creates an instance of GeoObjectModel.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModel.#ctor(System.String,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates an instance of GeoObjectModel with a given name and a root node.
            </summary>
            <param name="name">The name.</param>
            <param name="rootNode">The root node.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoObjectModeler">
            <summary>
            This class creates models for objects and recreates objects from models.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreatingMemberNode">
            <summary>
            This event happens when the modeler is creating a node for a member(field or property).
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreatedMemberNode">
            <summary>
            This event happens when the modeler has created a node for a member(field or property).
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreatingMemberObject">
            <summary>
            This event happens when the modeler is recreating an object from a node.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreatedMemberObject">
            <summary>
            This event happens when the modeler has created an object from a node.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.#ctor">
            <summary>
            Creates an instance of GeoObjectModeler.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreateModel(System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectModelerMemberTypes,System.Reflection.BindingFlags,ThinkGeo.MapSuite.Serialize.GeoObjectModelerDefaultValueMode)">
            <summary>
            Creates model for an object.
            </summary>
            <param name="objectToModel">The object to model.</param>
            <param name="memberTypes">The member types.</param>
            <param name="bindingFlags">The binding flags.</param>
            <param name="defaultValueMode">The default value mode.</param>
            <returns>The model that represent the object.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreateObject(ThinkGeo.MapSuite.Serialize.GeoObjectModel)">
            <summary>
            Creates an object from a model.
            </summary>
            <param name="model">The model.</param>
            <returns>The object recreated from the model.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.GetMembers(System.Type,ThinkGeo.MapSuite.Serialize.GeoObjectModelerMemberTypes)">
            <summary>
            Gets members of a type.
            </summary>
            <param name="type">The type.</param>
            <param name="memberTypes">The member types.</param>
            <returns>The members of a type.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.GetMembersCore(System.Type,ThinkGeo.MapSuite.Serialize.GeoObjectModelerMemberTypes)">
            <summary>
            Gets members of a type.
            </summary>
            <param name="type">The type.</param>
            <param name="memberTypes">The member types.</param>
            <returns>The members of a type.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreateMemberNode(System.String,System.Object,System.Type,System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates a node for a member.
            </summary>
            <param name="memberName">The member name.</param>
            <param name="memberValue">The member value.</param>
            <param name="memberType">The member type.</param>
            <param name="memberOwner">The member's owner(parent) object.</param>
            <param name="baseMemberNode">The base(parent) member node.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreateMemberNodeCore(System.String,System.Object,System.Type,System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates a node for a member.
            </summary>
            <param name="memberName">The member name.</param>
            <param name="memberValue">The member value.</param>
            <param name="memberType">The member type.</param>
            <param name="memberOwner">The member's owner(parent) object.</param>
            <param name="baseMemberNode">The base(parent) member node.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreateMemberObject(System.String,System.Type,System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates an object from a node.
            </summary>
            <param name="memberName">The member name.</param>
            <param name="memberType">The member type.</param>
            <param name="memberOwner">The member's owner(parent) object.</param>
            <param name="memberNode">The member node.</param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectModeler.CreateMemberObjectCore(System.String,System.Type,System.Object,ThinkGeo.MapSuite.Serialize.GeoObjectNode)">
            <summary>
            Creates an object from a node.
            </summary>
            <param name="memberName">The member name.</param>
            <param name="memberType">The member type.</param>
            <param name="memberOwner">The member's owner(parent) object.</param>
            <param name="memberNode">The member node.</param>
            <returns></returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoObjectModelerDefaultValueMode">
            <summary>
            Indicates how the default value of a member will be dealt with by the modeler.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Serialize.GeoObjectModelerDefaultValueMode.IncludeDefaultValues">
            <summary>
            Indicates that the default value of a member will be included by the modeler.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Serialize.GeoObjectModelerDefaultValueMode.ExcludeDefaultValues">
            <summary>
            Indicates that the default value of a member will be excluded by the modeler.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoObjectModelerMemberTypes">
            <summary>
            Indicate the kind of member that will be modeled by the modeler.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Serialize.GeoObjectModelerMemberTypes.Fields">
            <summary>
            Indicates that the fields of an object will be modeled by the modeler.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Serialize.GeoObjectModelerMemberTypes.Properties">
            <summary>
            Indicates that the properties of an object will be modeled by the modeler.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoObjectNode">
            <summary>
            This class represent the model of an object.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectNode.Name">
            <summary>
            Gets or sets the Name of the node.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectNode.Parent">
            <summary>
            Gets or sets the Parent of the node.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectNode.Children">
            <summary>
            Gets the Children of the node.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectNode.Attributes">
            <summary>
            Gets the Attribute of the node.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectNode.Value">
            <summary>
            Gets or sets the Value of the node.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoObjectNode.IsDefaultValue">
            <summary>
            Gets or sets the IsDefaultValue of the node.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectNode.#ctor">
            <summary>
            Creates an instance of GeoObjectNode.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectNode.#ctor(System.String)">
            <summary>
            Creates an instance of GeoObjectNode with a name.
            </summary>
            <param name="name">The name of this node.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoObjectNode.ToString">
            <summary>
            Returns a string that contains the name, children count and attribute count of this node.
            </summary>
            <returns>The string that contains the name, children count and attribute count of this node.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.NonSerializableBaseTypeAttribute">
            <summary>
            Indicates that a type's base type should not be serialized.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.NonSerializableBaseTypeAttribute.#ctor">
            <summary>
            Creates an instance of NonSerializableBaseTypeAttribute.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.OnGeodeserializedAttribute">
            <summary>
            When applied to a method, specifies that the method is called immediately after deserialization of the object.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.OnGeodeserializedAttribute.#ctor">
            <summary>
            Initializes a new instance of the OnGeodeserializedAttribute class.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.OnGeodeserializingAttribute">
            <summary>
            When applied to a method, specifies that the method is called during deserialization of an object.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.OnGeodeserializingAttribute.#ctor">
            <summary>
            Initializes a new instance of the OnGeodeserializingAttribute class.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.OnGeoserializedAttribute">
            <summary>
            When applied to a method, specifies that the method is called after serialization of an object graph.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.OnGeoserializedAttribute.#ctor">
            <summary>
            Initializes a new instance of the OnGeoserializedAttribute class.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.OnGeoserializingAttribute">
            <summary>
            When applied to a method, specifies that the method is called before serialization of an object.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.OnGeoserializingAttribute.#ctor">
            <summary>
            Initializes a new instance of the OnGeoserializingAttribute class.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter">
            <summary>
            This class formats a GeoObjectModel into serialized data.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter.#ctor">
            <summary>
            Creates an instance of GeoSerializationFormatter.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter.Encoding">
            <summary>
            set or get the readEncoding.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter.Save(ThinkGeo.MapSuite.Serialize.GeoObjectModel,System.IO.Stream)">
            <summary>
            Save serialized data into a stream.
            </summary>
            <param name="model">The GeoObjectModel to create serialized data for.</param>
            <param name="stream">The Stream to save serialized data into.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter.SaveCore(ThinkGeo.MapSuite.Serialize.GeoObjectModel,System.IO.Stream)">
            <summary>
            Format a GeoObjectModel into serialized data, and save the data into a stream.
            </summary>
            <param name="model">The GeoObjectModel to create serialized data for.</param>
            <param name="stream">The Stream to save serialized data into.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter.Load(System.IO.Stream)">
            <summary>
            Load a stream into a GeoObjectModel.
            </summary>
            <param name="stream">The Stream to load from.</param>
            <returns>The GeoObjectModel recreated from the stream.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializationFormatter.LoadCore(System.IO.Stream)">
            <summary>
            Load a stream into a GeoObjectModel.
            </summary>
            <param name="stream">The Stream to load from.</param>
            <returns>The GeoObjectModel recreated from the stream.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.GeoSerializer">
            <summary>
            This class serializes an object.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Serialize.GeoSerializer.Formatter">
            <summary>
            Gets or sets the Formatter.
            The Formatter determines what kind of serialized data will be created.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.#ctor">
            <summary>
            Creates an instance of GeoSerializer.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Serialize(System.Object,System.String)">
            <summary>
            Serialize an object and save the serialized data to a file.
            </summary>
            <param name="objectToSerialize">The object to be serialized.</param>
            <param name="targetPathFilename">The path to save the serialized data to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Serialize(System.Object,System.IO.Stream)">
            <summary>
            Serialize an object and save the serialized data to a stream.
            </summary>
            <param name="objectToSerialize">The object to be serialized.</param>
            <param name="targetStream">The stream to save the serialized data into.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Serialize(System.Object)">
            <summary>
            Serialize an object and save the serialized data to a string.
            </summary>
            <param name="objectToSerialize">The object to be serialized.</param>
            <returns>The string that contains the serialized data.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Deserialize(System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>
            Recreates an object from a file.
            </summary>
            <param name="sourcePathFilename">The file path to deserialize from.</param>
            <param name="fileAccess">The ReadWriteMode</param>
            <returns>The recreated object.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Deserialize(System.IO.Stream)">
            <summary>
            Recreates an object from a stream.
            </summary>
            <param name="sourceStream">The Stream to deserialize from.</param>
            <returns>The recreated object.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Deserialize(System.String)">
            <summary>
            Recreates an object from a string.
            </summary>
            <param name="sourceString">The string to deserialize from.</param>
            <returns>The recreated object.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.GeoSerializer.Deserialize(System.Uri)">
            <summary>
            Recreates an object from an Url.
            </summary>
            <param name="sourceUri">The Url to deserialize from.</param>
            <returns>The recreated object.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Serialize.XmlGeoSerializationFormatter">
            <summary>
            This class formats a GeoObjectModel into XML.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.XmlGeoSerializationFormatter.#ctor">
            <summary>
            Creates an instance of GeoSerializationFormatter.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.XmlGeoSerializationFormatter.SaveCore(ThinkGeo.MapSuite.Serialize.GeoObjectModel,System.IO.Stream)">
            <summary>
            Format a GeoObjectModel into XML, and save the XML into a stream.
            </summary>
            <param name="model">The GeoObjectModel to create XML for.</param>
            <param name="stream">The Stream to save XML into.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Serialize.XmlGeoSerializationFormatter.LoadCore(System.IO.Stream)">
            <summary>
            Load a stream that contains XML into a GeoObjectModel.
            </summary>
            <param name="stream">The Stream that contains XML.</param>
            <returns>The GeoObjectModel recreated from the stream.</returns>
        </member>
        <member name="T:LicenseExceptionDescription">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:LicenseExceptionDescription.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:LicenseExceptionDescription.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:LicenseExceptionDescription.EvalNotInstall">
            <summary>
              Looks up a localized string similar to The evaluation edition has not been installed on the machine, please go to Map Suite Product Center to start evaluation or activate it..
            </summary>
        </member>
        <member name="P:LicenseExceptionDescription.EvaluationExpired">
            <summary>
              Looks up a localized string similar to The evaluation has expired.  Please go to Map Suite Product Center or contact ThinkGeo for purchasing option or an extension to the trial..
            </summary>
        </member>
    </members>
</doc>
